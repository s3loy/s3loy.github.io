<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA-and-pytorch</title>
    <url>/CUDA-and-pytorch/</url>
    <content><![CDATA[<h1 id="在win系统上安装pytorch"><a class="markdownIt-Anchor" href="#在win系统上安装pytorch"></a> 在win系统上安装pytorch</h1>
<h2 id="step-1-安装conda"><a class="markdownIt-Anchor" href="#step-1-安装conda"></a> Step 1 安装Conda</h2>
<p><a href="https://www.anaconda.com/download/success">Download Now | Anaconda</a></p>
<p><code>Anaconda</code>和<code>Miniconda</code>都可以，前者东西全一些，后者更为轻便。</p>
<p>展示的是<code>Anaconda</code></p>
<p><s>此处下载推荐使用魔法</s></p>
<blockquote>
<p>如果网络不支持那就使用<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
</blockquote>
<p><code>Anaconda3-2024.10-1-Windows-x86_64.exe</code>下载好之后打开</p>
<p>如果不想配置环境变量就选<code>All Users</code>吧。</p>
<p><img src="/CUDA-and-pytorch/image-20250218235016076-1740145143701-1.png" alt></p>
<p>然后推荐找个不是C盘的地方下</p>
<p><img src="/CUDA-and-pytorch/image-20250218235145695-1740145143701-2.png" alt></p>
<p><img src="/CUDA-and-pytorch/image-20250218235447531-1740145143701-4.png" alt></p>
<p>安装时间也许会比较长，别急。</p>
<p>装好之后可以测试一下<code>conda --version</code>,有这样的反应就好，版本不一定一样。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">conda <span class="literal">--version</span></span><br><span class="line">conda <span class="number">25.1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为我后面要玩<code>d2l</code>，所以就用<code>conda</code>创建了一个环境</p>
<p><code>conda create -n d2l python=3.10</code></p>
<p>这边<code>conda</code>是指令头，<code>-n</code> 是指定新环境的名称，<code>d2l</code> 是你想要为新环境指定的名称,<code>python=3.10</code>这部分指定了<code>python</code>的版本，不过其实不一定要<code>3.10</code>，<code>pytorch</code>官网上提示的是<code>Latest PyTorch requires Python 3.9 or later.</code>，加上学长爱用<code>3.10</code>，那就定了。<s>ps:3.10和3.9到底谁大呢</s></p>
<p>创建完成会提示的，后面需要激活一下</p>
<p><code>conda activate d2l</code></p>
<p>顺利的话就能看到<code>(d2l)</code>在输入的前面。</p>
<p>用的差不多之后要回到原来的环境的话就</p>
<p><code>conda deactivate</code></p>
<p>这样就回去了，不过你直接关掉重开也不是不行（</p>
<h2 id="step-2-cuda"><a class="markdownIt-Anchor" href="#step-2-cuda"></a> Step 2 CUDA</h2>
<p>笔记本电脑的GPU是<code>Nvidia 4060 laptop</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;nvidia-smi</span><br><span class="line">Wed Feb <span class="number">19</span> <span class="number">00</span>:<span class="number">07</span>:<span class="number">11</span> <span class="number">2025</span></span><br><span class="line">+-----------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI <span class="number">571</span>.<span class="number">96</span>                 Driver Version: <span class="number">571</span>.<span class="number">96</span>         CUDA Version: <span class="number">12</span>.<span class="number">8</span>     |</span><br><span class="line">|-----------------------------------------+------------------------+----------------------+</span><br><span class="line">| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                        |               MIG M. |</span><br><span class="line">|=========================================+========================+======================|</span><br><span class="line">|   <span class="number">0</span>  NVIDIA GeForce RTX <span class="number">4060</span> ...  WDDM  |   <span class="number">00000000</span>:<span class="number">01</span>:<span class="number">00</span>.<span class="number">0</span>  On |                  N/A |</span><br><span class="line">| N/A   <span class="number">39</span>C    P8              <span class="number">3</span>W /  <span class="number">115</span>W |    <span class="number">1533</span>MiB /   <span class="number">8188</span>MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">|                                         |                        |                  N/A |</span><br><span class="line">+-----------------------------------------+------------------------+----------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这边可以看到CUDA的版本</p>
<p>到<a href="https://developer.nvidia.com/cuda-downloads%E9%87%8C%E9%9D%A2%E5%8E%BB">https://developer.nvidia.com/cuda-downloads里面去</a></p>
<p><img src="/CUDA-and-pytorch/image-20250219000853416-1740145143701-3.png" alt></p>
<p>然后根据版本选一下，本地跑别乱选<code>network</code></p>
<p>然后点<code>Download</code>就行了</p>
<p><img src="/CUDA-and-pytorch/image-20250219001030527-1740145143701-5.png" alt></p>
<p>下载好的ok就行了，这步只是解压不是安装。</p>
<p>网上看教程说</p>
<p><img src="/CUDA-and-pytorch/image-20250219001140813-1740145143701-6.png" alt></p>
<p>我确实没勾这个，但是我下面的几个选项还是都装了。</p>
<p>安装好之后理论上环境变量是在的，可以先验证一下</p>
<p>在C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.8  (你安装的位置，默认是这样)打开终端</p>
<p>按顺序输入</p>
<p><code>cd .\extras\demo_suite</code></p>
<p><code>.\bandwidthTest.exe</code></p>
<p><code>.\deviceQuery.exe</code></p>
<p>回车测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd .\extras\demo_suite</span></span><br><span class="line"><span class="comment"># .\bandwidthTest.exe</span></span><br><span class="line">[<span class="type">CUDA</span> <span class="type">Bandwidth</span> <span class="type">Test</span>] - Starting...</span><br><span class="line">Running on...</span><br><span class="line"></span><br><span class="line"> Device <span class="number">0</span>: NVIDIA GeForce RTX <span class="number">4060</span> Laptop GPU</span><br><span class="line"> Quick Mode</span><br><span class="line"></span><br><span class="line"> Host to Device Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">12883.8</span></span><br><span class="line"></span><br><span class="line"> Device to Host Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">12835.4</span></span><br><span class="line"></span><br><span class="line"> Device to Device Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">196311.5</span></span><br><span class="line"></span><br><span class="line">Result = PASS</span><br><span class="line"></span><br><span class="line">NOTE: The CUDA Samples are not meant <span class="keyword">for</span> performance measurements. Results may vary when GPU Boost is enabled.</span><br><span class="line"><span class="comment"># .\deviceQuery.exe</span></span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.<span class="number">8</span>\extras\demo_suite\deviceQuery.exe Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API)</span><br><span class="line"></span><br><span class="line">Detected <span class="number">1</span> CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device <span class="number">0</span>: <span class="string">&quot;NVIDIA GeForce RTX 4060 Laptop GPU&quot;</span></span><br><span class="line">  CUDA Driver Version / Runtime Version          <span class="number">12.8</span> / <span class="number">12.8</span></span><br><span class="line">  CUDA Capability Major/Minor version number:    <span class="number">8.9</span></span><br><span class="line">  Total amount of global memory:                 <span class="number">8188</span> MBytes (<span class="number">8585216000</span> bytes)</span><br><span class="line">MapSMtoCores <span class="keyword">for</span> SM <span class="number">8.9</span> is undefined.  Default to use <span class="number">128</span> Cores/SM</span><br><span class="line">MapSMtoCores <span class="keyword">for</span> SM <span class="number">8.9</span> is undefined.  Default to use <span class="number">128</span> Cores/SM</span><br><span class="line">  (<span class="number">24</span>) Multiprocessors, (<span class="number">128</span>) CUDA Cores/<span class="built_in">MP</span>:     <span class="number">3072</span> CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            <span class="number">2370</span> MHz (<span class="number">2.37</span> GHz)</span><br><span class="line">  Memory Clock rate:                             <span class="number">8001</span> Mhz</span><br><span class="line">  Memory Bus Width:                              <span class="number">128</span><span class="literal">-bit</span></span><br><span class="line">  L2 Cache Size:                                 <span class="number">33554432</span> bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         <span class="number">1</span>D=(<span class="number">131072</span>), <span class="number">2</span>D=(<span class="number">131072</span>, <span class="number">65536</span>), <span class="number">3</span>D=(<span class="number">16384</span>, <span class="number">16384</span>, <span class="number">16384</span>)</span><br><span class="line">  Maximum Layered <span class="number">1</span>D Texture Size, (num) layers  <span class="number">1</span>D=(<span class="number">32768</span>), <span class="number">2048</span> layers</span><br><span class="line">  Maximum Layered <span class="number">2</span>D Texture Size, (num) layers  <span class="number">2</span>D=(<span class="number">32768</span>, <span class="number">32768</span>), <span class="number">2048</span> layers</span><br><span class="line">  Total amount of constant memory:               zu bytes</span><br><span class="line">  Total amount of shared memory per block:       zu bytes</span><br><span class="line">  Total number of registers available per block: <span class="number">65536</span></span><br><span class="line">  Warp size:                                     <span class="number">32</span></span><br><span class="line">  Maximum number of threads per multiprocessor:  <span class="number">1536</span></span><br><span class="line">  Maximum number of threads per block:           <span class="number">1024</span></span><br><span class="line">  Max dimension size of a thread block (x,y,z): (<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">64</span>)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (<span class="number">2147483647</span>, <span class="number">65535</span>, <span class="number">65535</span>)</span><br><span class="line">  Maximum memory pitch:                          zu bytes</span><br><span class="line">  Texture alignment:                             zu bytes</span><br><span class="line">  Concurrent <span class="built_in">copy</span> and kernel execution:          Yes with <span class="number">1</span> <span class="built_in">copy</span> engine(s)</span><br><span class="line">  Run time limit on kernels:                     Yes</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page<span class="literal">-locked</span> memory mapping:       Yes</span><br><span class="line">  Alignment requirement <span class="keyword">for</span> Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Disabled</span><br><span class="line">  CUDA Device Driver Mode (TCC or WDDM):         WDDM (Windows Display Driver Model)</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device supports Compute Preemption:            Yes</span><br><span class="line">  Supports Cooperative Kernel Launch:            Yes</span><br><span class="line">  Supports MultiDevice Co<span class="literal">-op</span> Kernel Launch:      No</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   <span class="number">0</span> / <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = <span class="number">12.8</span>, CUDA Runtime Version = <span class="number">12.8</span>, NumDevs = <span class="number">1</span>, Device0 = NVIDIA GeForce RTX <span class="number">4060</span> Laptop GPU</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure>
<p>如果有这样的就说明成功了</p>
<p>试一下<code>nvcc -V</code></p>
<p><img src="/CUDA-and-pytorch/876ee5e3b3266e2d56bdd5b30a2809cf-1739898997106-5-1740145143702-7.png" alt></p>
<h2 id="step-3-安装pytorch"><a class="markdownIt-Anchor" href="#step-3-安装pytorch"></a> Step 3 安装Pytorch</h2>
<p>这个安装靠的是<code>conda</code>虚拟环境下的<code>pip3</code>安装的完整<code>pytorch</code>,并没有使用<code>docker</code>镜像来部署,不过如果到了需要租显卡的时候，就需要再去学习使用<code>docker</code>来部署了。</p>
<p>先<code>conda activate d2l</code> 激活一下自己的环境  <em>别笨到自己环境名字都没改，当然你也叫d2l那我没意见</em></p>
<p><a href="https://pytorch.org/">PyTorch</a>打开这个网站，</p>
<p><img src="/CUDA-and-pytorch/image-20250219004200322-1740145143702-9.png" alt></p>
<p>选好要下载的，复制好下面这个<code>Run this Command</code></p>
<p>到前面准备好的<code>conda</code>环境去安装</p>
<p><s>需要魔法，否则可能会给你装疯，而且在查阅资料的时候发现用镜像有概率不能识别pytorch，即使你的pytorch是你的pytorch，但是你的pytorch不是你的pytorch</s></p>
<p><img src="/CUDA-and-pytorch/6dbdeed45283dcad3a1c1f91a769f6b3-1740145143702-8.png" alt></p>
<p>报警告不用慌张，不影响使用。如果是这样就安装好了。</p>
<p>下面就测试一下<code>pytorch</code>的使用情况</p>
<p><code>python</code></p>
<p><code>&gt;&gt;&gt; import torch</code></p>
<p>第一次应该会等很久，别乱动就是了</p>
<p><code>&gt;&gt;&gt; torch.cuda.is_available()</code></p>
<p>返回<code>true</code></p>
<p><code>&gt;&gt;&gt; import torch</code></p>
<p><code>&gt;&gt;&gt; torch.cuda.device_count()</code></p>
<p>返回<code>1</code></p>
<p>代表识别到一张显卡</p>
<p>大概就活了。</p>
<p><img src="/CUDA-and-pytorch/28dcd3a09bb512143de46b300b9d95e7-1740145143702-10.png" alt></p>
<p><code>exit()</code>退出去</p>
<p>简单的<code>pytorch</code>就装好了</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Network-Layer</title>
    <url>/Network-Layer/</url>
    <content><![CDATA[<h1 id="network-layer"><a class="markdownIt-Anchor" href="#network-layer"></a> Network Layer</h1>
<blockquote>
<p>网络层是<code>OSI</code>模型中的第三层，它负责在不同网络之间（端到端）提供数据包的路由和转发。网络互联的本质是通过<code>IP</code>协议实现的，而数据传输的基本单元是<code>IP</code>数据报。本章将详细介绍网络层的核心协议与技术。</p>
</blockquote>
<p>网络互连<code>本质</code>是通过<code>ip</code>实现的，<code>传输</code>是以<code>ip数据报</code>为介质。</p>
<h2 id="ip"><a class="markdownIt-Anchor" href="#ip"></a> IP</h2>
<p><code>IP</code>协议是无连接、不可靠的数据报服务。</p>
<ul>
<li><strong>无连接 (<code>Connectionless</code>)</strong>：发送方在发送数据前，不需要与接收方建立连接。每个数据报都是独立传输的，因此到达顺序、完整性都不能保证。</li>
<li><strong>不可靠 (<code>Unreliable</code>)</strong>：<code>IP</code>协议不提供错误恢复或重传机制。如果数据报在传输中丢失或损坏，<code>IP</code>层本身不会处理，而是交由上层协议（如<code>TCP</code>）来确保可靠性。</li>
</ul>
<h3 id="ipv4-数据报格式"><a class="markdownIt-Anchor" href="#ipv4-数据报格式"></a> IPv4 数据报格式</h3>
<p>一个<code>IP</code>数据报由<code>首部 (Header)</code>和<code>数据 (Data)</code>两部分组成。首部通常为20字节，包含了路由和转发所需的所有关键信息。</p>
<ul>
<li><strong>版本 (<code>Version</code>)</strong> (4位): 指示<code>IP</code>协议的版本，对于<code>IPv4</code>，该值为 4。</li>
<li><strong>首部长度 (<code>IHL - Internet Header Length</code>)</strong> (4位): 表示整个<code>IP</code>首部的长度，单位是 <strong>4字节</strong>（32位）。例如，如果该值为5，则首部长度为 5 * 4 = 20 字节。最小值为5（20字节），最大值为15（60字节）。</li>
<li><strong>服务类型 (<code>ToS - Type of Service</code>)</strong> (8位): 用于指定数据报的优先级和服务质量（<code>QoS</code>）要求，例如最小延迟、最大吞吐量等。</li>
<li><strong>总长度 (<code>Total Length</code>)</strong> (16位): 指示整个<code>IP</code>数据报（包括首部和数据）的总长度，单位是字节。最大长度为 <code>65535</code> 字节。</li>
<li><strong>标识 (<code>Identification</code>)</strong> (16位): 该字段唯一标识一个数据报。当数据报因为过大而被分片时，所有分片都将拥有相同的标识号，以便接收方能够将它们重新组装。</li>
<li><strong>标志 (<code>Flags</code>)</strong> (3位):
<ul>
<li>第1位：保留，必须为0。</li>
<li>第2位：<strong><code>DF (Don't Fragment)</code></strong>。如果设为1，则禁止路由器对该数据报进行分片。如果数据报过大而无法通过，路由器将丢弃它并返回一个<code>ICMP</code>错误消息。</li>
<li>第3位：<strong><code>MF (More Fragments)</code></strong>。如果设为1，表示后面还有更多的分片；如果为0，表示这是最后一个分片（或未分片）。</li>
</ul>
</li>
<li><strong>片偏移 (<code>Fragment Offset</code>)</strong> (13位): 指示当前分片在原始数据报中的位置。偏移量以 <strong><code>8字节</code></strong> 为单位。</li>
<li><strong>生存时间 (<code>TTL - Time to Live</code>)</strong> (8位): 设置数据报在网络中可以存活的最大跳数（经过的路由器数）。每经过一个路由器，<code>TTL</code>值减1。当<code>TTL</code>减为0时，路由器将丢弃该数据报，并向源主机发送一个<code>ICMP</code>超时消息。这可以防止数据报在网络中无限循环。</li>
<li><strong>协议 (<code>Protocol</code>)</strong> (8位): 指示<code>IP</code>数据报的数据部分承载的是哪个上层协议。例如，<code>6 </code>代表<code>TCP</code>，<code>17 </code>代表<code>UDP</code>，1 代表<code>ICMP</code>。</li>
<li><strong>首部检验和 (<code>Header Checksum</code>)</strong> (16位): 用于校验<code>IP</code>首部在传输过程中是否出错。它只对首部进行计算，不包括数据部分。</li>
<li><strong>源IP地址 (<code>Source IP Address</code>)</strong> (32位): 发送方设备的<code>IP</code>地址。</li>
<li><strong>目的IP地址 (<code>Destination IP Address</code>)</strong> (32位): 接收方设备的<code>IP</code>地址。</li>
<li><strong>选项 (<code>Options</code>)</strong> (可变长): 用于一些特殊处理，如记录路由、时间戳等。由于选项会增加首部长度并降低处理效率，因此不常用。如果存在，首部长度字段会大于5。</li>
</ul>
<h3 id="ip-分片-fragmentation"><a class="markdownIt-Anchor" href="#ip-分片-fragmentation"></a> IP 分片 (Fragmentation)</h3>
<p>当一个<code>IP</code>数据报的长度超过了链路的<strong>最大传输单元 (<code>MTU</code>)</strong> 时，路由器就需要将其分割成多个更小的数据报，这个过程称为分片。</p>
<ul>
<li>标识、标志和片偏移这三个字段共同协作，以确保分片能够在目的主机被正确地重组。</li>
<li>所有分片共享相同的标识号。</li>
<li>除了最后一个分片，其他所有分片的<code>MF</code>标志位都为1。</li>
<li>片偏移字段记录了每个分片数据在原始数据中的相对位置。</li>
</ul>
<hr>
<h2 id="icmp"><a class="markdownIt-Anchor" href="#icmp"></a> ICMP</h2>
<p><strong>ICMP</strong>：<code>Internet Control Message Protocol</code> ，因特网控制报文协议</p>
<p>方向：主机/路由器 -&gt; 源站(发送方)</p>
<p><img src="/Network-Layer/54070be665d2466175453f2c7153900f-1740404253149-1.jpeg" alt></p>
<p><code>代码</code> 提供了进一步的描述信息，在此不进一步提供描述信息，<s>即代码的代码（？</s>。</p>
<hr>
<p><strong>However</strong>, 首先想区分一下这边的四个字节vs图上的内容vs十六进制和二进制</p>
<p>图上的<code>0  8  16  31</code>一共有32位，指的是二进制的32位，这个<code>类型</code>是1字节，2个16进制。也就是在读数据报的时候你看到的是两个十六进制的字符。<s>然而图上很喜欢使用二进制长度来表示</s></p>
<p><code>8位二进制</code>=<code>2位十六进制</code>=<code>1字节</code></p>
<hr>
<table>
<thead>
<tr>
<th>类型字段</th>
<th>ICMP报文类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>回显应答 Echo Reply</td>
</tr>
<tr>
<td>3</td>
<td>目的不可达 Destination Unreachable</td>
</tr>
<tr>
<td>4</td>
<td>源抑制 Source Quench</td>
</tr>
<tr>
<td>5</td>
<td>路由重定向 Redirect (change a route)</td>
</tr>
<tr>
<td>8</td>
<td>回显请求 Echo Request</td>
</tr>
<tr>
<td>9</td>
<td>路由器广告 Router Advertisement</td>
</tr>
<tr>
<td>10</td>
<td>路由器请求 Router Solicitation</td>
</tr>
<tr>
<td>11</td>
<td>数据报超时 Time Exceeded for a Datagram</td>
</tr>
<tr>
<td>12</td>
<td>数据报参数问题 Parameter Problem on a Datagram</td>
</tr>
<tr>
<td>13</td>
<td>时间戳请求 Timestamp Request</td>
</tr>
<tr>
<td>14</td>
<td>时间戳应答 Timestamp Reply</td>
</tr>
<tr>
<td>15</td>
<td>信息请求（废弃） Information Request (obsolete)</td>
</tr>
<tr>
<td>16</td>
<td>信息应答（废弃） Information Reply (obsolete)</td>
</tr>
<tr>
<td>17</td>
<td>地址掩码请求 Address Mask Request</td>
</tr>
<tr>
<td>18</td>
<td>地址掩码应答 Address Mask Reply</td>
</tr>
</tbody>
</table>
<p><code>ICMP</code> 报文分为两大类</p>
<p><code>差错报告报文</code>和<code>提供信息的报文(询问报文)</code></p>
<ul>
<li>
<p>差错报告报文 (<code>Error Report Messages</code>)</p>
<ul>
<li>
<p><code>3</code> 目的不可达 <code>Destination Unreachable</code></p>
</li>
<li>
<p><code>4</code> 源抑制 <code>Source Quench</code></p>
</li>
<li>
<p><code>5</code> 路由重定向 <code>Redirect (change a route)</code></p>
</li>
<li>
<p><code>11</code> 数据报超时 <code>Time Exceeded for a Datagram</code></p>
</li>
<li>
<p><code>12</code> 数据报参数问题 <code>Parameter Problem on a Datagram</code></p>
</li>
</ul>
</li>
<li>
<p>提供信息的报文 (询问报文) (<code>Information Request/Inquiry Messages</code>)</p>
<ul>
<li>
<p><code>0</code> 回显应答 <code>Echo Reply</code></p>
</li>
<li>
<p><code>8</code> 回显请求 <code>Echo Request</code></p>
</li>
<li>
<p><code>9</code> 路由器广告 <code>Router Advertisement</code></p>
</li>
<li>
<p><code>10</code> 路由器请求 <code>Router Solicitation</code></p>
</li>
<li>
<p><code>13</code> 时间戳请求 <code>Timestamp Request</code></p>
</li>
<li>
<p><code>14</code> 时间戳应答 <code>Timestamp Reply</code></p>
</li>
<li>
<p><code>17</code> 地址掩码请求 <code>Address Mask Request</code></p>
</li>
<li>
<p><code>18</code> 地址掩码应答 <code>Address Mask Reply</code></p>
</li>
</ul>
</li>
</ul>
<p>其中<code>3</code>、<code>11</code>、<code>0</code>、<code>8</code>常用</p>
<p><code>3</code>、<code>11</code>是<code>差错报告报文</code></p>
<p><code>0</code>、<code>8</code>是<code>提供信息的报文</code></p>
<h3 id="几种常用icmp报文类型"><a class="markdownIt-Anchor" href="#几种常用icmp报文类型"></a> 几种常用ICMP报文类型</h3>
<h4 id="目的不可达报文3"><a class="markdownIt-Anchor" href="#目的不可达报文3"></a> 目的不可达报文（3）</h4>
<p>顾名思义，<code>目的不可达报文</code>就是目的不可达，<code>代码</code>部分进一步阐述</p>
<p><img src="/Network-Layer/eaba7cf385281339afc9f7083d44ea17-1740404253149-2.jpeg" alt></p>
<p>相当于<code>代码</code>那块就是<code>00</code>,<code>01</code>…这样的十六进制</p>
<blockquote>
<p><code>MTU</code>是指一个网络接口上能够传输的最大数据包大小。</p>
<p><code>路径最小MTU</code>影响数据在网络中的传输，尤其在路径中包含不同的网络设备时，如果路径中的任何设备不能处理过大的数据包，它就会丢弃该数据包或将其分片。</p>
<p>所以<code>“路径最小MTU发现”应用</code>可以实现 <code> MTU</code>探测 和 避免分片</p>
</blockquote>
<h4 id="超时报文11"><a class="markdownIt-Anchor" href="#超时报文11"></a> 超时报文（11）</h4>
<p><code>代码</code>说明超时的性质：</p>
<p><code>00</code>  传输过程中IP <code>TTL（time to live）</code>超时</p>
<p><code>01</code>   分片重装超时</p>
<blockquote>
<p>TTL超时可用于实现路由跟踪（<code>tracert</code>）</p>
<p><em>路由跟踪的工作原理总结：</em></p>
<ul>
<li>路由跟踪工具利用<code>TTL</code>字段逐步发送数据包，每次增加<code>TTL</code>值以遍历路径。</li>
<li>每经过一个路由器，<code>TTL</code>值会减1，直到数据包的<code>TTL</code>变为0，路由器丢弃数据包并返回一个<code>ICMP</code>“时间超时”消息。</li>
<li>通过收集每个中间路由器的回应，路由跟踪工具能够显示整个路径以及每跳的延迟。</li>
</ul>
</blockquote>
<p><img src="/Network-Layer/4c779b318b1952f5114d3ac31802c576_720-1740404253150-3.jpg" alt></p>
<h4 id="回应请求与应答报文-类型-8-和-0"><a class="markdownIt-Anchor" href="#回应请求与应答报文-类型-8-和-0"></a> <strong>回应请求与应答报文 (类型 8 和 0)</strong></h4>
<p>这是我们最熟悉的<code>ping</code>命令所使用的报文。</p>
<ul>
<li><strong>PING (<code>Packet InterNet Groper</code>)</strong>：用于测试两台主机之间的连通性。</li>
<li>主机A向主机B发送一个<code>ICMP</code>回显请求报文（类型8）。</li>
<li>如果主机B接收到该报文，它会回复一个<code>ICMP</code>回显应答报文（类型0）。</li>
<li><code>ping</code>是一个应用层程序直接使用网络层<code>ICMP</code>的典型例子，它绕过了传输层的<code>TCP</code>或<code>UDP</code>。</li>
</ul>
<hr>
<h2 id="arp-address-resolution-protocol"><a class="markdownIt-Anchor" href="#arp-address-resolution-protocol"></a> ARP (Address Resolution Protocol)</h2>
<p>在任何局域网（如以太网）中，数据帧的传输最终依赖的是<strong>MAC地址（物理地址）</strong>，而不是<code>IP</code>地址。那么，当一台主机（例如 <code>192.168.1.100</code>）想要与同一网络中的另一台主机（例如 <code>192.168.1.50</code>）通信时，它如何知道对方的<code>MAC</code>地址呢？这就是<code>ARP</code>协议的作用。</p>
<p><strong>定义</strong>：<code>ARP (Address Resolution Protocol)</code>，地址解析协议。它负责将一个已知的<code>IP</code>地址（网络层地址）解析（映射）为对应的MAC地址（数据链路层地址）。</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>检查<code>ARP</code>缓存</strong>：主机 A 首先会检查自己的 <strong><code>ARP</code>缓存表</strong>，看是否已经有目标<code>IP</code>地址 <code>192.168.1.50</code> 对应的<code>MAC</code>地址记录。如果存在，则直接使用该<code>MAC</code>地址封装数据帧并发送。</li>
<li><strong>发送<code>ARP</code>请求</strong>：如果在缓存中找不到记录，主机 A 会在局域网内广播一个 <strong><code>ARP</code>请求</strong> 报文。这个报文的核心内容是：“<strong>谁的<code>IP</code>地址是 192.168.1.50？请把你的<code>MAC</code>地址告诉我。</strong>” 这个请求是广播的，意味着网络内所有设备都会收到它。</li>
<li><strong>单播<code>ARP</code>响应</strong>：网络中的所有设备都会解析这个<code>ARP</code>请求。但只有<code>IP</code>地址为 <code>192.168.1.50</code> 的主机 B 会响应。主机 B 会直接向主机 A 发送一个 <strong><code>ARP</code>响应</strong> 报文（单播），内容是：“<strong>我的<code>IP</code>地址是 <code>192.168.1.50</code>，我的<code>MAC</code>地址是<code> XX:XX:XX:XX:XX:XX</code>。</strong>”</li>
<li><strong>更新<code>ARP</code>缓存</strong>：主机 A 收到响应后，就知道了主机 B 的<code>MAC</code>地址，并将这个映射关系（<code>IP -&gt; MAC</code>）存入自己的<code>ARP</code>缓存表中，以备后续使用。然后，它就可以将数据发送给主机 B 了。</li>
</ol>
<p><strong><code>ARP</code>缓存</strong>：每个主机都维护一个ARP缓存，用于存储近期解析过的<code>IP</code>地址与<code>MAC</code>地址的对应关系。缓存条目有生命周期（通常是几分钟），过期后会被删除，以确保信息的时效性。</p>
<hr>
<h2 id="dhcp-dynamic-host-configuration-protocol"><a class="markdownIt-Anchor" href="#dhcp-dynamic-host-configuration-protocol"></a> DHCP (Dynamic Host Configuration Protocol)</h2>
<p>当一台新设备（如笔记本电脑或手机）接入网络时，它需要一个<code>IP</code>地址才能通信。手动为每台设备配置IP地址、子网掩码、默认网关和<code>DNS</code>服务器是非常繁琐且容易出错的。<code>DHCP</code>协议就是为了自动化这个过程而设计的。</p>
<p><strong>定义</strong>：<strong>动态主机配置协议 (<code>DHCP, Dynamic Host Configuration Protocol</code>)</strong> 是一个应用层协议（基于<code>UDP</code>），允许网络中的<code>DHCP</code>服务器自动地为客户端分配IP地址及其他网络配置参数。</p>
<p><strong>工作流程 (<code>DORA</code>)</strong>：这个过程通常被称为**<code>DORA</code>**，代表四个核心步骤。</p>
<ol>
<li><strong><code>Discover</code> (发现)</strong>：客户端（新设备）在网络中<strong>广播</strong>一个 <strong><code>DHCP Discover</code></strong> 报文，试图找到可用的<code>DHCP</code>服务器。报文大意是：“<strong>我需要一个<code>IP</code>地址，网络里有<code>DHCP</code>服务器吗？</strong>”</li>
<li><strong><code>Offer</code> (提供)</strong>：所有收到<code>Discover</code>报文的<code>DHCP</code>服务器都会从自己的地址池中选择一个可用的<code>IP</code>地址，并通过一个 <strong><code>DHCP Offer</code></strong> 报文（单播或广播）提供给客户端。报文大意是：“<strong>你好，我这里有一个<code>IP</code>地址 <code>192.168.1.123</code> 可以给你用，同时还有这些其他的配置信息。</strong>”</li>
<li><strong><code>Request (请求)</code></strong>：客户端可能会收到多个<code>Offer</code>。它会选择其中一个（通常是第一个收到的），然后<strong>广播</strong>一个 <strong><code>DHCP Request</code></strong> 报文，正式请求使用这个<code>IP</code>地址。广播的目的是通知所有<code>DHCP</code>服务器（包括那些也提供了Offer的服务器），它已经做出了选择。报文大意是：“<strong>各位，我决定使用服务器X提供的<code>IP</code>地址 <code>192.168.1.123</code>。</strong>”</li>
<li><strong><code>Acknowledge (确认)</code></strong>：被选中的<code>DHCP</code>服务器会发送一个 <strong><code>DHCP ACK</code></strong> 报文，确认将该<code>IP</code>地址租借给客户端，并规定了租期。此时，客户端就可以使用这个IP地址进行网络通信了。</li>
</ol>
<hr>
<h2 id="路由协议-routing-protocols"><a class="markdownIt-Anchor" href="#路由协议-routing-protocols"></a> 路由协议 (Routing Protocols)</h2>
<p>IP协议本身只负责数据报的转发，但它并不知道如何选择最佳路径。<strong>路由器</strong>通过运行<strong>路由协议</strong>来学习网络的拓扑结构，并创建<strong>路由表</strong>，从而做出智能的路径选择决策。路由协议主要分为两大类：</p>
<h3 id="内部网关协议-igp-interior-gateway-protocol"><a class="markdownIt-Anchor" href="#内部网关协议-igp-interior-gateway-protocol"></a> 内部网关协议 (IGP - Interior Gateway Protocol)</h3>
<p>IGP在一个<strong>自治系统 (<code>AS - Autonomous System</code>)</strong> 内部交换路由信息。一个<code>AS</code>可以是一个公司、一所大学或一个互联网服务提供商（<code>ISP</code>）的网络。</p>
<ul>
<li><strong>RIP (<code>Routing Information Protocol</code>)</strong>
<ul>
<li><strong>类型</strong>：距离矢量协议 (<code>Distance-Vector</code>)。</li>
<li><strong>工作原理</strong>：RIP路由器周期性地与邻居交换整个路由表。它使用“<strong>跳数 (<code>Hop Count</code>)</strong>”作为度量值来衡量路径的好坏，即经过的路由器数量越少，路径越优。</li>
<li><strong>特点</strong>：实现简单，但有明显缺点，如最大跳数限制（15跳）、收敛速度慢、容易产生路由环路等。现在已基本被<code>OSPF</code>取代。</li>
</ul>
</li>
<li><strong>OSPF (<code>Open Shortest Path First</code>)</strong>
<ul>
<li><strong>类型</strong>：链路状态协议 (<code>Link-State</code>)。</li>
<li><strong>工作原理</strong>：<code>OSPF</code>路由器不交换路由表，而是交换<strong>链路状态通告 (<code>LSA</code>)</strong>。每个路由器都收集网络中所有的<code>LSA</code>，从而在本地构建一个完整的网络拓扑图。然后，它使用**<code>Dijkstra</code>算法**计算出到达每个目的地的最短路径。</li>
<li><strong>特点</strong>：收敛速度快，无路由环路，支持可变长子网掩码（<code>VLSM</code>），支持区域划分以实现更好的扩展性。是当今企业网络中最主流的<code>IGP</code>协议。</li>
</ul>
</li>
</ul>
<h3 id="外部网关协议-egp-exterior-gateway-protocol"><a class="markdownIt-Anchor" href="#外部网关协议-egp-exterior-gateway-protocol"></a> 外部网关协议 (EGP - Exterior Gateway Protocol)</h3>
<p><code>EGP</code>用于在不同的自治系统（<code>AS</code>）之间交换路由信息，是构成整个互联网的骨架。</p>
<ul>
<li><strong>BGP (<code>Border Gateway Protocol</code>)</strong>
<ul>
<li><strong>定义</strong>：边界网关协议是目前唯一在使用的<code>EGP</code>。它不仅仅是寻找最短路径，更重要的是，它是一个“<strong>路径矢量协议</strong>”，能够根据管理员设定的策略（如费用、安全、政治因素等）来选择最佳路由。</li>
<li><strong>特点</strong>：极其稳定和可扩展，是互联网的核心路由协议，负责连接全球成千上万个自治系统。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ipv6"><a class="markdownIt-Anchor" href="#ipv6"></a> IPv6</h2>
<p>随着物联网的兴起和互联网的蓬勃发展，<code>IPv4</code>的地址空间（约43亿个）已完全耗尽。<code>IPv6</code>作为其继任者，提供了海量的地址空间和诸多改进。</p>
<p><strong>主要优势</strong>：</p>
<ol>
<li><strong>巨大的地址空间</strong>：<code>IPv6</code>使用128位地址，理论上可提供<code> 2^128</code> 个地址，这个数字足以满足未来数百年内任何可以想象到的需求。</li>
<li><strong>简化的首部格式</strong>：<code>IPv6</code>的首部是固定的40字节，移除了<code>IPv4</code>中不常用或冗余的字段（如<code>IHL</code>、标识、标志、片偏移、首部检验和），使得路由器处理数据包的效率更高。</li>
<li><strong>不再由路由器分片</strong>：<code>IPv6</code>要求发送方主机在发送前完成“路径<code>MTU</code>发现”（<code>PMTUD</code>），确保数据包大小不超过路径中的最小<code>MTU</code>。路由器不再进行分片，大大减轻了路由器的负担。</li>
<li><strong>增强的安全性</strong>：<code>IPsec</code>（IP安全协议）被设计为<code>IPv6</code>的强制组成部分（尽管后来变为可选），为网络层提供了端到端的加密和认证，安全性远超<code>IPv4</code>。</li>
<li><strong>支持无状态地址自动配置 (<code>SLAAC</code>)</strong>：<code>IPv6</code>主机可以根据路由器通告的前缀和自身的<code>MAC</code>地址等信息，自动生成全局唯一的<code>IP</code>地址，无需<code>DHCP</code>服务器介入即可上网。</li>
<li><strong>改进的邻居发现协议 (<code>NDP</code>)</strong>：<code>IPv6</code>使用<strong>邻居发现协议 (<code>NDP</code>)</strong>，它基于<code>ICMPv6</code>，取代了<code>IPv4</code>中的<code>ARP</code>和<code>ICMP</code>路由器发现等功能，实现了地址解析、路由器发现、重复地址检测（<code>DAD</code>）等，更加高效和强大。</li>
</ol>
<hr>
<h2 id="igmp-internet-group-management-protocol"><a class="markdownIt-Anchor" href="#igmp-internet-group-management-protocol"></a> IGMP (Internet Group Management Protocol)</h2>
<p>当数据需要发送给一组特定的、感兴趣的主机而不是单个主机（单播）或所有主机（广播）时，就需要<strong>组播 (<code>Multicast</code>)</strong>。<code>IGMP</code>协议就是用于管理这种组播组成员关系的。</p>
<p><strong>定义</strong>：IGMP (<code>Internet Group Management Protocol</code>)，因特网组管理协议。它允许主机通知其本地路由器，表示自己希望加入或离开某个特定的组播组。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li><strong>加入组</strong>：当一个主机上的某个应用希望接收特定组播组（例如一个视频流）的数据时，主机会向其本地路由器发送一个<code>IGMP</code><strong>成员关系报告</strong>报文。</li>
<li><strong>维护关系</strong>：路由器会周期性地发送<code>IGMP</code><strong>查询</strong>报文，询问本地网络上是否还有成员对某个组播组感兴趣。仍在组内的成员会回复报告报文。</li>
<li><strong>离开组</strong>：当主机不再希望接收数据时，它会发送一个<code>IGMP</code><strong>离开组</strong>报文。</li>
</ul>
<p><code>IGMP</code>只负责在主机和本地路由器之间进行通信。路由器之间则需要运行专门的组播路由协议（如<code>PIM</code>）来构建组播数据的分发路径。</p>
<hr>
<h2 id="nat-network-address-translation"><a class="markdownIt-Anchor" href="#nat-network-address-translation"></a> NAT (Network Address Translation)</h2>
<p><code>NAT</code>是为了延缓<code>IPv4</code>地址耗尽而设计出的一种关键技术。它允许一个机构内部的众多计算机使用<strong>私有<code>IP</code>地址</strong>上网，但在与外部互联网通信时，共享一个或少数几个<strong>公有<code>IP</code>地址</strong>。</p>
<p><strong>定义</strong>：<strong>网络地址转换 (<code>NAT</code>)</strong> 工作在路由器或防火墙上，负责在私有网络和公有网络之间转换<code>IP</code>数据报的源/目的地址和端口号。</p>
<p><strong>私有<code>IP</code>地址段</strong> (不会在公网路由):</p>
<ul>
<li><code>10.0.0.0</code> 到 <code>10.255.255.255</code> (A类)</li>
<li><code>172.16.0.0</code> 到 <code>172.31.255.255</code> (B类)</li>
<li><code>192.168.0.0</code> 到 <code>192.168.255.255</code> (C类)</li>
</ul>
<p><strong>工作原理与类型</strong>：</p>
<ol>
<li><strong>静态NAT (<code>Static NAT</code>)</strong>：
<ul>
<li>将一个私有<code>IP</code>地址<strong>一对一</strong>地映射到一个公有IP地址。</li>
<li>主要用于内部服务器（如Web服务器）需要被外部网络稳定访问的场景。</li>
</ul>
</li>
<li><strong>动态NAT (<code>Dynamic NAT</code>)</strong>：
<ul>
<li>维护一个公有<code>IP</code>地址池。当内部主机需要访问互联网时，从地址池中<strong>临时分配</strong>一个未使用的公有<code>IP</code>地址给它。</li>
<li>当通信结束时，该公有<code>IP</code>地址被回收，可供其他主机使用。</li>
</ul>
</li>
<li><strong>PAT (<code>Port Address Translation</code>) / NAPT</strong>：
<ul>
<li>这是目前<strong>最常用</strong>的<code>NAT</code>形式，也称为<code>NAPT</code>（网络地址端口转换）。它将多个私有<code>IP</code>地址映射到<strong>同一个公有IP地址</strong>的不同<strong>端口</strong>上。</li>
<li><strong>流程</strong>：当内部主机 <code>192.168.1.100 </code>使用端口 <code>50000 </code>访问外部服务器时，<code>NAT</code>路由器会将源地址和端口转换为 (公有IP, 新端口号)，例如 (<code>202.100.1.1</code>, <code>60001</code>)，并记录这个映射关系。当外部服务器响应数据到 (<code>202.100.1.1</code>, <code>60001</code>) 时，路由器根据记录将数据包的目的地址和端口改回 (<code>192.168.1.100</code>, <code>50000</code>)，并发送给内部主机。</li>
<li><strong>优点</strong>：极大地节约了公有<code>IP</code>地址，仅用一个公有<code>IP</code>就能让成百上千台设备同时上网。</li>
<li><strong>缺点</strong>：破坏了端到端的连接模型，可能导致某些<code>P2P</code>应用或<code>VoIP</code>协议出现问题。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="ipsec-internet-protocol-security"><a class="markdownIt-Anchor" href="#ipsec-internet-protocol-security"></a> IPsec (Internet Protocol Security)</h2>
<p><strong><code>IPsec</code></strong> 是一套协议簇，用于在网络层为<code>IP</code>通信提供高质量、可互操作的、基于密码学的安全保障。它能提供数据来源认证、数据完整性、数据机密性（加密）和防重放攻击等服务，是构建**<code>VPN</code> (虚拟专用网络)** 的核心技术。</p>
<p><strong>两种工作模式</strong>：</p>
<ol>
<li><strong>传输模式 (<code>Transport Mode</code>)</strong>：
<ul>
<li><strong>工作方式</strong>：只对IP数据报的<strong>数据部分（<code>Payload</code>）</strong> 进行加密或认证。原始的IP头部保持不变，只插入了<code>IPsec</code>头部。</li>
<li><strong>用途</strong>：主要用于两台主机之间的<strong>端到端</strong>安全通信。</li>
</ul>
</li>
<li><strong>隧道模式 (<code>Tunnel Mode</code>)</strong>：
<ul>
<li><strong>工作方式</strong>：将<strong>整个原始<code>IP</code>数据报（包括头部和数据）</strong> 都进行加密和认证，然后将其封装在一个新的IP数据报中。</li>
<li><strong>用途</strong>：主要用于两个网络（如公司总部和分部）之间的<strong>网关到网关</strong>安全通信，由网络边缘的<code>VPN</code>网关来处理。这是构建<code>VPN</code>最常见的方式。</li>
</ul>
</li>
</ol>
<p><strong>核心协议</strong>：</p>
<ul>
<li><strong>AH (<code>Authentication Header</code>)</strong>：只提供<strong>数据完整性</strong>和<strong>身份验证</strong>，但不提供加密。它确保数据在传输中未被篡改，但传输内容是明文的。</li>
<li><strong>ESP (<code>Encapsulating Security Payload</code>)</strong>：提供<strong>数据完整性</strong>、<strong>身份验证</strong>和<strong>数据机密性（加密）</strong>。这是目前应用最广泛的IPsec协议。</li>
</ul>
<hr>
<h2 id="vrrp-virtual-router-redundancy-protocol"><a class="markdownIt-Anchor" href="#vrrp-virtual-router-redundancy-protocol"></a> VRRP (Virtual Router Redundancy Protocol)</h2>
<p>在局域网中，如果作为默认网关的路由器发生故障，整个网络的主机将无法访问外部网络，这形成了一个<strong>单点故障</strong>。<code>VRRP</code>就是为了解决这个问题而设计的网关冗余协议。</p>
<p><strong>定义</strong>：<strong>虚拟路由器冗余协议 (<code>VRRP</code>)</strong> 是一种容错协议，可以将多台物理路由器组织成一个“<strong>虚拟路由器</strong>”，从而对外提供一个高可用的默认网关。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>虚拟路由器</strong>：在一个<code>VRRP</code>组中，多台物理路由器共享一个<strong>虚拟<code>IP</code>地址</strong>和<strong>虚拟<code>MAC</code>地址</strong>。网络中的所有客户端都将这个虚拟<code>IP</code>地址配置为它们的默认网关。</li>
<li><strong><code>Master</code>和<code>Backup</code></strong>：在任何时刻，<code>VRRP</code>组中只有一台路由器处于 <strong><code>Master </code>(主)</strong> 状态，它实际拥有虚拟IP地址并负责转发数据包。组内其他路由器则处于 <strong><code>Backup</code> (备)</strong> 状态。</li>
<li><strong>心跳检测</strong>：<code>Master</code>路由器会周期性地发送<code>VRRP</code>通告报文（心跳），向<code>Backup</code>路由器宣告自己处于活动状态。</li>
<li><strong>故障切换</strong>：如果<code>Backup</code>路由器在一定时间内没有收到<code>Master</code>的心跳报文，它会认为<code>Master</code>已经出现故障。此时，优先级最高的<code>Backup</code>路由器会自动切换为新的<code>Master</code>，接管虚拟<code>IP</code>地址和<code>MAC</code>地址，并开始转发数据。</li>
<li><strong>无缝切换</strong>：这个切换过程对客户端是完全透明的，客户端无需进行任何更改，从而保证了网络连接的连续性。</li>
</ol>
<hr>
<h2 id="mpls-multiprotocol-label-switching"><a class="markdownIt-Anchor" href="#mpls-multiprotocol-label-switching"></a> MPLS (Multiprotocol Label Switching)</h2>
<p><code>MPLS</code>是一种高性能的电信级网络技术，它在传统的IP路由（第三层）和数据链路层交换（第二层）之间工作，常被称为“<strong>2.5层</strong>”技术。</p>
<p><strong>定义</strong>：<strong>多协议标签交换 (<code>MPLS</code>)</strong> 通过给数据包预先分配简短、固定长度的“<strong>标签（<code>Label</code>）</strong>”，并根据标签进行转发，而不是像传统路由那样在每一跳都查找复杂的IP路由表。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>标签分发</strong>：<code>MPLS</code>网络中的路由器（称为<code>LSR</code> - 标签交换路由器）会通过<code>LDP</code>（标签分发协议）等协议，预先为网络中的IP前缀（路由）建立标签映射关系，形成<strong>标签转发信息库 (<code>LFIB</code>)</strong>。</li>
<li><strong>入口打标 (<code>Push</code>)</strong>：当一个IP数据包进入<code>MPLS</code>网络时，入口路由器（<code>Ingress LER</code>）会进行一次常规的<code>IP</code>路由查找，然后给这个数据包压入一个或多个<code>MPLS</code>标签，形成一个带标签的数据包。</li>
<li><strong>标签交换 (<code>Swap</code>)</strong>：在<code>MPLS</code>网络内部，核心的<code>LSR</code>路由器不再查看<code>IP</code>头部。它们只需读取最外层的标签，在<code>LFIB</code>中进行极速查找，然后“交换”（替换）标签，并将数据包转发到下一个<code>LSR</code>。</li>
<li><strong>出口弹标 (<code>Pop</code>)</strong>：当数据包到达<code>MPLS</code>网络的出口路由器（<code>Egress LER</code>）时，标签被移除（弹出），恢复成原始的<code>IP</code>数据包，然后继续进行标准的<code>IP</code>转发。</li>
</ol>
<p><strong>主要优势</strong>：</p>
<ul>
<li><strong>高速转发</strong>：基于标签的精确匹配交换比基于<code>IP</code>地址的最长前缀匹配查找要快得多。</li>
<li><strong>流量工程 (<code>Traffic Engineering</code>)</strong>：<code>MPLS</code>可以预先设定数据流的路径（建立<code>LSP</code> - 标签交换路径），而不必完全遵循<code>IGP</code>计算出的最短路径。这使得网络管理员可以精细地控制流量，以优化带宽利用率或绕过拥塞点。</li>
<li><strong>VPN支持</strong>：<code>MPLS</code>是构建大规模、高性能<code>VPN</code>（特别是<code>MPLS</code> <code>L3VPN</code>）的基础技术，被全球各大<code>ISP</code>广泛采用。</li>
</ul>
<p>仍在咕咕咕中</p>
]]></content>
      <categories>
        <category>Computer Networks</category>
      </categories>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Fast-Learning-FastAPI</title>
    <url>/Fast-Learning-FastAPI/</url>
    <content><![CDATA[<h1 id="fastapi"><a class="markdownIt-Anchor" href="#fastapi"></a> FastAPI</h1>
<p><code>pip install fastapi uvicorn</code></p>
<h2 id="part-1-简单创建"><a class="markdownIt-Anchor" href="#part-1-简单创建"></a> part 1 <strong>简单创建</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#hello_world.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#*或者在终端中使用uvicorn main:app --reload</span></span><br></pre></td></tr></table></figure>
<p>我们添加<code>@app.get</code>部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>
<p>此时访问<a href="http://127.0.0.1:8000/items/5">http://127.0.0.1:8000/items/5</a>    ，会发现返回了<code>&#123;&quot;item_id&quot;:5&#125;</code>,</p>
<p>如果访问的是<a href="http://127.0.0.1:8000/items/sast">127.0.0.1:8000/items/sast </a>   ，会发现返回的是<code>&#123;&quot;detail&quot;:[&#123;&quot;type&quot;:&quot;int_parsing&quot;,&quot;loc&quot;:[&quot;path&quot;,&quot;item_id&quot;],&quot;msg&quot;:&quot;Input should be a valid integer, unable to parse string as an integer&quot;,&quot;input&quot;:&quot;sast&quot;&#125;]&#125;</code></p>
<p>我们在<code>item_id</code>处使用注解要求其为<code>int</code>类型，能看到它会自动检验。</p>
<p>再向代码中添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_fake_item</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br></pre></td></tr></table></figure>
<p>此时访问<a href="http://127.0.0.1:8000/items/?skip=0&amp;limit=2">http://127.0.0.1:8000/items/?skip=0&amp;limit=2</a>    ，会发现返回是<code>[&#123;&quot;item_name&quot;:&quot;Foo&quot;&#125;,&#123;&quot;item_name&quot;:&quot;Bar&quot;&#125;]</code></p>
<h2 id="part-2-响应模型"><a class="markdownIt-Anchor" href="#part-2-响应模型"></a> part 2 <strong>响应模型</strong></h2>
<p><strong>请求体和 Pydantic 模型</strong></p>
<p>为了定义请求体的结构，FastAPI 使用了 Pydantic 库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: Item</span>):</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>然后也可以顺手用<code>requests</code>库来验证一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1:8000/items/&quot;</span></span><br><span class="line"></span><br><span class="line">my_item = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;111test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;null&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: <span class="number">1145.14</span>,</span><br><span class="line">  <span class="string">&quot;tax&quot;</span>: <span class="number">666.25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, json=my_item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;状态码 (Status Code):&quot;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;响应内容 (Response JSON):&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br></pre></td></tr></table></figure>
<p><code>状态码 (Status Code): 200 响应内容 (Response JSON): &#123;'name': '111test', 'description': 'null', 'price': 1145.14, 'tax': 666.25&#125;</code></p>
<p>我们可以修改响应结果，为了让部分数据不可见之类的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemIn</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItemOut</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=ItemOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: ItemIn</span>):</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>这样用相同的测试会发现是<code>&#123;'name': '111test', 'price': 1145.14&#125;</code></p>
<h2 id="part-3-依赖注入"><a class="markdownIt-Anchor" href="#part-3-依赖注入"></a> part 3 <strong>依赖注入</strong></h2>
<p><code>Depends</code> 会告诉 <code>FastAPI</code>，``read_items<code>函数依赖于</code>common_parameters` 函数的返回值。它的核心优势在于 <strong>代码复用</strong> 和 <strong>逻辑分离</strong>。</p>
<h3 id="31-共享通用参数"><a class="markdownIt-Anchor" href="#31-共享通用参数"></a> 3.1 共享通用参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个“依赖项”函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">common_parameters</span>(<span class="params">q: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q, <span class="string">&quot;skip&quot;</span>: skip, <span class="string">&quot;limit&quot;</span>: limit&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.9+ 推荐使用 Annotated 来组织 Depends</span></span><br><span class="line"><span class="comment"># CommonsDep 的意思就是：我需要一个 dict，这个 dict 是通过调用 common_parameters 函数得到的</span></span><br><span class="line">CommonsDep = Annotated[<span class="built_in">dict</span>, Depends(common_parameters)]</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line">fake_users_db = [&#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Alice&quot;</span>&#125;, &#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Bob&quot;</span>&#125;, &#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">commons: CommonsDep</span>):</span><br><span class="line">    <span class="comment"># commons 参数现在就是一个字典，比如 &#123;&quot;q&quot;: None, &quot;skip&quot;: 0, &quot;limit&quot;: 100&#125;</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons[<span class="string">&quot;q&quot;</span>]:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;query&quot;</span>: commons[<span class="string">&quot;q&quot;</span>]&#125;)</span><br><span class="line">    </span><br><span class="line">    items = fake_items_db[commons[<span class="string">&quot;skip&quot;</span>] : commons[<span class="string">&quot;skip&quot;</span>] + commons[<span class="string">&quot;limit&quot;</span>]]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;items&quot;</span>: items&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_users</span>(<span class="params">commons: CommonsDep</span>):</span><br><span class="line">    <span class="comment"># read_users 函数也轻松地复用了分页和查询逻辑</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons[<span class="string">&quot;q&quot;</span>]:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;query&quot;</span>: commons[<span class="string">&quot;q&quot;</span>]&#125;)</span><br><span class="line">    </span><br><span class="line">    users = fake_users_db[commons[<span class="string">&quot;skip&quot;</span>] : commons[<span class="string">&quot;skip&quot;</span>] + commons[<span class="string">&quot;limit&quot;</span>]]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;users&quot;</span>: users&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>现在，<code>/items/ </code>和 <code>/users/</code> 两个端点都拥有了同样的分页和查询能力，而我们只写了一次核心逻辑。这就是依赖注入最直观的好处。</p>
<h3 id="32-依赖项作为守卫"><a class="markdownIt-Anchor" href="#32-依赖项作为守卫"></a> 3.2 依赖项作为“守卫”</h3>
<p>依赖注入一个更强大的用途是处理认证和授权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Header, HTTPException</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">verify_token</span>(<span class="params">x_token: Annotated[<span class="built_in">str</span>, Header(<span class="params"></span>)]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个依赖项会检查请求头中是否包含 &#x27;X-Token&#x27;，并且值是否为 &#x27;fake-super-secret-token&#x27;</span></span><br><span class="line"><span class="string">    Header() 告诉 FastAPI 这个参数要从请求头里获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/protected-route/&quot;</span>, dependencies=[Depends(<span class="params">verify_token</span>)]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_protected_route</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个端点被依赖项保护起来了。</span></span><br><span class="line"><span class="string">    只有当请求头包含 X-Token: fake-super-secret-token 时，才能访问成功。</span></span><br><span class="line"><span class="string">    否则，客户端会直接收到 400 错误。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome, you have the correct token!&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part-4-组织大型应用"><a class="markdownIt-Anchor" href="#part-4-组织大型应用"></a> part 4 组织大型应用</h2>
<p>当API越来越多，把所有东西都写在同一个 <code>main.py</code> 文件里会变得难以维护。<code>APIRouter</code> 允许你将API按功能模块拆分到不同的文件中。</p>
<p>文件树如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/my_app</span><br><span class="line">|-- /routers</span><br><span class="line">|   |-- items.py</span><br><span class="line">|   |-- users.py</span><br><span class="line">|-- main.py</span><br></pre></td></tr></table></figure>
<p>然后内容如下</p>
<p><code>routers/items.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># routers/items.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, HTTPException</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个 APIRouter 实例</span></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/items&quot;</span>,            <span class="comment"># 为这个路由下的所有路径添加URL前缀</span></span><br><span class="line">    tags=[<span class="string">&quot;Items&quot;</span>],             <span class="comment"># 在API文档中为它们分组</span></span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Item not found&quot;</span>&#125;&#125;, <span class="comment"># 统一的错误响应</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=<span class="type">List</span>[Item]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据ID获取单个物品。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 在真实应用中，这里会是数据库查询</span></span><br><span class="line">    <span class="keyword">if</span> item_id &gt;= <span class="built_in">len</span>(fake_items_db) <span class="keyword">or</span> item_id &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[item_id]</span><br></pre></td></tr></table></figure>
<p><code>routers/users.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># routers/users.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, HTTPException</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserBase</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr  <span class="comment"># Pydantic内置的Email验证类型</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserCreate</span>(<span class="title class_ inherited__">UserBase</span>):</span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserPublic</span>(<span class="title class_ inherited__">UserBase</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/users&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;Users&quot;</span>],</span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;User not found&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fake_users_db = &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john.doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;john.doe@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;fake_hashed_password_123&quot;</span>, <span class="comment"># 模拟存储的是哈希后的密码</span></span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;jane.smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;jane.smith@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;Jane Smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;another_fake_password_456&quot;</span>,</span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=<span class="type">List</span>[UserPublic]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_users</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取一个用户列表，同样支持分页。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    users_list = <span class="built_in">list</span>(fake_users_db.values())</span><br><span class="line">    <span class="keyword">return</span> users_list[skip : skip + limit]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=UserPublic, status_code=<span class="number">201</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">user: UserCreate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个新用户。</span></span><br><span class="line"><span class="string">    在真实世界中，你会在这里哈希密码，然后存入数据库。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    new_user_id = <span class="built_in">max</span>(fake_users_db.keys()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    db_user = &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: new_user_id,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: user.username,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: user.email,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: user.full_name,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">f&quot;hashed_<span class="subst">&#123;user.password&#125;</span>&quot;</span>, <span class="comment"># 假装哈希了密码</span></span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>, </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fake_users_db[new_user_id] = db_user</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;user_id&#125;&quot;</span>, response_model=UserPublic</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_user</span>(<span class="params">user_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据ID获取单个用户信息。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">not</span> <span class="keyword">in</span> fake_users_db:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;User not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fake_users_db[user_id]</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> routers <span class="keyword">import</span> items, users  <span class="comment"># &lt;-- 在这里导入 users</span></span><br><span class="line"></span><br><span class="line">app = FastAPI(title=<span class="string">&quot;我的模块化大型应用&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.include_router(items.router)</span><br><span class="line">app.include_router(users.router)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the main application&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>思考</strong>：目前items和users的数据是完全隔离的，并且每次服务器重启都会丢失。在真实应用中，这些数据应该存放在一个共享的、持久化的数据库中。接下来，我们将学习如何将FastAPI与真实数据库连接起来。</p>
</blockquote>
<h2 id="part-5-异步数据库操作"><a class="markdownIt-Anchor" href="#part-5-异步数据库操作"></a> part 5 异步数据库操作</h2>
<p>到目前为止，我们都使用<code>Python</code>列表或字典作为假数据库。现在，我们将学习如何将<code>FastAPI</code>与一个真正的SQL数据库（以<code>PostgreSQL</code>为例）进行异步交互。</p>
<ul>
<li>[ ] To be continued</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>FastAPI</tag>
        <tag>Backend</tag>
      </tags>
  </entry>
</search>
