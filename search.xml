<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA-and-pytorch</title>
    <url>/CUDA-and-pytorch/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-%E5%9C%A8win%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85pytorch">1. 在win系统上安装pytorch</a>
<ul>
<li><a href="#11-step-1-%E5%AE%89%E8%A3%85conda">1.1. Step 1 安装Conda</a></li>
<li><a href="#12-step-2-cuda">1.2. Step 2 CUDA</a></li>
<li><a href="#13-step-3-%E5%AE%89%E8%A3%85pytorch">1.3. Step 3 安装Pytorch</a></li>
</ul>
</li>
</ul>
</details>
<h1 id="1-在win系统上安装pytorch"><a class="markdownIt-Anchor" href="#1-在win系统上安装pytorch"></a> 1. 在win系统上安装pytorch</h1>
<h2 id="11-step-1-安装conda"><a class="markdownIt-Anchor" href="#11-step-1-安装conda"></a> 1.1. Step 1 安装Conda</h2>
<p><a href="https://www.anaconda.com/download/success">Download Now | Anaconda</a></p>
<p><code>Anaconda</code>和<code>Miniconda</code>都可以，前者东西全一些，后者更为轻便。</p>
<p>展示的是<code>Anaconda</code></p>
<p><s>此处下载推荐使用魔法</s></p>
<blockquote>
<p>如果网络不支持那就使用<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
</blockquote>
<p><code>Anaconda3-2024.10-1-Windows-x86_64.exe</code>下载好之后打开</p>
<p>如果不想配置环境变量就选<code>All Users</code>吧。</p>
<p><img src="/CUDA-and-pytorch/image-20250218235016076-1740145143701-1.png" alt></p>
<p>然后推荐找个不是C盘的地方下</p>
<p><img src="/CUDA-and-pytorch/image-20250218235145695-1740145143701-2.png" alt></p>
<p><img src="/CUDA-and-pytorch/image-20250218235447531-1740145143701-4.png" alt></p>
<p>安装时间也许会比较长，别急。</p>
<p>装好之后可以测试一下<code>conda --version</code>,有这样的反应就好，版本不一定一样。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">conda <span class="literal">--version</span></span><br><span class="line">conda <span class="number">25.1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为我后面要玩<code>d2l</code>，所以就用<code>conda</code>创建了一个环境</p>
<p><code>conda create -n d2l python=3.10</code></p>
<p>这边<code>conda</code>是指令头，<code>-n</code> 是指定新环境的名称，<code>d2l</code> 是你想要为新环境指定的名称,<code>python=3.10</code>这部分指定了<code>python</code>的版本，不过其实不一定要<code>3.10</code>，<code>pytorch</code>官网上提示的是<code>Latest PyTorch requires Python 3.9 or later.</code>，加上学长爱用<code>3.10</code>，那就定了。<s>ps:3.10和3.9到底谁大呢</s></p>
<p>创建完成会提示的，后面需要激活一下</p>
<p><code>conda activate d2l</code></p>
<p>顺利的话就能看到<code>(d2l)</code>在输入的前面。</p>
<p>用的差不多之后要回到原来的环境的话就</p>
<p><code>conda deactivate</code></p>
<p>这样就回去了，不过你直接关掉重开也不是不行（</p>
<h2 id="12-step-2-cuda"><a class="markdownIt-Anchor" href="#12-step-2-cuda"></a> 1.2. Step 2 CUDA</h2>
<p>笔记本电脑的GPU是<code>Nvidia 4060 laptop</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;nvidia-smi</span><br><span class="line">Wed Feb <span class="number">19</span> <span class="number">00</span>:<span class="number">07</span>:<span class="number">11</span> <span class="number">2025</span></span><br><span class="line">+-----------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI <span class="number">571</span>.<span class="number">96</span>                 Driver Version: <span class="number">571</span>.<span class="number">96</span>         CUDA Version: <span class="number">12</span>.<span class="number">8</span>     |</span><br><span class="line">|-----------------------------------------+------------------------+----------------------+</span><br><span class="line">| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                        |               MIG M. |</span><br><span class="line">|=========================================+========================+======================|</span><br><span class="line">|   <span class="number">0</span>  NVIDIA GeForce RTX <span class="number">4060</span> ...  WDDM  |   <span class="number">00000000</span>:<span class="number">01</span>:<span class="number">00</span>.<span class="number">0</span>  On |                  N/A |</span><br><span class="line">| N/A   <span class="number">39</span>C    P8              <span class="number">3</span>W /  <span class="number">115</span>W |    <span class="number">1533</span>MiB /   <span class="number">8188</span>MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">|                                         |                        |                  N/A |</span><br><span class="line">+-----------------------------------------+------------------------+----------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这边可以看到CUDA的版本</p>
<p>到<a href="https://developer.nvidia.com/cuda-downloads%E9%87%8C%E9%9D%A2%E5%8E%BB">https://developer.nvidia.com/cuda-downloads里面去</a></p>
<p><img src="/CUDA-and-pytorch/image-20250219000853416-1740145143701-3.png" alt></p>
<p>然后根据版本选一下，本地跑别乱选<code>network</code></p>
<p>然后点<code>Download</code>就行了</p>
<p><img src="/CUDA-and-pytorch/image-20250219001030527-1740145143701-5.png" alt></p>
<p>下载好的ok就行了，这步只是解压不是安装。</p>
<p>网上看教程说</p>
<p><img src="/CUDA-and-pytorch/image-20250219001140813-1740145143701-6.png" alt></p>
<p>我确实没勾这个，但是我下面的几个选项还是都装了。</p>
<p>安装好之后理论上环境变量是在的，可以先验证一下</p>
<p>在C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.8  (你安装的位置，默认是这样)打开终端</p>
<p>按顺序输入</p>
<p><code>cd .\extras\demo_suite</code></p>
<p><code>.\bandwidthTest.exe</code></p>
<p><code>.\deviceQuery.exe</code></p>
<p>回车测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd .\extras\demo_suite</span></span><br><span class="line"><span class="comment"># .\bandwidthTest.exe</span></span><br><span class="line">[<span class="type">CUDA</span> <span class="type">Bandwidth</span> <span class="type">Test</span>] - Starting...</span><br><span class="line">Running on...</span><br><span class="line"></span><br><span class="line"> Device <span class="number">0</span>: NVIDIA GeForce RTX <span class="number">4060</span> Laptop GPU</span><br><span class="line"> Quick Mode</span><br><span class="line"></span><br><span class="line"> Host to Device Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">12883.8</span></span><br><span class="line"></span><br><span class="line"> Device to Host Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">12835.4</span></span><br><span class="line"></span><br><span class="line"> Device to Device Bandwidth, <span class="number">1</span> Device(s)</span><br><span class="line"> PINNED Memory Transfers</span><br><span class="line">   Transfer Size (Bytes)        Bandwidth(MB/s)</span><br><span class="line">   <span class="number">33554432</span>                     <span class="number">196311.5</span></span><br><span class="line"></span><br><span class="line">Result = PASS</span><br><span class="line"></span><br><span class="line">NOTE: The CUDA Samples are not meant <span class="keyword">for</span> performance measurements. Results may vary when GPU Boost is enabled.</span><br><span class="line"><span class="comment"># .\deviceQuery.exe</span></span><br><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.<span class="number">8</span>\extras\demo_suite\deviceQuery.exe Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API)</span><br><span class="line"></span><br><span class="line">Detected <span class="number">1</span> CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device <span class="number">0</span>: <span class="string">&quot;NVIDIA GeForce RTX 4060 Laptop GPU&quot;</span></span><br><span class="line">  CUDA Driver Version / Runtime Version          <span class="number">12.8</span> / <span class="number">12.8</span></span><br><span class="line">  CUDA Capability Major/Minor version number:    <span class="number">8.9</span></span><br><span class="line">  Total amount of global memory:                 <span class="number">8188</span> MBytes (<span class="number">8585216000</span> bytes)</span><br><span class="line">MapSMtoCores <span class="keyword">for</span> SM <span class="number">8.9</span> is undefined.  Default to use <span class="number">128</span> Cores/SM</span><br><span class="line">MapSMtoCores <span class="keyword">for</span> SM <span class="number">8.9</span> is undefined.  Default to use <span class="number">128</span> Cores/SM</span><br><span class="line">  (<span class="number">24</span>) Multiprocessors, (<span class="number">128</span>) CUDA Cores/<span class="built_in">MP</span>:     <span class="number">3072</span> CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            <span class="number">2370</span> MHz (<span class="number">2.37</span> GHz)</span><br><span class="line">  Memory Clock rate:                             <span class="number">8001</span> Mhz</span><br><span class="line">  Memory Bus Width:                              <span class="number">128</span><span class="literal">-bit</span></span><br><span class="line">  L2 Cache Size:                                 <span class="number">33554432</span> bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         <span class="number">1</span>D=(<span class="number">131072</span>), <span class="number">2</span>D=(<span class="number">131072</span>, <span class="number">65536</span>), <span class="number">3</span>D=(<span class="number">16384</span>, <span class="number">16384</span>, <span class="number">16384</span>)</span><br><span class="line">  Maximum Layered <span class="number">1</span>D Texture Size, (num) layers  <span class="number">1</span>D=(<span class="number">32768</span>), <span class="number">2048</span> layers</span><br><span class="line">  Maximum Layered <span class="number">2</span>D Texture Size, (num) layers  <span class="number">2</span>D=(<span class="number">32768</span>, <span class="number">32768</span>), <span class="number">2048</span> layers</span><br><span class="line">  Total amount of constant memory:               zu bytes</span><br><span class="line">  Total amount of shared memory per block:       zu bytes</span><br><span class="line">  Total number of registers available per block: <span class="number">65536</span></span><br><span class="line">  Warp size:                                     <span class="number">32</span></span><br><span class="line">  Maximum number of threads per multiprocessor:  <span class="number">1536</span></span><br><span class="line">  Maximum number of threads per block:           <span class="number">1024</span></span><br><span class="line">  Max dimension size of a thread block (x,y,z): (<span class="number">1024</span>, <span class="number">1024</span>, <span class="number">64</span>)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (<span class="number">2147483647</span>, <span class="number">65535</span>, <span class="number">65535</span>)</span><br><span class="line">  Maximum memory pitch:                          zu bytes</span><br><span class="line">  Texture alignment:                             zu bytes</span><br><span class="line">  Concurrent <span class="built_in">copy</span> and kernel execution:          Yes with <span class="number">1</span> <span class="built_in">copy</span> engine(s)</span><br><span class="line">  Run time limit on kernels:                     Yes</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page<span class="literal">-locked</span> memory mapping:       Yes</span><br><span class="line">  Alignment requirement <span class="keyword">for</span> Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Disabled</span><br><span class="line">  CUDA Device Driver Mode (TCC or WDDM):         WDDM (Windows Display Driver Model)</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device supports Compute Preemption:            Yes</span><br><span class="line">  Supports Cooperative Kernel Launch:            Yes</span><br><span class="line">  Supports MultiDevice Co<span class="literal">-op</span> Kernel Launch:      No</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   <span class="number">0</span> / <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = <span class="number">12.8</span>, CUDA Runtime Version = <span class="number">12.8</span>, NumDevs = <span class="number">1</span>, Device0 = NVIDIA GeForce RTX <span class="number">4060</span> Laptop GPU</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure>
<p>如果有这样的就说明成功了</p>
<p>试一下<code>nvcc -V</code></p>
<p><img src="/CUDA-and-pytorch/876ee5e3b3266e2d56bdd5b30a2809cf-1739898997106-5-1740145143702-7.png" alt></p>
<h2 id="13-step-3-安装pytorch"><a class="markdownIt-Anchor" href="#13-step-3-安装pytorch"></a> 1.3. Step 3 安装Pytorch</h2>
<p>这个安装靠的是<code>conda</code>虚拟环境下的<code>pip3</code>安装的完整<code>pytorch</code>,并没有使用<code>docker</code>镜像来部署,不过如果到了需要租显卡的时候，就需要再去学习使用<code>docker</code>来部署了。</p>
<p>先<code>conda activate d2l</code> 激活一下自己的环境  <em>别笨到自己环境名字都没改，当然你也叫d2l那我没意见</em></p>
<p><a href="https://pytorch.org/">PyTorch</a>打开这个网站，</p>
<p><img src="/CUDA-and-pytorch/image-20250219004200322-1740145143702-9.png" alt></p>
<p>选好要下载的，复制好下面这个<code>Run this Command</code></p>
<p>到前面准备好的<code>conda</code>环境去安装</p>
<p><s>需要魔法，否则可能会给你装疯，而且在查阅资料的时候发现用镜像有概率不能识别pytorch，即使你的pytorch是你的pytorch，但是你的pytorch不是你的pytorch</s></p>
<p><img src="/CUDA-and-pytorch/6dbdeed45283dcad3a1c1f91a769f6b3-1740145143702-8.png" alt></p>
<p>报警告不用慌张，不影响使用。如果是这样就安装好了。</p>
<p>下面就测试一下<code>pytorch</code>的使用情况</p>
<p><code>python</code></p>
<p><code>&gt;&gt;&gt; import torch</code></p>
<p>第一次应该会等很久，别乱动就是了</p>
<p><code>&gt;&gt;&gt; torch.cuda.is_available()</code></p>
<p>返回<code>true</code></p>
<p><code>&gt;&gt;&gt; import torch</code></p>
<p><code>&gt;&gt;&gt; torch.cuda.device_count()</code></p>
<p>返回<code>1</code></p>
<p>代表识别到一张显卡</p>
<p>大概就活了。</p>
<p><img src="/CUDA-and-pytorch/28dcd3a09bb512143de46b300b9d95e7-1740145143702-10.png" alt></p>
<p><code>exit()</code>退出去</p>
<p>简单的<code>pytorch</code>就装好了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Fast-Learning-FastAPI</title>
    <url>/Fast-Learning-FastAPI/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-fastapi">1. FastAPI</a>
<ul>
<li><a href="#11-part-1-%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA">1.1. part 1 <strong>简单创建</strong></a></li>
<li><a href="#12-part-2-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B">1.2. part 2 <strong>响应模型</strong></a></li>
<li><a href="#13-part-3-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">1.3. part 3 <strong>依赖注入</strong></a>
<ul>
<li><a href="#131-%E5%85%B1%E4%BA%AB%E9%80%9A%E7%94%A8%E5%8F%82%E6%95%B0">1.3.1. 共享通用参数</a></li>
<li><a href="#132-%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%BD%9C%E4%B8%BA%E5%AE%88%E5%8D%AB">1.3.2. 依赖项作为“守卫”</a></li>
</ul>
</li>
<li><a href="#14-part-4-%E7%BB%84%E7%BB%87%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8">1.4. part 4 组织大型应用</a></li>
<li><a href="#15-part-5-%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C">1.5. part 5 异步数据库操作</a></li>
</ul>
</li>
</ul>
</details>
<h1 id="1-fastapi"><a class="markdownIt-Anchor" href="#1-fastapi"></a> 1. FastAPI</h1>
<p><code>pip install fastapi uvicorn</code></p>
<h2 id="11-part-1-简单创建"><a class="markdownIt-Anchor" href="#11-part-1-简单创建"></a> 1.1. part 1 <strong>简单创建</strong></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#hello_world.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#*或者在终端中使用uvicorn main:app --reload</span></span><br></pre></td></tr></table></figure>
<p>我们添加<code>@app.get</code>部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure>
<p>此时访问<a href="http://127.0.0.1:8000/items/5">http://127.0.0.1:8000/items/5</a>    ，会发现返回了<code>{&quot;item_id&quot;:5}</code>,</p>
<p>如果访问的是<a href="http://127.0.0.1:8000/items/sast">127.0.0.1:8000/items/sast </a>   ，会发现返回的是<code>{&quot;detail&quot;:[{&quot;type&quot;:&quot;int_parsing&quot;,&quot;loc&quot;:[&quot;path&quot;,&quot;item_id&quot;],&quot;msg&quot;:&quot;Input should be a valid integer, unable to parse string as an integer&quot;,&quot;input&quot;:&quot;sast&quot;}]}</code></p>
<p>我们在<code>item_id</code>处使用注解要求其为<code>int</code>类型，能看到它会自动检验。</p>
<p>再向代码中添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_fake_item</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br></pre></td></tr></table></figure>
<p>此时访问<a href="http://127.0.0.1:8000/items/?skip=0&amp;limit=2">http://127.0.0.1:8000/items/?skip=0&amp;limit=2</a>    ，会发现返回是<code>[{&quot;item_name&quot;:&quot;Foo&quot;},{&quot;item_name&quot;:&quot;Bar&quot;}]</code></p>
<h2 id="12-part-2-响应模型"><a class="markdownIt-Anchor" href="#12-part-2-响应模型"></a> 1.2. part 2 <strong>响应模型</strong></h2>
<p><strong>请求体和 Pydantic 模型</strong></p>
<p>为了定义请求体的结构，FastAPI 使用了 Pydantic 库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: Item</span>):</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>然后也可以顺手用<code>requests</code>库来验证一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://127.0.0.1:8000/items/&quot;</span></span><br><span class="line"></span><br><span class="line">my_item = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;111test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;null&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: <span class="number">1145.14</span>,</span><br><span class="line">  <span class="string">&quot;tax&quot;</span>: <span class="number">666.25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, json=my_item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;状态码 (Status Code):&quot;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;响应内容 (Response JSON):&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br></pre></td></tr></table></figure>
<p><code>状态码 (Status Code): 200 响应内容 (Response JSON): {'name': '111test', 'description': 'null', 'price': 1145.14, 'tax': 666.25}</code></p>
<p>我们可以修改响应结果，为了让部分数据不可见之类的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemIn</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItemOut</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=ItemOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_item</span>(<span class="params">item: ItemIn</span>):</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>这样用相同的测试会发现是<code>{'name': '111test', 'price': 1145.14}</code></p>
<h2 id="13-part-3-依赖注入"><a class="markdownIt-Anchor" href="#13-part-3-依赖注入"></a> 1.3. part 3 <strong>依赖注入</strong></h2>
<p><code>Depends</code> 会告诉 <code>FastAPI</code>，``read_items<code>函数依赖于</code>common_parameters` 函数的返回值。它的核心优势在于 <strong>代码复用</strong> 和 <strong>逻辑分离</strong>。</p>
<h3 id="131-共享通用参数"><a class="markdownIt-Anchor" href="#131-共享通用参数"></a> 1.3.1. 共享通用参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个“依赖项”函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">common_parameters</span>(<span class="params">q: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q, <span class="string">&quot;skip&quot;</span>: skip, <span class="string">&quot;limit&quot;</span>: limit&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.9+ 推荐使用 Annotated 来组织 Depends</span></span><br><span class="line"><span class="comment"># CommonsDep 的意思就是：我需要一个 dict，这个 dict 是通过调用 common_parameters 函数得到的</span></span><br><span class="line">CommonsDep = Annotated[<span class="built_in">dict</span>, Depends(common_parameters)]</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line">fake_users_db = [&#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Alice&quot;</span>&#125;, &#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Bob&quot;</span>&#125;, &#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">commons: CommonsDep</span>):</span><br><span class="line">    <span class="comment"># commons 参数现在就是一个字典，比如 &#123;&quot;q&quot;: None, &quot;skip&quot;: 0, &quot;limit&quot;: 100&#125;</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons[<span class="string">&quot;q&quot;</span>]:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;query&quot;</span>: commons[<span class="string">&quot;q&quot;</span>]&#125;)</span><br><span class="line">    </span><br><span class="line">    items = fake_items_db[commons[<span class="string">&quot;skip&quot;</span>] : commons[<span class="string">&quot;skip&quot;</span>] + commons[<span class="string">&quot;limit&quot;</span>]]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;items&quot;</span>: items&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_users</span>(<span class="params">commons: CommonsDep</span>):</span><br><span class="line">    <span class="comment"># read_users 函数也轻松地复用了分页和查询逻辑</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons[<span class="string">&quot;q&quot;</span>]:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;query&quot;</span>: commons[<span class="string">&quot;q&quot;</span>]&#125;)</span><br><span class="line">    </span><br><span class="line">    users = fake_users_db[commons[<span class="string">&quot;skip&quot;</span>] : commons[<span class="string">&quot;skip&quot;</span>] + commons[<span class="string">&quot;limit&quot;</span>]]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;users&quot;</span>: users&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>现在，<code>/items/ </code>和 <code>/users/</code> 两个端点都拥有了同样的分页和查询能力，而我们只写了一次核心逻辑。这就是依赖注入最直观的好处。</p>
<h3 id="132-依赖项作为守卫"><a class="markdownIt-Anchor" href="#132-依赖项作为守卫"></a> 1.3.2. 依赖项作为“守卫”</h3>
<p>依赖注入一个更强大的用途是处理认证和授权</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Header, HTTPException</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">verify_token</span>(<span class="params">x_token: Annotated[<span class="built_in">str</span>, Header(<span class="params"></span>)]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个依赖项会检查请求头中是否包含 &#x27;X-Token&#x27;，并且值是否为 &#x27;fake-super-secret-token&#x27;</span></span><br><span class="line"><span class="string">    Header() 告诉 FastAPI 这个参数要从请求头里获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/protected-route/&quot;</span>, dependencies=[Depends(<span class="params">verify_token</span>)]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_protected_route</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个端点被依赖项保护起来了。</span></span><br><span class="line"><span class="string">    只有当请求头包含 X-Token: fake-super-secret-token 时，才能访问成功。</span></span><br><span class="line"><span class="string">    否则，客户端会直接收到 400 错误。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome, you have the correct token!&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-part-4-组织大型应用"><a class="markdownIt-Anchor" href="#14-part-4-组织大型应用"></a> 1.4. part 4 组织大型应用</h2>
<p>当API越来越多，把所有东西都写在同一个 <code>main.py</code> 文件里会变得难以维护。<code>APIRouter</code> 允许你将API按功能模块拆分到不同的文件中。</p>
<p>文件树如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/my_app</span><br><span class="line">|-- /routers</span><br><span class="line">|   |-- items.py</span><br><span class="line">|   |-- users.py</span><br><span class="line">|-- main.py</span><br></pre></td></tr></table></figure>
<p>然后内容如下</p>
<p><code>routers/items.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># routers/items.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, HTTPException</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个 APIRouter 实例</span></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/items&quot;</span>,            <span class="comment"># 为这个路由下的所有路径添加URL前缀</span></span><br><span class="line">    tags=[<span class="string">&quot;Items&quot;</span>],             <span class="comment"># 在API文档中为它们分组</span></span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Item not found&quot;</span>&#125;&#125;, <span class="comment"># 统一的错误响应</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=<span class="type">List</span>[Item]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据ID获取单个物品。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 在真实应用中，这里会是数据库查询</span></span><br><span class="line">    <span class="keyword">if</span> item_id &gt;= <span class="built_in">len</span>(fake_items_db) <span class="keyword">or</span> item_id &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fake_items_db[item_id]</span><br></pre></td></tr></table></figure>
<p><code>routers/users.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># routers/users.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, HTTPException</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserBase</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr  <span class="comment"># Pydantic内置的Email验证类型</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserCreate</span>(<span class="title class_ inherited__">UserBase</span>):</span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserPublic</span>(<span class="title class_ inherited__">UserBase</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/users&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;Users&quot;</span>],</span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;User not found&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fake_users_db = &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john.doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;john.doe@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;fake_hashed_password_123&quot;</span>, <span class="comment"># 模拟存储的是哈希后的密码</span></span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;jane.smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;jane.smith@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;Jane Smith&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;another_fake_password_456&quot;</span>,</span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=<span class="type">List</span>[UserPublic]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_users</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取一个用户列表，同样支持分页。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    users_list = <span class="built_in">list</span>(fake_users_db.values())</span><br><span class="line">    <span class="keyword">return</span> users_list[skip : skip + limit]</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/&quot;</span>, response_model=UserPublic, status_code=<span class="number">201</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">create_user</span>(<span class="params">user: UserCreate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个新用户。</span></span><br><span class="line"><span class="string">    在真实世界中，你会在这里哈希密码，然后存入数据库。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    new_user_id = <span class="built_in">max</span>(fake_users_db.keys()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    db_user = &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: new_user_id,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: user.username,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: user.email,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: user.full_name,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">f&quot;hashed_<span class="subst">&#123;user.password&#125;</span>&quot;</span>, <span class="comment"># 假装哈希了密码</span></span><br><span class="line">        <span class="string">&quot;is_active&quot;</span>: <span class="literal">True</span>, </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fake_users_db[new_user_id] = db_user</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;user_id&#125;&quot;</span>, response_model=UserPublic</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_user</span>(<span class="params">user_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据ID获取单个用户信息。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">not</span> <span class="keyword">in</span> fake_users_db:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;User not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fake_users_db[user_id]</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> routers <span class="keyword">import</span> items, users  <span class="comment"># &lt;-- 在这里导入 users</span></span><br><span class="line"></span><br><span class="line">app = FastAPI(title=<span class="string">&quot;我的模块化大型应用&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.include_router(items.router)</span><br><span class="line">app.include_router(users.router)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the main application&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>思考</strong>：目前items和users的数据是完全隔离的，并且每次服务器重启都会丢失。在真实应用中，这些数据应该存放在一个共享的、持久化的数据库中。接下来，我们将学习如何将FastAPI与真实数据库连接起来。</p>
</blockquote>
<h2 id="15-part-5-异步数据库操作"><a class="markdownIt-Anchor" href="#15-part-5-异步数据库操作"></a> 1.5. part 5 异步数据库操作</h2>
<p>到目前为止，我们都使用<code>Python</code>列表或字典作为假数据库。现在，我们将学习如何将<code>FastAPI</code>与一个真正的SQL数据库（以<code>PostgreSQL</code>为例）进行异步交互。</p>
<ul>
<li>[ ] To be continued</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-review</title>
    <url>/Leetcode-review/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90">68. 文本左右对齐</a></li>
<li><a href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97">392. 判断子序列</a></li>
<li><a href="#68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90-1">68. 文本左右对齐</a></li>
<li><a href="#1312-%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0">1312. 让字符串成为回文串的最少插入次数</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E6%B1%82lcs">如何求lcs</a></li>
</ul>
</li>
<li><a href="#3354-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%AD%89%E4%BA%8E%E9%9B%B6---%E5%8A%9B%E6%89%A3leetcode">3354. 使数组元素等于零 - 力扣（LeetCode）</a></li>
<li><a href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84---%E5%8A%9B%E6%89%A3leetcode">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></li>
<li><a href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8---%E5%8A%9B%E6%89%A3leetcode">11. 盛最多水的容器 - 力扣（LeetCode）</a></li>
<li><a href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C---%E5%8A%9B%E6%89%A3leetcode">15. 三数之和 - 力扣（LeetCode）</a></li>
<li><a href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84---%E5%8A%9B%E6%89%A3leetcode">209. 长度最小的子数组 - 力扣（LeetCode）</a></li>
<li><a href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2---%E5%8A%9B%E6%89%A3leetcode">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></li>
<li><a href="#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2---%E5%8A%9B%E6%89%A3leetcode">30. 串联所有单词的子串 - 力扣（LeetCode）</a></li>
<li><a href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2---%E5%8A%9B%E6%89%A3leetcode">76. 最小覆盖子串 - 力扣（LeetCode）</a></li>
<li><a href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC---%E5%8A%9B%E6%89%A3leetcode">36. 有效的数独 - 力扣（LeetCode）</a></li>
<li><a href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5---%E5%8A%9B%E6%89%A3leetcode">54. 螺旋矩阵 - 力扣（LeetCode）</a></li>
<li><a href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F---%E5%8A%9B%E6%89%A3leetcode">48. 旋转图像 - 力扣（LeetCode）</a></li>
<li><a href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6---%E5%8A%9B%E6%89%A3leetcode">73. 矩阵置零 - 力扣（LeetCode）</a></li>
<li><a href="#289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F---%E5%8A%9B%E6%89%A3leetcode">289. 生命游戏 - 力扣（LeetCode）</a></li>
<li><a href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1---%E5%8A%9B%E6%89%A3leetcode">383. 赎金信 - 力扣（LeetCode）</a></li>
<li><a href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2---%E5%8A%9B%E6%89%A3leetcode">205. 同构字符串 - 力扣（LeetCode）</a></li>
<li><a href="#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B---%E5%8A%9B%E6%89%A3leetcode">290. 单词规律 - 力扣（LeetCode）</a></li>
<li><a href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D---%E5%8A%9B%E6%89%A3leetcode">242. 有效的字母异位词 - 力扣（LeetCode）</a></li>
<li><a href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84---%E5%8A%9B%E6%89%A3leetcode">49. 字母异位词分组 - 力扣（LeetCode）</a></li>
<li><a href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C---%E5%8A%9B%E6%89%A3leetcode">1. 两数之和 - 力扣（LeetCode）</a></li>
<li><a href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0---%E5%8A%9B%E6%89%A3leetcode">202. 快乐数 - 力扣（LeetCode）</a></li>
<li><a href="#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii---%E5%8A%9B%E6%89%A3leetcode">219. 存在重复元素 II - 力扣（LeetCode）</a></li>
<li><a href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97---%E5%8A%9B%E6%89%A3leetcode">128. 最长连续序列 - 力扣（LeetCode）</a></li>
</ul>
</details>
<h2 id="68-文本左右对齐"><a class="markdownIt-Anchor" href="#68-文本左右对齐"></a> 68. 文本左右对齐</h2>
<p><a href="https://leetcode.cn/problems/text-justification/description/">68. 文本左右对齐 - 力扣（LeetCode）</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fullJustify</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    ans=[]</span><br><span class="line">    word_list=[]</span><br><span class="line">    cur_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">      <span class="keyword">if</span> cur_len + <span class="built_in">len</span>(word) + <span class="built_in">len</span>(word_list) &gt; maxWidth:</span><br><span class="line">        spaces = maxWidth - cur_len</span><br><span class="line">        gaps = <span class="built_in">len</span>(word_list) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> gaps == <span class="number">0</span>:</span><br><span class="line">          line = word_list[<span class="number">0</span>] + <span class="string">&#x27; &#x27;</span> * spaces</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          average,left = <span class="built_in">divmod</span>(spaces,gaps)</span><br><span class="line">          line = <span class="string">&#x27;&#x27;</span></span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gaps):</span><br><span class="line">            line += word_list[i]</span><br><span class="line">            line += average* <span class="string">&#x27; &#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;left:</span><br><span class="line">              line +=<span class="string">&#x27; &#x27;</span></span><br><span class="line">          line += word_list[-<span class="number">1</span>]</span><br><span class="line">        ans.append(line)</span><br><span class="line">        <span class="comment">#initialize</span></span><br><span class="line">        word_list = []</span><br><span class="line">        cur_len = <span class="number">0</span></span><br><span class="line">      word_list.append(word)</span><br><span class="line">      cur_len += <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="comment">#最后一行</span></span><br><span class="line">    line = <span class="string">&#x27; &#x27;</span>.join(word_list)</span><br><span class="line">    spaces = maxWidth - <span class="built_in">len</span>(line)</span><br><span class="line">    line += <span class="string">&#x27; &#x27;</span> * spaces</span><br><span class="line">    ans.append(line)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>一开始先写了处理溢出的情况，不过中间还需要先存储那些可以的word再合成一个line</p>
<p>思路就是一行一行读一行一行造，里面有一个问题是在这里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gaps):</span><br><span class="line">  line += word_list[i]</span><br><span class="line">  line += average* <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="keyword">if</span> i&lt;left:</span><br><span class="line">    line +=<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个<code>i&lt;left</code>我想了很久</p>
<p>left是余数，i是中间有的空格-1，这边要的效果是把余数在前面的空里面填满</p>
<p>那假设有3个要填的，有四个空格，要填的i是0，1，2，此时left=3</p>
<p>5个要填的，有七个空格，要填的i是0，1，2，3，4，此时left=5</p>
<p>那很明显可以用i&lt;left来限制</p>
<p>然后就造吧</p>
<h2 id="392-判断子序列"><a class="markdownIt-Anchor" href="#392-判断子序列"></a> <a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    it = <span class="built_in">iter</span>(t)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(c <span class="keyword">in</span> it <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure>
<p>迭代器神力，同时判断是不是在里面<br>
同时使用<code>all( )</code></p>
<h2 id="68-文本左右对齐-2"><a class="markdownIt-Anchor" href="#68-文本左右对齐-2"></a> <a href="https://leetcode.cn/problems/text-justification/">68. 文本左右对齐</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fullJustify</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    ans=[]</span><br><span class="line">    word_list=[]</span><br><span class="line">    cur_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">      <span class="keyword">if</span> cur_len + <span class="built_in">len</span>(word) + <span class="built_in">len</span>(word_list) &gt; maxWidth:</span><br><span class="line">        spaces = maxWidth - cur_len</span><br><span class="line">        gaps = <span class="built_in">len</span>(word_list) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> gaps == <span class="number">0</span>:</span><br><span class="line">          line = word_list[<span class="number">0</span>] + <span class="string">&#x27; &#x27;</span> * spaces</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          average,left = <span class="built_in">divmod</span>(spaces,gaps)</span><br><span class="line">          line = <span class="string">&#x27;&#x27;</span></span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gaps):</span><br><span class="line">            line += word_list[i]</span><br><span class="line">            line += average* <span class="string">&#x27; &#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;left:</span><br><span class="line">              line +=<span class="string">&#x27; &#x27;</span></span><br><span class="line">          line += word_list[-<span class="number">1</span>]</span><br><span class="line">        ans.append(line)</span><br><span class="line">        <span class="comment">#initialize</span></span><br><span class="line">        word_list = []</span><br><span class="line">        cur_len = <span class="number">0</span></span><br><span class="line">      word_list.append(word)</span><br><span class="line">      cur_len += <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="comment">#最后一行</span></span><br><span class="line">    line = <span class="string">&#x27; &#x27;</span>.join(word_list)</span><br><span class="line">    spaces = maxWidth - <span class="built_in">len</span>(line)</span><br><span class="line">    line += <span class="string">&#x27; &#x27;</span> * spaces</span><br><span class="line">    ans.append(line)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>思路：一行一行造<br>
先根据数量造出一行的<code>word_list</code>,然后计算出来中间的<code>gap</code>,然后根据规则和<code>divmod()</code>同时整除和求余再分配空格,然后组装</p>
<h2 id="1312-让字符串成为回文串的最少插入次数"><a class="markdownIt-Anchor" href="#1312-让字符串成为回文串的最少插入次数"></a> <a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minInsertions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    re_str=s[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      m = <span class="built_in">len</span>(text1)</span><br><span class="line">      n = <span class="built_in">len</span>(text2)</span><br><span class="line"></span><br><span class="line">      dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">          <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">return</span> dp[m][n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)-longestCommonSubsequence(s,re_str)</span><br></pre></td></tr></table></figure>
<p>套用了另外一道简单题目<code>lcs</code>，第一次涉及<code>dp</code></p>
<h3 id="如何求lcs"><a class="markdownIt-Anchor" href="#如何求lcs"></a> 如何求lcs</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  m = <span class="built_in">len</span>(text1)</span><br><span class="line">  n = <span class="built_in">len</span>(text2)</span><br><span class="line"></span><br><span class="line">  dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p>m = <code>&quot;abccdca&quot;</code><br>
n = <code>&quot;adcaab&quot;  lcs = </code>“aca”`</p>
<p><strong>情况一：两个字符串的最后一个字符相等</strong><br>
如果 <code>text1[i-1] == text2[j-1]</code></p>
<ul>
<li>这意味着我们找到了一个公共字符！这个字符<strong>必然</strong>可以作为它们公共子序列的一部分。</li>
<li>那么，text1 的前 i 个字符和 text2 的前 j 个字符的LCS，就等于它们<strong>各自去掉最后一个字符</strong>后的LCS长度再<strong>加1</strong>。</li>
<li>用 dp 数组来表示就是：<code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
</ul>
<p><strong>举例：</strong> 求 “ab<strong>c</strong>” 和 “ad<strong>c</strong>” 的LCS。因为最后一个字符 ‘c’ 相等，问题就转化为求 “ab” 和 “ad” 的LCS长度，然后加1。</p>
<p><strong>情况二：两个字符串的最后一个字符不相等</strong><br>
如果 <code>text1[i-1] != text2[j-1]</code></p>
<ul>
<li>这意味着这两个不同的字符<strong>不可能同时</strong>出现在LCS的末尾。</li>
<li>那么，我们就要在两种可能性中取一个较大值：
<ol>
<li>text1 的前 i 个字符和 text2 的前 j-1 个字符的LCS长度（相当于把 text2 的最后一个字符扔掉，看看结果）。这个值就是 <code>dp[i][j-1]</code>。</li>
<li>text1 的前 i-1 个字符和 text2 的前 j 个字符的LCS长度（相当于把 text1 的最后一个字符扔掉，看看结果）。这个值就是 <code>dp[i-1][j]</code>。</li>
</ol>
</li>
<li>我们取这两者中的最大值，因为它代表了更长的公共子序列。</li>
<li>用 dp 数组来表示就是：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
<p>这题看题解去吧,俺也懵懵的</p>
<h2 id="3354-使数组元素等于零-力扣leetcode"><a class="markdownIt-Anchor" href="#3354-使数组元素等于零-力扣leetcode"></a> <a href="https://leetcode.cn/problems/make-array-elements-equal-to-zero/">3354. 使数组元素等于零 - 力扣（LeetCode）</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">countValidSelections</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    num_sum= <span class="built_in">sum</span>(nums)</span><br><span class="line">    left_sum = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    right_sum = num_sum</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">      <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> left_sum == right_sum:</span><br><span class="line">          ans+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> left_sum - right_sum == <span class="number">1</span> <span class="keyword">or</span> right_sum - left_sum == <span class="number">1</span>:</span><br><span class="line">          ans+=<span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        left_sum+=num</span><br><span class="line">        right_sum=num_sum-left_sum</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路非常简单，发现题目根本没必要使用动态的想法</p>
<h2 id="167-两数之和-ii-输入有序数组-力扣leetcode"><a class="markdownIt-Anchor" href="#167-两数之和-ii-输入有序数组-力扣leetcode"></a> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    index1=<span class="number">0</span></span><br><span class="line">    index2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">      requirement=target-num</span><br><span class="line">      <span class="keyword">if</span> requirement <span class="keyword">in</span> numbers:</span><br><span class="line">        index1=index+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num == requirement:</span><br><span class="line">          index2 = numbers.index(requirement, index1) + <span class="number">1</span></span><br><span class="line">          <span class="keyword">return</span> [index1, index2]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          index2 = numbers.index(requirement) +<span class="number">1</span></span><br><span class="line">          <span class="keyword">return</span> [index1,index2]</span><br></pre></td></tr></table></figure>
<p>这是第一次ac代码，执行用时分布 5813ms 击败5.20%<br>
没错高贵的O(n^2),那可得好好优化一下了</p>
<p>在这应该使用<code>双指针</code>来快速查找,避免多次遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    left=<span class="number">0</span></span><br><span class="line">    right=<span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">      cur_sum=numbers[left]+numbers[right]</span><br><span class="line">      <span class="keyword">if</span> cur_sum==target:</span><br><span class="line">        <span class="keyword">return</span> [left+<span class="number">1</span>,right+<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">elif</span> cur_sum &lt; target:</span><br><span class="line">        left+=<span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        right-=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>该方法时间复杂度为O(n)  执行用时分布 4ms 击败50.86%<br>
<s>奇怪，为什么一样的算法他们能跑到0ms的，是我没充钱吗？</s></p>
<h2 id="11-盛最多水的容器-力扣leetcode"><a class="markdownIt-Anchor" href="#11-盛最多水的容器-力扣leetcode"></a> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器 - 力扣（LeetCode）</a></h2>
<p>贪心双指针一遍过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    max_volume=<span class="number">0</span></span><br><span class="line">    left=<span class="number">0</span></span><br><span class="line">    right=<span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left!=right):</span><br><span class="line">      x=right-left</span><br><span class="line">      y=<span class="built_in">min</span>(height[left],height[right])</span><br><span class="line">      v=x*y</span><br><span class="line">      <span class="keyword">if</span> v&gt;max_volume:</span><br><span class="line">        max_volume=v</span><br><span class="line">      <span class="keyword">if</span> height[left]&gt;=height[right]:</span><br><span class="line">        right-=<span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        left+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_volume</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和-力扣leetcode"><a class="markdownIt-Anchor" href="#15-三数之和-力扣leetcode"></a> <a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></h2>
<p>这是第一版🔟山,最后tle了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> sorted_nums:</span><br><span class="line">      <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    nums1 = sorted_nums[:count]</span><br><span class="line">    nums2 = sorted_nums[count:]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums1 <span class="keyword">or</span> <span class="keyword">not</span> nums2:</span><br><span class="line">      <span class="keyword">if</span> sorted_nums.count(<span class="number">0</span>) &gt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    seen = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">        k = -i - j</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> sorted_nums:</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> [i, j, k].count(i) &gt; sorted_nums.count(i):</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> [i, j, k].count(j) &gt; sorted_nums.count(j):</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> [i, j, k].count(k) &gt; sorted_nums.count(k):</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        triple = <span class="built_in">sorted</span>([i, j, k])</span><br><span class="line">        <span class="keyword">if</span> triple <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">          seen.append(triple)</span><br><span class="line">          ans.append(triple)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sorted_nums.count(<span class="number">0</span>) &gt;= <span class="number">3</span>:</span><br><span class="line">      ans.append([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>这是高贵的O(n^3)算法，暴力的后果还是被卡了啊，同时内存也多到爆炸，于是想到三指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    ans=[]</span><br><span class="line">    nums.sort()</span><br><span class="line">    n=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">      <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      left=i+<span class="number">1</span></span><br><span class="line">      right=n-<span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        s = nums[i]+nums[left]+nums[right]</span><br><span class="line">        <span class="keyword">if</span> s==<span class="number">0</span>:</span><br><span class="line">          ans.append([nums[i],nums[left],nums[right]])</span><br><span class="line">          <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]==nums[left+<span class="number">1</span>]:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">          <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]:</span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">          left+=<span class="number">1</span></span><br><span class="line">          right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s&lt;<span class="number">0</span>:</span><br><span class="line">          left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          right-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="209-长度最小的子数组-力扣leetcode"><a class="markdownIt-Anchor" href="#209-长度最小的子数组-力扣leetcode"></a> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></h2>
<p>滑动窗口初尝试，好像不难，和双指针很像了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n=<span class="built_in">len</span>(nums)</span><br><span class="line">    ans=n+<span class="number">1</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">      s+=num</span><br><span class="line">      <span class="keyword">while</span> s&gt;=target:</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">        s-=nums[left]</span><br><span class="line">        left+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ans==n+<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-力扣leetcode"><a class="markdownIt-Anchor" href="#3-无重复字符的最长子串-力扣leetcode"></a> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></h2>
<p>滑动窗口+hashmap</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">      <span class="keyword">while</span> s[end] <span class="keyword">in</span> seen:</span><br><span class="line">        seen.remove(s[start])</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">      seen.add(s[end])</span><br><span class="line">      maxlen = <span class="built_in">max</span>(maxlen, end - start + <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<p>和<a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">LCR 167. 招式拆解 I - 力扣（LeetCode）</a>是一样的，因此一起过了</p>
<h2 id="30-串联所有单词的子串-力扣leetcode"><a class="markdownIt-Anchor" href="#30-串联所有单词的子串-力扣leetcode"></a> <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串 - 力扣（LeetCode）</a></h2>
<p>一开始思路不好，神秘的O(n!xn)算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate_permutations</span>(<span class="params">self,words:<span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> words</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">      first = words[i]</span><br><span class="line">      rest = words[:i] + words[i+<span class="number">1</span>:]</span><br><span class="line">      <span class="keyword">for</span> sub <span class="keyword">in</span> <span class="variable language_">self</span>.generate_permutations(rest):</span><br><span class="line">        res.append(first + sub)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    sub_words = <span class="built_in">set</span>(<span class="variable language_">self</span>.generate_permutations(words))</span><br><span class="line">    l=<span class="built_in">len</span>(s)</span><br><span class="line">    window = <span class="built_in">len</span>(words[<span class="number">0</span>]) * <span class="built_in">len</span>(words)</span><br><span class="line">    <span class="keyword">if</span> window &gt; <span class="built_in">len</span>(s): <span class="keyword">return</span> []</span><br><span class="line">    ans=[]</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s) - window + <span class="number">1</span>): </span><br><span class="line">      <span class="keyword">if</span> s[start : start + window] <span class="keyword">in</span> sub_words:</span><br><span class="line">        ans.append(start)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>124 / 182 个通过的测试用例<br>
提交于 2025.10.30 21:35<br>
<code>s =&quot;fffffffffffffffffffffffffffffffff&quot;</code><br>
<code>words =[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</code><br>
很明显会因为生成子串的过程太长导致tle<br>
所以换一个思路，把words用键值对一一对应</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    word_len = <span class="built_in">len</span>(words[<span class="number">0</span>]) </span><br><span class="line">    total_len = word_len * <span class="built_in">len</span>(words)</span><br><span class="line">    word_map = &#123;w: words.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> words&#125; </span><br><span class="line">    ans = []</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - total_len + <span class="number">1</span>):</span><br><span class="line">      seen = &#123;&#125;</span><br><span class="line">      j = <span class="number">0</span>    </span><br><span class="line">      <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(words):</span><br><span class="line">        word_start = i + j * word_len</span><br><span class="line">        word_end = word_start + word_len</span><br><span class="line">        word = s[word_start:word_end]</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_map:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        seen[word] = seen.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> seen[word] &gt; word_map[word]:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> j == <span class="built_in">len</span>(words):</span><br><span class="line">        ans.append(i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/submissions/674785574">30. 串联所有单词的子串 - 力扣（LeetCode）</a><br>
这测试点诗人啊<br>
181 / 182 个通过的测试用例</p>
<p>ac代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    total_len = word_len * <span class="built_in">len</span>(words)</span><br><span class="line">    word_map = &#123;w: words.count(w) <span class="keyword">for</span> w <span class="keyword">in</span> words&#125;</span><br><span class="line">    ans = []</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">      left = offset</span><br><span class="line">      seen = &#123;&#125;</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(offset, n - word_len + <span class="number">1</span>, word_len):</span><br><span class="line">        word = s[right:right+word_len]</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> word_map:</span><br><span class="line">          seen[word] = seen.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">          count += <span class="number">1</span></span><br><span class="line">          <span class="keyword">while</span> seen[word] &gt; word_map[word]:</span><br><span class="line">            left_word = s[left:left+word_len]</span><br><span class="line">            seen[left_word] -= <span class="number">1</span></span><br><span class="line">            left += word_len</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> count == <span class="built_in">len</span>(words):</span><br><span class="line">            ans.append(left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          seen.clear()</span><br><span class="line">          count = <span class="number">0</span></span><br><span class="line">          left = right + word_len</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最快的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    step = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    total_len = step * <span class="built_in">len</span>(words)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">      map_word_cnt = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> map_word_cnt:</span><br><span class="line">          map_word_cnt[word] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          map_word_cnt[word] += <span class="number">1</span></span><br><span class="line">      match_cnt = <span class="built_in">len</span>(words)</span><br><span class="line">      right = i</span><br><span class="line">      <span class="keyword">while</span> right + step - <span class="number">1</span> &lt; n:</span><br><span class="line">        left = right + step - total_len</span><br><span class="line">        left_out = left - step</span><br><span class="line">        <span class="keyword">if</span> left_out &gt;= <span class="number">0</span>:</span><br><span class="line">          w_left_out = s[left_out:left_out+step]</span><br><span class="line">          <span class="keyword">if</span> w_left_out <span class="keyword">in</span> map_word_cnt:</span><br><span class="line">            map_word_cnt[w_left_out] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> map_word_cnt[w_left_out] &gt; <span class="number">0</span>:</span><br><span class="line">              match_cnt += <span class="number">1</span></span><br><span class="line">        w_right = s[right:right+step]</span><br><span class="line">        <span class="keyword">if</span> w_right <span class="keyword">in</span> map_word_cnt:</span><br><span class="line">          map_word_cnt[w_right] -= <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> map_word_cnt[w_right] &gt;= <span class="number">0</span>:</span><br><span class="line">            match_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> match_cnt == <span class="number">0</span>:</span><br><span class="line">          res.append(left)</span><br><span class="line">        right += step</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-力扣leetcode"><a class="markdownIt-Anchor" href="#76-最小覆盖子串-力扣leetcode"></a> <a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></h2>
<p>滑动窗口 哈希表</p>
<blockquote>
<p>如果min_len=len(s)会导致维护出错</p>
</blockquote>
<p>使用哈希表还是不熟练<br>
.items()忘了</p>
<p>还有一个注意点是切片，切片左闭右开 <code>[left , right + 1)</code> 老记错<br>
<code>right-left+1</code> 是长度</p>
<p>滑动窗口从窗口为零开始，向右扩张，同时维护<code>window_counts</code> ，一边向右添加一边保持左边没有额外的字符<br>
就这样遍历，复杂度O(N) 600ms 击败44.06%</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    t_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">      <span class="keyword">if</span> char <span class="keyword">in</span> t_count:</span><br><span class="line">        t_count[char] += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        t_count[char] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t_count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, current_dict: <span class="built_in">dict</span>, t_count: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">for</span> char, required_count <span class="keyword">in</span> t_count.items():</span><br><span class="line">      <span class="keyword">if</span> current_dict.get(char, <span class="number">0</span>) &lt; required_count:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    t_count = <span class="variable language_">self</span>.count(t)</span><br><span class="line">    window_counts = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    min_len = <span class="built_in">len</span>(s) + <span class="number">1</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">      char_in = s[right]</span><br><span class="line">      window_counts[char_in] = window_counts.get(char_in, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> <span class="variable language_">self</span>.check(window_counts, t_count):</span><br><span class="line">        current_len = right - left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current_len &lt; min_len:</span><br><span class="line">          min_len = current_len</span><br><span class="line">          result = s[left : right + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        char_out = s[left]</span><br><span class="line">        window_counts[char_out] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> window_counts[char_out] == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">del</span> window_counts[char_out]</span><br><span class="line"></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这次想法里面的问题所在是这块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, current_dict: <span class="built_in">dict</span>, t_count: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">  <span class="keyword">for</span> char, required_count <span class="keyword">in</span> t_count.items(): </span><br><span class="line">    <span class="keyword">if</span> current_dict.get(char, <span class="number">0</span>) &lt; required_count:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这个循环的次数取决于 t 中有多少个 不重复 的字符<br>
但是如果字典有27个字符的时候就很明显不合理了<br>
而且check了非常非常多次，也浪费了很多的时间<br>
看看这个代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    need=defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">      need[c]+=<span class="number">1</span></span><br><span class="line">    needCnt=<span class="built_in">len</span>(t)</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    res=(<span class="number">0</span>,<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> j,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">      <span class="keyword">if</span> need[c]&gt;<span class="number">0</span>:</span><br><span class="line">        needCnt-=<span class="number">1</span></span><br><span class="line">      need[c]-=<span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> needCnt==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          c=s[i]</span><br><span class="line">          <span class="keyword">if</span> need[c]==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          need[c]+=<span class="number">1</span></span><br><span class="line">          i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j-i&lt;res[<span class="number">1</span>]-res[<span class="number">0</span>]:</span><br><span class="line">          res=(i,j)</span><br><span class="line">        need[s[i]]+=<span class="number">1</span></span><br><span class="line">        needCnt+=<span class="number">1</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span><span class="keyword">if</span> res[<span class="number">1</span>]&gt;<span class="built_in">len</span>(s) <span class="keyword">else</span> s[res[<span class="number">0</span>]:res[<span class="number">1</span>]+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>在这边发现了defaultdict，这才知道leetcode已经import过了collections<br>
那这块内容需要好好学一学,写到Python-algorithm去</p>
<h2 id="36-有效的数独-力扣leetcode"><a class="markdownIt-Anchor" href="#36-有效的数独-力扣leetcode"></a> <a href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独 - 力扣（LeetCode）</a></h2>
<p>这题只要判断是否合理，不需要解出来数独其实还好<br>
一次遍历就行了<br>
用set来创建集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    rows = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">    cols = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">    boxes = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">        num = board[i][j]</span><br><span class="line">        <span class="keyword">if</span> num == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> rows[i]:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows[i].add(num)</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> cols[j]:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cols[j].add(num)</span><br><span class="line"></span><br><span class="line">        box_index = (i // <span class="number">3</span>) * <span class="number">3</span> + (j // <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> boxes[box_index]:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        boxes[box_index].add(num)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵-力扣leetcode"><a class="markdownIt-Anchor" href="#54-螺旋矩阵-力扣leetcode"></a> <a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></h2>
<p>我的思路是用上下左右限制，有点复杂，维护起来也好累。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    num_rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">    num_cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, num_cols - <span class="number">1</span></span><br><span class="line">    top, bottom = <span class="number">0</span>, num_rows - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">        ans.append(matrix[top][col])</span><br><span class="line">      top += <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">        ans.append(matrix[row][right])</span><br><span class="line">      right -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> (left &lt;= right <span class="keyword">and</span> top &lt;= bottom):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        ans.append(matrix[bottom][col])</span><br><span class="line">      bottom -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        ans.append(matrix[row][left])</span><br><span class="line">      left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但看官方第二种解法是这样的<br>
对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。</p>
<p>从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。</p>
<p>从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</p>
<p>如果 left&lt;right 且 top&lt;bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。</p>
<p>遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<h2 id="48-旋转图像-力扣leetcode"><a class="markdownIt-Anchor" href="#48-旋转图像-力扣leetcode"></a> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像 - 力扣（LeetCode）</a></h2>
<p>想法很多都不好实现。<br>
没写，但是看到了一个逆天答案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    matrix[:] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*matrix)))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix: row.reverse()</span><br></pre></td></tr></table></figure>
<h2 id="73-矩阵置零-力扣leetcode"><a class="markdownIt-Anchor" href="#73-矩阵置零-力扣leetcode"></a> <a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零 - 力扣（LeetCode）</a></h2>
<p>思路非常简单，找到0的位置，然后直接改，这题目凭什么是中档题？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">    cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">          temp.append([i, j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> temp:</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        matrix[r][j] = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        matrix[i][c] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>但由于使用了temp存储，导致空间复杂度为O(M+N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    flag_col0 = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">      <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        flag_col0 = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">          matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">          matrix[i][j] = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> flag_col0:</span><br><span class="line">        matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个是leetcode官方给出的空间复杂度为O(1)的算法<br>
如果<code> matrix[i][j]</code>是 0，它就把这个信息记录在 <code>matrix[i][0]</code>和 <code>matrix[0][j]</code> 上，将它们也设置为 0。<br>
这样一来，<code>matrix[i][0]</code>就成了第 i 行是否需要置零的标记位。<br>
同理，<code>matrix[0][j]</code>就成了第 j 列是否需要置零的标记位。<br>
很巧妙的直接使用原矩阵在不破坏的情况下标记并且置零，不额外开空间</p>
<h2 id="289-生命游戏-力扣leetcode"><a class="markdownIt-Anchor" href="#289-生命游戏-力扣leetcode"></a> <a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏 - 力扣（LeetCode）</a></h2>
<p>充满小巧思了<br>
第一个小巧思是使用元组来传neighbor,然后python会自动解包，写起来好看<br>
第二个小巧思是要判断当前状态：状态 1 和 2 都代表“原来是活的”，状态 0 和 3 都代表“原来是死的”<br>
这样区分避免出现在修改过程中误判的情况，最后第二次遍历把状态再修正<br>
和官方第二个题解差不多，但是官方只用到2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">gameOfLife</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    neighbors = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        alive = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> neighbors:</span><br><span class="line">          r, c = i + dx, j + dy</span><br><span class="line">          <span class="keyword">if</span> <span class="number">0</span> &lt;= r &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt; n:</span><br><span class="line">            <span class="keyword">if</span> board[r][c] == <span class="number">1</span> <span class="keyword">or</span> board[r][c] == <span class="number">2</span>:</span><br><span class="line">              alive += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">1</span> <span class="keyword">and</span> (alive &lt; <span class="number">2</span> <span class="keyword">or</span> alive &gt; <span class="number">3</span>):</span><br><span class="line">          board[i][j] = <span class="number">2</span> </span><br><span class="line">        <span class="keyword">elif</span> board[i][j] == <span class="number">0</span> <span class="keyword">and</span> alive == <span class="number">3</span>:</span><br><span class="line">          board[i][j] = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> board[i][j] == <span class="number">2</span>:</span><br><span class="line">          board[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> board[i][j] == <span class="number">3</span>:</span><br><span class="line">          board[i][j] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="383-赎金信-力扣leetcode"><a class="markdownIt-Anchor" href="#383-赎金信-力扣leetcode"></a> <a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信 - 力扣（LeetCode）</a></h2>
<p>用Counter自动计数<br>
然后直接在本体上操作就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    magazine_counts = Counter(magazine)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> ransomNote:</span><br><span class="line">      <span class="keyword">if</span> magazine_counts[char] &gt; <span class="number">0</span>:</span><br><span class="line">        magazine_counts[char] -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这样写也可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote)&gt;<span class="built_in">len</span>(magazine) <span class="keyword">or</span> <span class="built_in">len</span>(<span class="built_in">set</span>(magazine)) &lt; <span class="built_in">len</span>(<span class="built_in">set</span>(ransomNote)):</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">      count[i] = count.get(i,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">      <span class="keyword">if</span> count.get(i, <span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      count[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="205-同构字符串-力扣leetcode"><a class="markdownIt-Anchor" href="#205-同构字符串-力扣leetcode"></a> <a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串 - 力扣（LeetCode）</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    s2tdict=&#123;&#125;</span><br><span class="line">    t2sdict=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> sstr,tstr <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">      <span class="keyword">if</span> sstr <span class="keyword">in</span> s2tdict <span class="keyword">and</span> s2tdict[sstr]!=tstr:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      <span class="keyword">if</span> tstr <span class="keyword">in</span> t2sdict <span class="keyword">and</span> t2sdict[tstr]!=sstr:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      s2tdict[sstr]=tstr</span><br><span class="line">      t2sdict[tstr]=sstr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>但是zip()用法太别致了吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(t)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s, t)))</span><br></pre></td></tr></table></figure>
<p>被吓哭了<br>
也许应该复习一下set()和zip()<br>
set(t)创建的是t中所有<strong>不重复</strong>字符的集合<br>
zip(s, t) 会生成一系列的配对元组（tuple）：<br>
(‘p’, ‘t’), (‘a’, ‘i’), (‘p’, ‘t’), (‘e’, ‘l’), (‘r’, ‘e’)<br>
这些配对就代表了 s 到 t 的映射关系。例如，第一个 ‘p’ 映射到 ‘t’，‘a’ 映射到 ‘i’，第二个 ‘p’ 也映射到 ‘t’。<br>
因此映射和set()长度相同的情况下就可以得出结论</p>
<h2 id="290-单词规律-力扣leetcode"><a class="markdownIt-Anchor" href="#290-单词规律-力扣leetcode"></a> <a href="https://leetcode.cn/problems/word-pattern/">290. 单词规律 - 力扣（LeetCode）</a></h2>
<p>和上一题同一个道理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    s2list=s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    p2list=<span class="built_in">list</span>(pattern)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s2list)==<span class="built_in">len</span>(p2list) <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s2list,p2list)))==<span class="built_in">len</span>(<span class="built_in">set</span>(s2list))==<span class="built_in">len</span>(<span class="built_in">set</span>(p2list))</span><br></pre></td></tr></table></figure>
<p>思路：<code>s2list</code>和<code>p2list</code><br>
首先两个长度要相等<br>
然后要保证set出来的长度也相同<br>
eg:<br>
“abba”“wow mom mom wow”<br>
set(list(“abba”))={“a”,“b”}<br>
set(list(“wow mom mom wow”.split(&quot; &quot;)))={“wow”,“mom”}<br>
set(zip(s2list,p2list))={(“a”,“wow”),(“b”,“mom”)}</p>
<h2 id="242-有效的字母异位词-力扣leetcode"><a class="markdownIt-Anchor" href="#242-有效的字母异位词-力扣leetcode"></a> <a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    s2list=<span class="built_in">list</span>(s)</span><br><span class="line">    t2list=<span class="built_in">list</span>(t)</span><br><span class="line">    scounter=Counter(s2list)</span><br><span class="line">    tcounter=Counter(t2list)</span><br><span class="line">    <span class="keyword">if</span> scounter==tcounter:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>其实&quot;str&quot;可以直接到Counter里面去使用<br>
直接<code>return Counter(t)==Counter(s)</code>就结束了<br>
或者也可以使用sorted(),<code>return sorted(t)==sorted(s)</code></p>
<h2 id="49-字母异位词分组-力扣leetcode"><a class="markdownIt-Anchor" href="#49-字母异位词分组-力扣leetcode"></a> <a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组 - 力扣（LeetCode）</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">    anagram_map = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">      sorted_s=<span class="built_in">str</span>(<span class="built_in">sorted</span>(s))</span><br><span class="line">      anagram_map[sorted_s].append(s)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(anagram_map.values())</span><br></pre></td></tr></table></figure>
<p>复杂度是O(Nklogk)，有点高了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> [strs]</span><br><span class="line">    ans= &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ss <span class="keyword">in</span> strs:</span><br><span class="line">      s = <span class="built_in">str</span>(<span class="built_in">sorted</span>(ss))</span><br><span class="line">      <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> ans : </span><br><span class="line">        ans[s] = [ss]</span><br><span class="line">      <span class="keyword">else</span> :</span><br><span class="line">        ans[s].append(ss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(ans.values())</span><br></pre></td></tr></table></figure>
<p>这样一个道理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">    mp = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs:</span><br><span class="line">      key=<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(<span class="built_in">str</span>))</span><br><span class="line">      mp[key].append(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(mp.values())</span><br></pre></td></tr></table></figure>
<h2 id="1-两数之和-力扣leetcode"><a class="markdownIt-Anchor" href="#1-两数之和-力扣leetcode"></a> <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></h2>
<p>哈希</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    num_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">      complement = target - num</span><br><span class="line">      <span class="keyword">if</span> complement <span class="keyword">in</span> num_map:</span><br><span class="line">        <span class="keyword">return</span> [num_map[complement], i]</span><br><span class="line">      num_map[num] = i</span><br><span class="line">    <span class="keyword">return</span> []Q</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数-力扣leetcode"><a class="markdownIt-Anchor" href="#202-快乐数-力扣leetcode"></a> <a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></h2>
<p>第一版<br>
371 / 420 个通过的测试用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">while</span> n/<span class="number">10</span>&gt;<span class="number">1</span>:</span><br><span class="line">      <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">      n2str=<span class="built_in">str</span>(n)</span><br><span class="line">      <span class="keyword">for</span> num <span class="keyword">in</span> n2str:</span><br><span class="line">        <span class="built_in">sum</span>+=(<span class="built_in">int</span>(num))**<span class="number">2</span></span><br><span class="line">      n=<span class="built_in">sum</span></span><br><span class="line">      <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>while那边的判断条件写错了，看到测试用例7,在一开始就返回false了，但是迭代到最后是可以到1的</p>
<p>第二版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">      seen.add(n)</span><br><span class="line"></span><br><span class="line">      total_sum = <span class="number">0</span></span><br><span class="line">      n2str = <span class="built_in">str</span>(n)</span><br><span class="line">      <span class="keyword">for</span> digit <span class="keyword">in</span> n2str:</span><br><span class="line">        total_sum += <span class="built_in">int</span>(digit) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      n = total_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度O(Log(N))，7ms在这个题目里算最慢的一档了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">      result.append(n)</span><br><span class="line">      s = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n):</span><br><span class="line">        s+=<span class="built_in">int</span>(i)**<span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> s == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      n = s</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>4ms<br>
稍微快了一些</p>
<h2 id="219-存在重复元素-ii-力扣leetcode"><a class="markdownIt-Anchor" href="#219-存在重复元素-ii-力扣leetcode"></a> <a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II - 力扣（LeetCode）</a></h2>
<p>思路：用map存，时间复杂度O(N)，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    num_map=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">      <span class="keyword">if</span> num <span class="keyword">in</span> num_map <span class="keyword">and</span> i - num_map[num] &lt;= k:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      num_map[num] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>官方第二个滑动窗口<br>
思路是维护k+1大小的set</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">      <span class="keyword">if</span> i &gt; k:</span><br><span class="line">        s.remove(nums[i - k - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">if</span> num <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      s.add(num)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="128-最长连续序列-力扣leetcode"><a class="markdownIt-Anchor" href="#128-最长连续序列-力扣leetcode"></a> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列 - 力扣（LeetCode）</a></h2>
<p>思路：去重，然后迭代，哈希表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    longest_streak = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">      <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">        current_num = num</span><br><span class="line">        current_streak = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> current_num + <span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">          current_num += <span class="number">1</span></span><br><span class="line">          current_streak += <span class="number">1</span></span><br><span class="line">        longest_streak = <span class="built_in">max</span>(longest_streak, current_streak)</span><br><span class="line">    <span class="keyword">return</span> longest_streak</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network</title>
    <url>/Computer-Network/</url>
    <content><![CDATA[<h1 id="计算机网络-computer-network"><a class="markdownIt-Anchor" href="#计算机网络-computer-network"></a> 计算机网络 / Computer Network</h1>
<h2 id="网络全貌-network-overview"><a class="markdownIt-Anchor" href="#网络全貌-network-overview"></a> 网络全貌 / Network Overview</h2>
<h3 id="网络定义-network-definition"><a class="markdownIt-Anchor" href="#网络定义-network-definition"></a> 网络定义 / Network Definition</h3>
<blockquote>
<p><strong>Concept: 什么是网络 (Network)?</strong><br>
<strong>网络</strong>是指一组通过物理介质互连、遵循共同的<strong>标准 (Standards)</strong> 与 <strong>协议 (Protocols)</strong> 从而能够相互交换数据的计算机和其他设备<br>
Core：<strong>网络 = 物理互连 + 通信协议</strong></p>
</blockquote>
<blockquote>
<p>本节和学校计网授课风格不同，仅作为计网入门，对408并无参考意义<br>
对于没有接触过的同学可能会感觉知识高密度输入，但请先别疑惑，细节和底层可以在以后的学习里面去理解，<strong>不要半途而废</strong><br>
内容逻辑性较强，慢慢理解</p>
</blockquote>
<p>为什么学习计算机网络？<br>
<s>至少让自己不单单当一个调包侠</s><br>
想学而不是不得不学</p>
<h3 id="物理连接-physical-connection"><a class="markdownIt-Anchor" href="#物理连接-physical-connection"></a> 物理连接 / Physical Connection</h3>
<p>要实现通信，首先需要物理层面的连通</p>
<ul>
<li><strong>物理介质 (Physical Media)</strong>: 双绞线（网线）、光纤、无线电波等，用于承载信号</li>
<li><strong>连通性 (Connectivity)</strong>: 物理介质将设备连接在一起，形成通路</li>
</ul>
<p>在网络拓扑中，我们定义以下角色：</p>
<ul>
<li><strong>节点 (Nodes)</strong>: 网络中的任何可寻址设备</li>
<li><strong>主机 (Host) / 端系统 (End System)</strong>: 网络的边缘，运行应用程序（如 PC、手机、服务器）</li>
<li><strong>中间设备 (Intermediary Device)</strong>: 网络的核心，负责数据转发（如路由器 Router、交换机 Switch）</li>
<li><strong>链路 (Links)</strong>: 连接节点的物理通道</li>
</ul>
<p><img src="/Computer-Network/network.png" alt="network"></p>
<h3 id="逻辑规则-logical-rules"><a class="markdownIt-Anchor" href="#逻辑规则-logical-rules"></a> 逻辑规则 / Logical Rules</h3>
<p>物理连接只是基础，设备之间还需要懂得对方的“语言”，这就需要<strong>网络协议(Network Protocol)</strong></p>
<blockquote>
<p>为了方便讲解，后续的<strong>协议</strong>指的都是<strong>网络协议</strong></p>
</blockquote>
<blockquote>
<p><strong>Definition: 协议 (Protocol)</strong><br>
协议是通信双方为了进行数据交换而建立的规则、标准或约定的集合<br>
一个完整的协议通常包含三个要素：</p>
<ol>
<li><strong>语法 (Syntax)</strong>: 数据与控制信息的结构或格式（例如：前8位是地址，后8位是数据）</li>
<li><strong>语义 (Semantics)</strong>: 发出何种控制信息，完成何种动作以及做出何种响应（例如：收到 “RST” 包表示重置连接）</li>
<li><strong>时序 (Timing)</strong>: 事件实现顺序的详细说明（例如：先握手，再传数据）</li>
</ol>
</blockquote>
<p>协议 = 语法 + 语义 + 时序</p>
<h3 id="数据交换-packet-switching"><a class="markdownIt-Anchor" href="#数据交换-packet-switching"></a> 数据交换 / Packet Switching</h3>
<p>有了物理连接和逻辑协议，数据究竟是如何在网络中传输的？互联网采用的是革命性的<strong>分组交换</strong>技术</p>
<h4 id="数据包与封装-data-packets-encapsulation"><a class="markdownIt-Anchor" href="#数据包与封装-data-packets-encapsulation"></a> 数据包与封装 / Data Packets &amp; Encapsulation</h4>
<p>在计算机网络中，应用数据并不是以连续的流（Stream）一次性传输的，而是被切割成更小的数据块</p>
<blockquote>
<p><strong>Definition: 数据包 (Data Packet)</strong><br>
数据包是网络传输的最小逻辑单位。它由两部分组成：</p>
<ol>
<li><strong>首部 (Header)</strong>: 包含控制信息（如源地址、目的地址、序列号、校验和）</li>
<li><strong>负载 (Payload)</strong>: 实际要传输的用户数据</li>
</ol>
</blockquote>
<p><strong>封装 (Encapsulation)</strong> 是分层架构的核心机制：</p>
<ul>
<li>每一层协议在发送数据时，都会在上一层数据的前面加上自己的 <strong>Header</strong></li>
<li><strong>关键</strong>: 对于下层协议而言，上层传递下来的整个数据包（Header + Payload），都仅仅是下层的 <strong>Payload</strong></li>
</ul>
<p>每一层都在给数据贴标签，这层贴完给下一层，下一层根本不看里面的内容，只看标签办事</p>
<blockquote>
<p>在此处一定要记住这个概念，在见到没见过的东西你可以安慰自己说它是封装很好（</p>
</blockquote>
<p><img src="/Computer-Network/UDP_encapsulation.svg" alt="UDP_encapsulation"></p>
<h4 id="分组交换-packet-switching"><a class="markdownIt-Anchor" href="#分组交换-packet-switching"></a> 分组交换 / Packet Switching</h4>
<p>现代互联网（Internet）的基础设计思想是分组交换，它区别于传统电话网的电路交换</p>
<blockquote>
<p><strong>Concept: 分组交换 vs. 电路交换</strong></p>
<p><strong>电路交换 (Circuit Switching)</strong>: 通信前必须建立一条<strong>独占</strong>的物理通路，论是否通话，资源都被占用，效率低下<br>
<strong>分组交换 (Packet Switching)</strong>: 数据被切分成多个包，每个包独立寻找路径到达目的地</p>
</blockquote>
<p>分组交换具有两个核心特征：<br>
<strong>1. 统计多路复用 (Statistical Multiplexing)</strong><br>
链路带宽资源不是按固定时隙分配给用户的，而是<strong>按需分配</strong></p>
<ul>
<li>多个用户的数据流交织在同一条链路中传输。这极大提高了带宽利用率，但也引入了拥塞的可能性</li>
</ul>
<p><strong>2. 存储转发 (Store-and-Forward)</strong><br>
路由器（交换节点）在向下一跳转发数据包之前，必须<strong>完整地接收</strong>该数据包</p>
<ul>
<li><strong>过程</strong>:
<ol>
<li><strong>Store</strong>: 路由器先将整个包接收并存储在缓存（Buffer）中</li>
<li><strong>Process</strong>: 检查 Header（查路由表、校验错误）</li>
<li><strong>Forward</strong>: 将包推送到正确的输出链路</li>
</ol>
</li>
<li><strong>代价</strong>: 这一机制是网络<strong>时延 (Latency)</strong> 的主要物理来源之一。如果链路拥塞，包会在路由器的缓存队列中排队，产生<strong>排队时延</strong></li>
</ul>
<p><img src="/Computer-Network/Package.gif" alt="Package"></p>
<h3 id="性能指标-performance-metrics"><a class="markdownIt-Anchor" href="#性能指标-performance-metrics"></a> 性能指标 / Performance Metrics</h3>
<blockquote>
<p>在这只是一个知识补充</p>
</blockquote>
<p>那如何衡量网络性能？</p>
<h4 id="速率与带宽-rate-bandwidth"><a class="markdownIt-Anchor" href="#速率与带宽-rate-bandwidth"></a> 速率与带宽 / Rate &amp; Bandwidth</h4>
<p>单位时间内传输的数据量（bps）</p>
<h4 id="时延-latency"><a class="markdownIt-Anchor" href="#时延-latency"></a> 时延 / Latency</h4>
<p>数据从一端传送到另一端所需的时间</p>
<ul>
<li>发送时延（推数据）</li>
<li>传播时延（光速跑）</li>
<li>处理时延（路由器检查）</li>
<li>排队时延（路由器堵车）</li>
</ul>
<h4 id="吞吐量-throughput"><a class="markdownIt-Anchor" href="#吞吐量-throughput"></a> 吞吐量 / Throughput</h4>
<p>实际通过网络的有效数据速率（受带宽和拥塞控制影响）</p>
<h4 id="丢包率-packet-loss"><a class="markdownIt-Anchor" href="#丢包率-packet-loss"></a> 丢包率 / Packet Loss</h4>
<p><strong>丢包率</strong>（Packet Loss Rate）是指在数据传输过程中，丢失的数据包数量占所发送数据包总数的比率。它是衡量网络性能的重要指标之一。丢包率的计算公式为：</p>
<blockquote>
<p>丢包率 = [(输入报文 - 输出报文) / 输入报文] * 100%</p>
</blockquote>
<h3 id="分层模型-layered-architecture"><a class="markdownIt-Anchor" href="#分层模型-layered-architecture"></a> 分层模型 / Layered Architecture</h3>
<p>网络极其复杂，为了降低复杂度，我们采用<strong>分层</strong>的设计思想</p>
<p>为了把协议标准化，历史上出现了两种主要模型：</p>
<h4 id="osi-七层模型-osi-model"><a class="markdownIt-Anchor" href="#osi-七层模型-osi-model"></a> OSI 七层模型 / OSI Model</h4>
<p>学术界的“理想国”，分得非常细，非常完美，但太复杂，实现困难</p>
<ol>
<li><strong>物理层</strong>：传比特流 (Bit)</li>
<li><strong>数据链路层</strong>：传帧 (Frame)，管网卡MAC地址</li>
<li><strong>网络层</strong>：传包 (Packet)，管IP地址，选路</li>
<li><strong>传输层</strong>：管端到端连接 (TCP/UDP)</li>
<li><strong>会话层</strong>：管理会话状态。（TCP/IP中无）</li>
<li><strong>表示层</strong>：数据加密、压缩、编码。（TCP/IP中无）</li>
<li><strong>应用层</strong>：直接服务用户</li>
</ol>
<h4 id="tcpip-模型-tcpip-model"><a class="markdownIt-Anchor" href="#tcpip-模型-tcpip-model"></a> TCP/IP 模型 / TCP/IP Model</h4>
<p>工业界的事实标准，更加实用.它把 OSI 繁琐的 5、6、7 层合并了</p>
<ol>
<li><strong>网络接口层</strong> (对应 OSI 的 1, 2)</li>
<li><strong>网际层</strong> (对应 OSI 的 3)</li>
<li><strong>传输层</strong> (对应 OSI 的 4)</li>
<li><strong>应用层</strong> (对应 OSI 的 5, 6, 7)</li>
</ol>
<blockquote>
<p><strong>注意</strong>: 在 TCP/IP 模型中，会话管理（Session）和数据表示（Presentation）的功能被下放给应用程序开发者自行实现，操作系统内核不负责这两层</p>
</blockquote>
<p><img src="/Computer-Network/osivstcpip.png" alt="osivstcpip"></p>
<h2 id="应用层-application-layer"><a class="markdownIt-Anchor" href="#应用层-application-layer"></a> 应用层 / Application Layer</h2>
<blockquote>
<p><strong>Definition: 应用层</strong><br>
应用层是网络应用程序及其应用层协议驻留的地方。它是协议栈的顶层，直接为用户进程提供服务</p>
</blockquote>
<p>需要知道的是，应用程序!=应用层</p>
<h3 id="应用架构-application-architectures"><a class="markdownIt-Anchor" href="#应用架构-application-architectures"></a> 应用架构 / Application Architectures</h3>
<p>谁来做服务端？谁来做客户端？</p>
<h4 id="大型机模式-mainframe-model"><a class="markdownIt-Anchor" href="#大型机模式-mainframe-model"></a> 大型机模式 / Mainframe Model</h4>
<p>很老的东西，又称为分时共享模式，面向终端的多用户计算机系统</p>
<h4 id="客户-服务器架构-client-server-architecture"><a class="markdownIt-Anchor" href="#客户-服务器架构-client-server-architecture"></a> 客户-服务器架构 / Client-Server Architecture</h4>
<p>客户端（Client）间歇性连接，IP 可变<br>
固定的服务器（Server），一直开机，IP 固定<br>
现在非常常用<br>
在客户机发出命令，在服务器中处理并返回结果</p>
<h4 id="对等网络架构-p2p-architecture"><a class="markdownIt-Anchor" href="#对等网络架构-p2p-architecture"></a> 对等网络架构 / P2P Architecture</h4>
<p>没有中心服务器，任意端系统之间直接通信<br>
虽然这个方法扩展性强，但难以管理<br>
<code>BitTorrent</code> 就是使用了这个架构<br>
<img src="/Computer-Network/CSP2P.jpg" alt="CSP2P"></p>
<h4 id="浏览器-服务器架构-bs-architecture"><a class="markdownIt-Anchor" href="#浏览器-服务器架构-bs-architecture"></a> 浏览器-服务器架构 / B/S Architecture</h4>
<p><img src="/Computer-Network/BrowserServer.jpg" alt="BrowserServer"></p>
<h3 id="进程寻址-process-addressing"><a class="markdownIt-Anchor" href="#进程寻址-process-addressing"></a> 进程寻址 / Process Addressing</h3>
<blockquote>
<p>网络很大，我怎么找到你？</p>
</blockquote>
<p>应用层通信的本质是<strong>进程（Process)</strong> 之间的通信</p>
<h4 id="端口号-port-number"><a class="markdownIt-Anchor" href="#端口号-port-number"></a> 端口号 / Port Number</h4>
<ul>
<li><strong>定义</strong>：一个 16 位的整数，用于标识主机上运行的特定进程</li>
<li><strong>分类</strong>：熟知端口（0-1023，如 HTTP 80, HTTPS 443, ssh 22），注册端口（1024-49151），动态端口（49152-65535）</li>
</ul>
<h4 id="套接字-socket"><a class="markdownIt-Anchor" href="#套接字-socket"></a> 套接字 / Socket</h4>
<ol>
<li><strong>套接字地址 (Socket Address)</strong>: IP 地址 : 端口号。这是网络中进程的唯一标识</li>
<li><strong>套接字 API (Socket API)</strong>: 操作系统内核提供给应用程序的<strong>编程接口</strong>
<ul>
<li>在 Linux/Unix 中，Socket 表现为一个<strong>文件描述符 (File Descriptor)</strong></li>
<li>应用程序通过读写这个“文件”来与网络另一端的进程通信，而无需关心底层的 TCP/IP 传输细节<br>
<img src="/Computer-Network/socket.png" alt="socket"></li>
</ul>
</li>
</ol>
<h3 id="基础设施-infrastructure"><a class="markdownIt-Anchor" href="#基础设施-infrastructure"></a> 基础设施 / Infrastructure</h3>
<p><img src="/Computer-Network/L7L4relationship.jpg" alt="L7L4relationship"></p>
<h4 id="dns域名系统-dns"><a class="markdownIt-Anchor" href="#dns域名系统-dns"></a> DNS域名系统 / DNS</h4>
<blockquote>
<p><strong>Why DNS?</strong><br>
网络设备只认识 IP 地址，但人类习惯记忆字符串<br>
DNS 是连接这两者的桥梁</p>
</blockquote>
<p>DNS 是一个<strong>分层的 (Hierarchical)</strong>、<strong>基于域的 (Domain-based)</strong> 命名方案，以及一个实现主机名到 IP 地址转换的<strong>分布式数据库 (Distributed Database)</strong> 系统<br>
三个要点：<em>分布</em>、<em>分层</em>、<em>缓存</em></p>
<ul>
<li><strong>为什么是分布式的？</strong> 全球几十亿台设备，如果只靠一台服务器记账，它会瞬间崩溃（单点故障、流量过载）。所以 DNS 将数据分散在全球各地</li>
</ul>
<h5 id="dns-查询过程-query-process"><a class="markdownIt-Anchor" href="#dns-查询过程-query-process"></a> DNS 查询过程 / Query Process</h5>
<p>当访问 <a href="http://www.example.com">www.example.com</a> 时：</p>
<ol>
<li><strong>浏览器缓存</strong> -&gt; <strong>OS Hosts 文件</strong> -&gt; <strong>本地 DNS 服务器 (Local DNS)</strong></li>
<li>若未命中，Local DNS 发起<strong>迭代查询 (Iterative Query)</strong>:
<ul>
<li>问 <strong>根服务器 (Root)</strong> -&gt; 得到 .com TLD 服务器 IP</li>
<li>问 <strong>TLD 服务器</strong> -&gt; 得到 <a href="http://example.com">example.com</a> 权威服务器 IP</li>
<li>问 <strong>权威服务器 (Authoritative)</strong> -&gt; 得到 <a href="http://www.example.com">www.example.com</a> 的最终 IP</li>
</ul>
</li>
</ol>
<p>DNS 不止存 IP，还存别的东西：</p>
<ul>
<li><strong>A 记录</strong>: 域名 -&gt; IPv4 地址</li>
<li><strong>AAAA 记录</strong>: 域名 -&gt; IPv6 地址</li>
<li><strong>CNAME 记录</strong>: 别名。比如 <a href="http://www.a.com">www.a.com</a> 其实是 <a href="http://b.com">b.com</a> 的小号。（<strong>CDN 的核心实现机制</strong>）</li>
<li><strong>MX 记录</strong>: 邮件交换。告诉邮件服务器邮件该发给谁</li>
<li><strong>NS 记录</strong>: 域名服务器。告诉别人这块地盘归哪台 DNS 服务器管</li>
</ul>
<h5 id="nslookup-dig-dns"><a class="markdownIt-Anchor" href="#nslookup-dig-dns"></a> nslookup &amp; dig DNS</h5>
<p>来自己看看DNS吧!<br>
可以使用<code>nslookup</code>工具来查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nslookup www.bilibili.com</span></span><br><span class="line">Server:         127.0.0.53            &lt;-- 1. 你的本地 DNS 服务器</span><br><span class="line">Address:        127.0.0.53#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:             &lt;-- 2. 非权威应答</span><br><span class="line">www.bilibili.com        canonical name = a.w.bilicdn1.com.</span><br><span class="line">Name:   a.w.bilicdn1.com              &lt;-- 3. 这里验证了 CNAME 机制，B站把请求转给了 CDN</span><br><span class="line">Address: 223.111.252.67               &lt;-- 4. 最终的 A 记录 (IP 地址)</span><br><span class="line">Name:   a.w.bilicdn1.com              这就是DNS的缓存机制</span><br><span class="line">Address: 117.169.96.199               这里出现了多个 IP，验证了 DNS 负载均衡</span><br><span class="line">... #太多了我就省略了</span><br><span class="line">;; Truncated, retrying in TCP mode.</span><br><span class="line">Name:   a.w.bilicdn1.com</span><br><span class="line">Address: 2409:8c38:c40:100::2</span><br><span class="line">Name:   a.w.bilicdn1.com</span><br><span class="line">Address: 2409:8c38:c40:100::3</span><br><span class="line">Name:   a.w.bilicdn1.com</span><br><span class="line">Address: 2409:8c38:c40:100::241</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果想要更完整的内容，可以使用<code>dig</code>工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dig www.bilibili.com</span></span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.bilibili.com.       600     IN      CNAME   a.w.bilicdn1.com.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释: CNAME 记录显示 B 站将域名指向了 CDN 域名 (a.w.bilicdn1.com)</span></span><br><span class="line"></span><br><span class="line">a.w.bilicdn1.com.       600     IN      A       223.111.252.67</span><br><span class="line">a.w.bilicdn1.com.       600     IN      A       117.169.96.199</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释: 这里返回了多个 A 记录 (IP 地址)，这验证了 DNS 负载均衡 (Load Balancing) 机制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端可以随机选择一个 IP 进行连接</span></span><br><span class="line"></span><br><span class="line">;; Query time: 10 msec  &lt;-- 极快的响应时间暗示了命中缓存</span><br></pre></td></tr></table></figure>
<p>Q：为什么这下面不仅仅有一个 IP 地址，而是有好几个？<br>
A：<strong>负载均衡</strong></p>
<blockquote>
<p><strong>What is 负载匀衡?</strong><br>
负载均衡 (Load Balancing)是指在多个计算资源（如计算机集群、网络连接、CPU、磁盘驱动器）之间分配工作负载（Workloads）的技术</p>
<ul>
<li>核心组件：负载均衡器 (Load Balancer)。它是位于客户端与后端服务器组（Backend Server Pool）之间的一个<strong>反向代理 (Reverse Proxy)</strong> 或网络设备。</li>
<li>基本功能：接收来自客户端的入站流量 (Inbound Traffic)，并根据指定的算法将其转发到后端某台特定的服务器 (Upstream Server) 上。</li>
</ul>
<p><s>如果以后开nginx或者caddy的课可能会详细讲讲？</s></p>
</blockquote>
<h4 id="内容分发网络-cdn"><a class="markdownIt-Anchor" href="#内容分发网络-cdn"></a> 内容分发网络 / CDN</h4>
<p>如果你在中国，服务器在美国，物理距离导致的<strong>延迟</strong>就无法通过加宽带解决<br>
所以出现了CDN技术<br>
<img src="/Computer-Network/CND.webp" alt="CND"></p>
<ul>
<li><strong>核心原理</strong>:
<ul>
<li><strong>边缘服务器 (Edge Server)</strong>: 部署在全球各地的节点</li>
<li><strong>重定向机制</strong>: 利用 DNS 的 <strong>CNAME</strong> 记录，将用户对 <a href="http://www.bilibili.com">www.bilibili.com</a> 的解析请求重定向到 CDN 的负载均衡器，进而返回距离用户物理距离最近、负载最低的边缘节点 IP</li>
<li><strong>缓存 (Caching)</strong>: 静态资源（图片、视频、CSS/JS）被缓存在边缘节点。回源（Back-to-Source）仅在缓存未命中时发生</li>
</ul>
</li>
</ul>
<blockquote>
<p>这是现代互联网视频流畅播放、网页秒开的基石</p>
</blockquote>
<h3 id="万维网与-http-web-http"><a class="markdownIt-Anchor" href="#万维网与-http-web-http"></a> 万维网与 HTTP / Web &amp; HTTP</h3>
<h4 id="http-协议-http"><a class="markdownIt-Anchor" href="#http-协议-http"></a> HTTP 协议 / HTTP</h4>
<h5 id="what-is-http"><a class="markdownIt-Anchor" href="#what-is-http"></a> What is HTTP?</h5>
<blockquote>
<p>该部分内容涉及到下一层的知识点，在后面会讲，别着急</p>
</blockquote>
<blockquote>
<p><strong>Definition: HTTP</strong><br>
HTTP 是一个<strong>无状态 (Stateless)</strong> 的应用层协议，定义了客户端（用户代理）与服务器之间交换超文本资源（HTML, 图片等）的格式与语义</p>
</blockquote>
<p>它基于“请求-响应” (Request-Response) 模式<br>
还记得前面讲的“协议=语法+语义”吗？HTTP 的语法非常直观</p>
<blockquote>
<ul>
<li><strong>请求 (Request)</strong>: 动词 路径 协议版本 (例如: GET /index.html HTTP/1.1)</li>
<li><strong>响应 (Response)</strong>: 协议版本 状态码 状态短语 (例如: HTTP/1.1 200 OK 或 404 Not Found)</li>
<li><strong>响应体 (Body)</strong></li>
</ul>
</blockquote>
<p>http有这两个特点:</p>
<ul>
<li>传输层依赖：
<ul>
<li>HTTP 默认使用 TCP 端口 80</li>
<li>可靠性：HTTP 自身不提供数据可靠性机制，完全依赖 TCP 提供的可靠数据传输服务（无丢失、无差错、按序到达）</li>
</ul>
</li>
<li>RTT (Round-Trip Time) 开销：
<ul>
<li>HTTP 通信前必须先建立 TCP 连接。TCP 三次握手引入了初始延迟</li>
<li>在非持久连接（Non-Persistent Connection）模式下，每个对象的传输都需要独立的 TCP 握手，导致显著的时延累积</li>
</ul>
</li>
</ul>
<p>根据 RFC 7231 标准，常见方法定义如下：</p>
<ul>
<li>GET: 请求获取 Request-URI 所标识的资源</li>
<li>POST: 向指定资源提交数据进行处理请求（如提交表单或上传文件）。数据包含在请求体中</li>
<li>PUT: 向服务器发送数据，用以替换目标资源当前的表示</li>
<li>DELETE: 请求服务器删除 Request-URI 所标识的资源</li>
</ul>
<p><img src="Computer-Network/http.png" alt="http"></p>
<p>由于 HTTP 协议的无状态性 (Statelessness)，服务器无法仅凭协议层面的信息识别连续请求是否来自同一客户端<br>
为此，引入了 <strong>Cookie</strong> 机制（RFC 6265）：</p>
<ol>
<li>状态生成：服务器在 HTTP 响应首部中包含 <code>Set-Cookie</code> 字段，向客户端下发状态标识</li>
<li>状态存储：用户代理（User Agent，如浏览器）将 Cookie 保存至本地（内存或磁盘）</li>
<li>状态回传：后续向同一域发送请求时，用户代理会自动在请求首部中包含 <code>Cookie</code> 字段，从而实现会话维持（Session Maintenance）</li>
</ol>
<p><s>在现在的时代，<strong>JWT (JSON Web Token)</strong> 这个词很常见呢</s></p>
<h5 id="take-a-look-at-http-with-telnet"><a class="markdownIt-Anchor" href="#take-a-look-at-http-with-telnet"></a> Take a look at HTTP with telnet</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">telnet www.baidu.com 80</span></span><br><span class="line">Trying 36.152.44.132...</span><br><span class="line">Connected to www.baidu.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;. </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--- [手动输入部分] ---</span></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(此处按两次回车发送请求)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--- [服务器响应部分] ---</span></span><br><span class="line">HTTP/1.1 200 OK                     &lt;-- 状态行</span><br><span class="line">Server: BWS/1.1                     &lt;-- Server Header: 百度自研服务器</span><br><span class="line">Content-Type: text/html             &lt;-- 告诉终端：这是网页代码</span><br><span class="line">Content-Length: 29506               &lt;-- 实体长度</span><br><span class="line">Connection: keep-alive              &lt;-- 关键：持久连接，TCP 未断开</span><br><span class="line">Set-Cookie: BAIDUID=0E91...; expires=Thu, 31-Dec-37...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释: Set-Cookie 头部</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">expires=2037年: 这是一个持久化 Cookie，用于长期的用户追踪</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;... (响应体 HTML 代码)</span><br></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure>
<p>这是我们发送的request：</p>
<ol>
<li>GET /: 请求方法，告诉服务器“根路径 /给我”</li>
<li>HTTP/1.1: 协议版本，指示客户端支持 HTTP/1.1 标准</li>
<li>Host:www.baidu.com : <strong>HTTP/1.1 强制要求的首部</strong>。指定目标服务器的域名</li>
<li>回车两次: 协议中的 <code>\r\n\r\n</code> (CRLF)</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>
<ul>
<li>200 OK: 收到，没问题<br>
这里暴露了服务器的很多“隐私”：</li>
<li>Server: BWS/1.1:
<ul>
<li>通常这里会写 nginx 或 Apache</li>
<li>但这里是 BWS (Baidu Web Server)。百度为了高性能，自己魔改的服务器软件</li>
</ul>
</li>
<li>Date: Sun, 23 Nov 2025 …: 服务器现在时间</li>
<li>Content-Type: text/html: 告诉你的终端接受内容是什么(MIME 类型)</li>
<li>Content-Length: 29506: 预告接下来的网页内容一共有 29,506 个字节</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span> <span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure>
<p>还记得 HTTP/1.1 的持久连接吗？</p>
<ul>
<li>服务器发完数据后并没有断开TCP</li>
<li>如果你现在继续在这个窗口里输入 <code>GET /favicon.ico HTTP/1.1 ...</code>，它会立刻响应，不需要重新握手</li>
<li>这也意味着由于连接没断，你需要手动用 <code>Ctrl+]</code> 然后 <code>quit</code> 才能退出 telnet<br>
这是 HTTP 克服“健忘症”的铁证：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Set-Cookie: <span class="attribute">BAIDUID</span>=...; <span class="attribute">expires</span>=Thu, 31-Dec-37<span class="built_in">..</span>.</span><br><span class="line">Set-Cookie: <span class="attribute">BIDUPSID</span>=...</span><br><span class="line">Set-Cookie: <span class="attribute">PSTM</span>=...</span><br></pre></td></tr></table></figure>
<ul>
<li>百度一口气给你发了好几个身份证（Cookie）。
<ul>
<li>BAIDUID: 这是百度用来追踪你的核心 ID。</li>
<li>expires=Thu, 31-Dec-37
<ul>
<li>除非你手动清空浏览器缓存，否则这十几年里，百度只要看到这个 ID，就知道“哦，还是 2025 年那个用 Telnet 连我的家伙”</li>
<li>这就是为什么广告能精准投放、搜索记录能被保存的原因</li>
</ul>
</li>
</ul>
</li>
<li>X-Xss-Protection: 1;mode=block: 告诉浏览器打开防 XSS 攻击的护盾（虽然现代浏览器大多已经弃用这个头了，但百度为了兼容老浏览器还留着）</li>
<li>Vary: Accept-Encoding<br>
然后后面的就是响应体(Body)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<h4 id="https-协议-https"><a class="markdownIt-Anchor" href="#https-协议-https"></a> HTTPS 协议 / HTTPS</h4>
<blockquote>
<p><strong>Why HTTPS?</strong><br>
HTTP 是<strong>明文</strong>传输的。你在公共场合连 Wi-Fi 登录 HTTP 网站，嘿壳抓包能直接看到你的密码<br>
HTTPS = HTTP + <strong>SSL/TLS</strong></p>
</blockquote>
<p>HTTPS 并非一种全新的协议，而是 <strong>HTTP over SSL/TLS</strong>。它在应用层（HTTP）和传输层（TCP）之间插入了一个安全层——<strong>TLS (Transport Layer Security)</strong> 或其前身 SSL (Secure Sockets Layer)</p>
<p>HTTPS 解决了三个核心安全问题（CIA 模型）：</p>
<ol>
<li><strong>机密性 (Confidentiality)</strong>: 防止窃听 (Eavesdropping)。通过加密算法对数据负载进行编码，确保只有拥有密钥的接收方才能解密</li>
<li><strong>完整性 (Integrity)</strong>: 防止篡改 (Tampering)。通过<strong>消息摘要 (Message Digest)</strong> 算法（如 SHA-256）生成数字指纹，确保数据在传输过程中未被修改</li>
<li><strong>身份认证 (Authentication)</strong>: 防止伪装 (Spoofing)。通过<strong>数字证书 (Digital Certificate)</strong> 和 <strong>PKI (公钥基础设施)</strong> 验证服务器的真实身份</li>
</ol>
<p>TLS 协议混合使用了两种加密方式以平衡安全性与性能：</p>
<ul>
<li><strong>非对称加密 (Asymmetric Encryption)</strong>:
<ul>
<li><strong>原理</strong>: 使用一对密钥（公钥 Public Key 和 私钥 Private Key）。公钥加密的数据只能由私钥解密，反之亦然</li>
<li><strong>用途</strong>: 仅用于 <strong>TLS 握手阶段</strong>，用于安全地交换“会话密钥”</li>
<li><strong>算法</strong>: RSA, ECC (Elliptic Curve Cryptography), Diffie-Hellman</li>
</ul>
</li>
<li><strong>对称加密 (Symmetric Encryption)</strong>:
<ul>
<li><strong>原理</strong>: 通信双方持有相同的密钥，加密和解密使用同一把钥匙</li>
<li><strong>用途</strong>: 用于 <strong>应用数据传输阶段</strong>（握手完成后），因为其计算速度远快于非对称加密</li>
<li><strong>算法</strong>: AES-GCM, ChaCha20-Poly1305</li>
</ul>
</li>
</ul>
<p><strong>CA (Certificate Authority)</strong> 是信任的锚点</p>
<ul>
<li><strong>信任链验证</strong>: 浏览器利用内置的 <strong>Root CA</strong> 公钥，逐级验证服务器证书的签名</li>
</ul>
<h5 id="openssl证书链观测"><a class="markdownIt-Anchor" href="#openssl证书链观测"></a> openssl证书链观测</h5>
<p>我们可以使用openssl来看看证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl s_client -connect www.bilibili.com:443 -showcerts</span></span><br><span class="line">Connecting to 223.111.252.67...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Part 1: 证书链验证过程]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenSSL 从服务器收到了证书链，并尝试逐级验证</span></span><br><span class="line">depth=2 OU=GlobalSign Root CA - R3, O=GlobalSign, CN=GlobalSign</span><br><span class="line">verify return:1  # depth=2: 根证书 (Root CA)</span><br><span class="line"></span><br><span class="line">depth=1 C=BE, O=GlobalSign nv-sa, CN=GlobalSign RSA OV SSL CA 2018</span><br><span class="line">verify return:1  # depth=1: 中间证书 (Intermediate CA)</span><br><span class="line"></span><br><span class="line">depth=0 C=CN, ST=上海, L=上海, O=上海幻电信息科技有限公司, CN=*.bilibili.com</span><br><span class="line">verify return:1  # depth=0: 服务器证书 (Leaf Certificate)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Part 2: 证书链详情]</span></span><br><span class="line">Certificate chain</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">0号证书：服务器实体证书</span></span><br><span class="line"> 0 s:C=CN, ST=上海, L=上海, O=上海幻电信息科技有限公司, CN=*.bilibili.com  # s (Subject): 证书持有者</span><br><span class="line">   i:C=BE, O=GlobalSign nv-sa, CN=GlobalSign RSA OV SSL CA 2018  # i (Issuer): 颁发者</span><br><span class="line">   a:PKEY: RSA, 2048 (bit); sigalg: sha256WithRSAEncryption # 签名算法</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">1号证书：中间 CA 证书</span></span><br><span class="line"> 1 s:C=BE, O=GlobalSign nv-sa, CN=GlobalSign RSA OV SSL CA 2018 # Subject</span><br><span class="line">   i:OU=GlobalSign Root CA - R3, O=GlobalSign, CN=GlobalSign # Issuer (指向 Root)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">2号证书：根 CA 证书 (通常由 OS 内置，服务器可发可不发)</span></span><br><span class="line"> 2 s:OU=GlobalSign Root CA - R3, O=GlobalSign, CN=GlobalSign</span><br><span class="line">   i:C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA # Issuer (通常是自签名)</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Part 3: 握手结果]</span></span><br><span class="line">SSL handshake has read 4424 bytes and written 1642 bytes</span><br><span class="line">Verification: OK # 核心结果：信任链验证通过</span><br><span class="line">---</span><br><span class="line">New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384  # 协议版本 TLS 1.3，使用 AES-256-GCM 对称加密</span><br><span class="line">Protocol: TLSv1.3</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="http-演进-http-evolution"><a class="markdownIt-Anchor" href="#http-演进-http-evolution"></a> HTTP 演进 / HTTP Evolution</h4>
<h5 id="http11"><a class="markdownIt-Anchor" href="#http11"></a> HTTP/1.1</h5>
<ul>
<li><strong>机制</strong>: 文本协议，支持持久连接</li>
<li><strong>缺陷</strong>: <strong>应用层队头阻塞 (HOL Blocking)</strong>。请求必须串行排队，前一个请求未完成，后续请求只能等待<br>
<img src="/Computer-Network/HOL.png" alt="HOL"></li>
</ul>
<h5 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP/2</h5>
<p>因此进化出了HTTP/2：<br>
HTTP/2 依然基于 TCP，但对其传输机制进行了重构，旨在解决应用层 HOL 阻塞</p>
<ul>
<li><strong>机制</strong>: <strong>二进制分帧</strong> + <strong>多路复用</strong></li>
<li><strong>改进</strong>:
<ul>
<li><strong>流 (Stream)</strong>: 允许在同一个 TCP 连接中并发传输多个请求/响应</li>
<li><strong>HPACK</strong>: 头部压缩，节省带宽</li>
<li><strong>Server Push</strong>: 服务端主动推送资源</li>
</ul>
</li>
</ul>
<p>现在绝大部分地方都停留在了HTTP/2<br>
就用b站为例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -v -I https://www.bilibili.com</span></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Step 1: ALPN 协商 (Application-Layer Protocol Negotiation)]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 TLS 握手的同时，客户端告知服务器：“我支持 HTTP/2 (h2) 和 HTTP/1.1”</span></span><br><span class="line">* ALPN: curl offers h2,http/1.1</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">...</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器在 TLS 握手结束时确认：“好的，我们使用 h2 (HTTP/2)”</span></span><br><span class="line">* ALPN: server accepted h2</span><br><span class="line">* Server certificate:</span><br><span class="line">...</span><br><span class="line">* Connected to www.bilibili.com (2409:8c20:5624::55) port 443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Step 2: HTTP/2 流与伪首部]</span></span><br><span class="line">* using HTTP/2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 1 号流 (Stream ID 1) 用于传输请求</span></span><br><span class="line">* [HTTP/2] [1] OPENED stream for https://www.bilibili.com/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送 HEADERS 帧。注意：HTTP/2 使用“伪首部字段” (Pseudo-Header Fields，以冒号开头)</span></span><br><span class="line">* [HTTP/2] [1] [:method: HEAD]        # 对应 HTTP/1.1 的 GET/HEAD 方法</span><br><span class="line">* [HTTP/2] [1] [:scheme: https]       # 协议</span><br><span class="line">* [HTTP/2] [1] [:authority: www.bilibili.com] # 对应 HTTP/1.1 的 Host 头部</span><br><span class="line">* [HTTP/2] [1] [:path: /]             # 路径</span><br><span class="line">* [HTTP/2] [1] [user-agent: curl/8.15.0]</span><br><span class="line">* [HTTP/2] [1] [accept: */*]</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HEAD / HTTP/2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: www.bilibili.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/8.15.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* Request completely sent off</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[Step 3: 接收响应]</span></span><br><span class="line">&lt; HTTP/2 200</span><br><span class="line">&lt; date: Sun, 23 Nov 2025 08:29:57 GMT</span><br><span class="line">&lt; content-type: text/html; charset=utf-8</span><br><span class="line">...</span><br><span class="line">* Connection #0 to host www.bilibili.com left intact</span><br></pre></td></tr></table></figure>
<h5 id="http3"><a class="markdownIt-Anchor" href="#http3"></a> HTTP/3</h5>
<p>HTTP/2 解决了应用层的阻塞，但无法解决 <strong>TCP 层面的队头阻塞 (Transport-Layer HOL Blocking)</strong></p>
<ul>
<li><strong>TCP 的局限</strong>: TCP 是字节流协议，要求数据按序到达。如果 TCP 窗口中的一个包丢失，操作系统内核会挂起整个 TCP 连接，等待重传，导致所有流（Stream）都被阻塞</li>
</ul>
<p>HTTP/3 弃用 TCP，改用基于 UDP 的 <strong>QUIC 协议 (Quick UDP Internet Connections)</strong></p>
<ul>
<li><strong>基于 UDP</strong>: UDP 无连接、不可靠，但 QUIC 在应用层实现了可靠传输机制（重传、拥塞控制）</li>
<li><strong>流的独立性 (Stream Independence)</strong>:
<ul>
<li>QUIC 中的流是真正的独立。如果流 A 的一个 UDP 包丢失，只会影响流 A，流 B 和 流 C 继续传输，不受影响</li>
</ul>
</li>
<li><strong>连接迁移 (Connection Migration)</strong>:
<ul>
<li>TCP 依赖四元组（源IP, 源端口, 目的IP, 目的端口）标识连接。网络切换（Wi-Fi -&gt; 4G）会导致 IP 改变，连接断开</li>
<li>QUIC 使用 <strong>Connection ID (CID)</strong> 标识连接。只要 CID 不变，即使 IP 变了，连接依然保持，无需重新握手</li>
</ul>
</li>
<li><strong>0-RTT 握手</strong>: 结合 TLS 1.3，允许在恢复会话时直接发送数据</li>
</ul>
<blockquote>
<p>QUIC 是在 <strong>用户态 (User Space)</strong> 实现的可靠传输，而不是内核态，这是它迭代快的原因</p>
</blockquote>
<h3 id="实时通信-real-time-communication"><a class="markdownIt-Anchor" href="#实时通信-real-time-communication"></a> 实时通信 / Real-Time Communication</h3>
<p>在上一节我们看到，HTTP 的本质是“请求-响应”模式。这种模式有一个致命的缺陷：<strong>被动性</strong><br>
服务器就像一个仅仅会应答的机器，客户端不问，它就永远不能说话</p>
<p>这对于浏览网页没问题，但对于<strong>即时通讯 (IM)</strong>、<strong>股票行情</strong>或<strong>多人在线游戏</strong>来说，是无法接受的。为了让服务器能“主动”发消息，最早的开发者只能使用<strong>轮询 (Polling)</strong>，即让浏览器每隔几秒就发一个 HTTP 请求问：“有新消息吗？”。这不仅制造了大量无效的 HTTP 请求，还带来了无法消除的延迟</p>
<p>我们需要一种真正的双向通信机制</p>
<h4 id="websocket-协议-websocket"><a class="markdownIt-Anchor" href="#websocket-协议-websocket"></a> WebSocket 协议 / WebSocket</h4>
<p>WebSocket 的出现解决了这个问题。它允许在单个 TCP 连接上进行<strong>全双工 (Full-Duplex)</strong> 通信——即双方都可以同时向对方发送数据，不需要谁先问谁</p>
<p>有趣的是，WebSocket 并不是另起炉灶，它是<strong>寄生</strong>在 HTTP 之上的。建立一个 WebSocket 连接，必须经历一次“协议升级”的过程</p>
<p>我们可以抓包或使用 <code>curl</code> 模拟这个过程，你会发现它始于 HTTP，终于二进制流：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl --http1.1 -i -N \</span><br><span class="line">    -H <span class="string">&quot;Connection: Upgrade&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Upgrade: websocket&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Sec-WebSocket-Version: 13&quot;</span> \</span><br><span class="line">    https://echo.websocket.org</span><br></pre></td></tr></table></figure>
<p>服务器会返回 <code>HTTP/1.1 101 Switching Protocols</code><br>
它标志着 TCP 连接的<strong>所有权</strong>发生了转移，建立了一条原始的 TCP 管道，直接传输 WebSocket 的<strong>二进制帧 (Frame)</strong><br>
<img src="/Computer-Network/websocket.png" alt="websocket"></p>
<h4 id="webtransport-协议-webtransport"><a class="markdownIt-Anchor" href="#webtransport-协议-webtransport"></a> WebTransport 协议 / WebTransport</h4>
<p>WebSocket 虽然解决了双向通信，但它依然基于 <strong>TCP</strong></p>
<p><strong>WebTransport</strong> 是基于 <strong>HTTP/3 (QUIC)</strong> 构建的新一代 API。由于底层换成了基于 UDP 的 QUIC，它能够提供一种名为 <strong>Datagrams (数据报)</strong> 的传输模式。在这种模式下，数据包是可以丢弃、可以乱序的。对于实时性要求极高的场景，丢几帧画面远比卡顿几秒要好得多</p>
<h3 id="远程管理-remote-management"><a class="markdownIt-Anchor" href="#远程管理-remote-management"></a> 远程管理 / Remote Management</h3>
<p>如何管理远程服务器？也许你可以看看ssh</p>
<h4 id="ssh-协议-ssh"><a class="markdownIt-Anchor" href="#ssh-协议-ssh"></a> SSH 协议 / SSH</h4>
<p>早期的 <strong>Telnet</strong> (TCP 23) 协议极其简陋，它在网络上仅仅是建立了一个虚拟终端。最可怕的是，它默认<strong>明文传输</strong><br>
当你通过 Telnet 登录服务器时，你输入的每一个字符（包括 root 密码）都会以明文形式流经所有的路由器。任何中间人（MITM）都能截获你的权限</p>
<p><strong>SSH (Secure Shell, TCP 22)</strong> 的出现终结了 Telnet<br>
SSH 不仅仅是一个远程 Shell，它本质上是一个<strong>加密的隧道协议</strong>。它在 TCP 连接建立后，会立即进行密钥交换（Key Exchange），在不安全的网络中协商出一个对称密钥。此后传输的所有数据，都是经过高强度加密的乱码</p>
<h4 id="网络监控-network-monitoring"><a class="markdownIt-Anchor" href="#网络监控-network-monitoring"></a> 网络监控 / Network Monitoring</h4>
<p>除了控制，我们还需要监控<br>
传统的监控协议 <strong>SNMP</strong> 采用的是 <strong>“拉模式 (Pull)”</strong>：管理端每隔几秒钟问一次路由器：“现在的 CPU 占用率是多少？”<br>
这种方式不仅效率低下，而且存在<strong>盲区</strong>——如果流量在两次轮询的间隙瞬间暴涨又消失（微突发），SNMP 是完全无感知的</p>
<p>随着 Linux 内核的发展，<strong>eBPF</strong> 技术正在颠覆这一领域<br>
不同于 SNMP 的外部询问，eBPF 允许我们在操作系统内核中植入安全的、<strong>事件驱动</strong>的“探针”。每当有一个数据包经过网卡，或者发生一次系统调用，eBPF 程序就会被触发。这种从<strong>内核视角</strong>进行的毫秒级实时观测，让网络监控从“看大概”进化到了“看显微镜”</p>
<h3 id="文件传输-file-transfer"><a class="markdownIt-Anchor" href="#文件传输-file-transfer"></a> 文件传输 / File Transfer</h3>
<h4 id="ftp-与-sftp-ftp-sftp"><a class="markdownIt-Anchor" href="#ftp-与-sftp-ftp-sftp"></a> FTP 与 SFTP / FTP &amp; SFTP</h4>
<p>搬运文件看似简单，但在复杂的现代网络环境中，古老的协议却显得格格不入。这其中最典型的反面教材就是 <strong>FTP</strong></p>
<p>FTP 是互联网早期的产物，它设计了独特的<strong>双端口机制</strong>：一个端口（TCP 21）用于发送指令，另一个端口（TCP 20）用于传输数据</p>
<p>这种设计在当年没有问题，但在 <strong>NAT (网络地址转换)</strong> 普及的今天，它简直是灾难。在 FTP 的<strong>主动模式</strong>下，客户端需要告诉服务器：“请连接我的内网 IP:端口 给我发数据”。但在公网上的服务器根本无法反向连接进你的内网。虽然 FTP 后来推出了“被动模式”试图补救，但由于它需要服务器开放海量随机端口，这又成了防火墙的噩梦</p>
<p>因此，FTP 已基本被淘汰，取而代之的是 <strong>SFTP</strong><br>
SFTP 并不是 FTP 的加密版，它是 <strong>SSH 协议的一个子系统</strong>，直接复用 SSH 的 22 端口。不需要额外配置防火墙，且天然具备高安全性</p>
<h3 id="你先别急-you-no-hurry"><a class="markdownIt-Anchor" href="#你先别急-you-no-hurry"></a> 你先别急 / You No Hurry</h3>
<p>在继续深入之前，我们需要解决一个核心疑问：<strong>应用层是如何工作的？</strong><br>
我们在写 HTTP 或 SSH 程序时，似乎只需要调用一个 <code>send()</code> 函数，数据就神奇地到达了地球另一端。我们并不关心网线断没断、路由器堵不堵</p>
<p>这是因为<strong>传输层 (Transport Layer)</strong> 向应用层提供了一个 <strong>“黑盒服务模型”</strong></p>
<ul>
<li><strong>应用层的视角</strong>：我把数据扔进这个黑盒，告诉它“送到 IP:Port”</li>
<li><strong>黑盒的承诺</strong>：我会搞定所有的传输细节</li>
</ul>
<p>但是，这个黑盒提供了两种截然不同的<strong>服务套餐</strong>：一种是“快但不保修”（UDP），一种是“慢但包邮包退”（TCP）。接下来，我们就拆开这个黑盒，看看里面的齿轮是如何转动的</p>
<h2 id="传输层-transport-layer"><a class="markdownIt-Anchor" href="#传输层-transport-layer"></a> 传输层 / Transport Layer</h2>
<blockquote>
<p><strong>Concept: 核心使命：从主机到进程</strong><br>
网络层 (IP) 只能把数据送到<strong>主机</strong>。传输层负责把数据分发给主机上具体的<strong>进程</strong><br>
这种复用与分用，依靠的是 <strong>端口号 (Port Number)</strong></p>
</blockquote>
<p>在这一层，主要有两个性格迥异的协议：<strong>UDP</strong> 和 <strong>TCP</strong>。它们代表了网络设计中两种截然不同的哲学</p>
<h3 id="udp-协议-udp"><a class="markdownIt-Anchor" href="#udp-协议-udp"></a> UDP 协议 / UDP</h3>
<p><strong>UDP</strong> 是黑盒提供的第一种套餐。它的哲学是：<strong>“尽最大努力交付” (Best Effort)</strong></p>
<p>我们来看看一个真实的 UDP 数据包。你会发现它的结构<strong>十分干净</strong>，没有复杂的握手序列，头部只有区区 <strong>8 个字节</strong>。<br>
这是<a href="https://wiki.wireshark.org/SampleCaptures">SampleCaptures - Wireshark Wiki</a>上下载下来的一个<a href="https://wiki.wireshark.org/uploads/e2b98423e5f0dc85e0b1228ebbd044e2/protobuf_udp_addressbook.pcapng">Fetching Title#3h26</a><br>
我们可以用<code>wireshark</code>这个软件打开它看看，安装自己去弄<a href="https://www.wireshark.org/download.html">Wireshark • Go Deep | Download</a><br>
<img src="/Computer-Network/UDPpackage.png" alt="UDPpackage"></p>
<p>你会发现它的头部极其干净，只有区区 <strong>8 个字节</strong>：</p>
<ul>
<li><strong>源端口</strong> &amp; <strong>目的端口</strong>: 负责送给正确的进程</li>
<li><strong>长度</strong>: 告诉接收方这包有多长</li>
<li><strong>校验和 (Checksum)</strong>: 这是 UDP 唯一的底线</li>
</ul>
<p><strong>为什么校验和如此重要？</strong><br>
这是 UDP 唯一的可靠性措施。如果数据包在传输中出现了比特翻转，UDP会直接<strong>丢弃</strong>这个包，并且<strong>不会</strong>通知发送方<br>
<strong>在 IPv4 中，UDP 校验和是可选的（虽然通常都开），但在 IPv6 中是强制的</strong></p>
<blockquote>
<p>“既然这么不靠谱，为什么还要用它？”</p>
</blockquote>
<p>在<strong>实时性</strong>要求极高的场景，<strong>延迟</strong>是最大的敌人。如果使用 TCP，一旦丢包就会暂停画面等待重传，导致卡顿。而UDP允许偶尔丢包，保证了整体流程的顺畅</p>
<h3 id="tcp-协议-tcp"><a class="markdownIt-Anchor" href="#tcp-协议-tcp"></a> TCP 协议 / TCP</h3>
<p><strong>TCP</strong> 是互联网的基石。它的任务极其艰巨：<strong>在不可靠的 IP 层之上，构建一个可靠的传输通道</strong>。为了实现“无差错、不丢失、不乱序”的承诺，TCP 被设计成了一个极其复杂的<strong>有限状态机 (FSM)</strong><br>
<img src="/Computer-Network/TCP.jpg" alt="TCP"></p>
<h4 id="三次握手-three-way-handshake"><a class="markdownIt-Anchor" href="#三次握手-three-way-handshake"></a> 三次握手 / Three-Way Handshake</h4>
<p>TCP 是面向连接的，通信前必须先“打通电话”。这不仅仅是打个招呼，更是为了<strong>同步双方的初始序列号 (ISN)</strong></p>
<ul>
<li>TCP 是双工的，A 要告诉 B 它的 ISN，B 也要告诉 A 它的 ISN，且都需要确认</li>
<li>SYN(A) -&gt; SYN(B) + ACK(A) -&gt; ACK(B)<br>
<img src="/Computer-Network/TCPconnect.png" alt="TCPconnect"><br>
<strong>为什么要三次？</strong><br>
这主要是为了防止<strong>已失效的连接请求</strong>突然又传到了服务端，导致服务端错误地建立连接，浪费资源</li>
</ul>
<h4 id="可靠性与流量控制-reliability-flow-control"><a class="markdownIt-Anchor" href="#可靠性与流量控制-reliability-flow-control"></a> 可靠性与流量控制 / Reliability &amp; Flow Control</h4>
<p>TCP 并没有采用“发一个包，等一个确认”的低效模式，而是采用了<strong>流水线</strong>机制<br>
<strong>滑动窗口 (Sliding Window)</strong> 是 TCP 效率的关键。接收方在回复 ACK 时，会带上一个 <code>Window</code> 字段，告诉发送方：“我的接收缓冲区还能存 4096 字节，你别发太快”。发送方会根据这个反馈，动态调整自己的发送量。这被称为<strong>流量控制 (Flow Control)</strong></p>
<h4 id="四次挥手-four-way-wave"><a class="markdownIt-Anchor" href="#四次挥手-four-way-wave"></a> 四次挥手 / Four-Way Wave</h4>
<p>当数据传输结束，断开连接的过程也充满了设计的智慧<br>
注意，TCP 是<strong>全双工</strong>的（双向独立通道），所以关闭时需要两个方向分别关闭<br>
<img src="/Computer-Network/TCPclose.png" alt="TCPclose"></p>
<ol>
<li>客户端发 <code>FIN</code>：“我没数据发了。”</li>
<li>服务器回 <code>ACK</code>：“知道了。”（此时连接处于<strong>半关闭</strong>状态，服务器可能还有数据没传完）</li>
<li>服务器传完后发 <code>FIN</code>：“我也没数据了。”</li>
<li>客户端回 <code>ACK</code>：“再见。”</li>
</ol>
<p><strong>TIME_WAIT 的深意</strong><br>
在客户端发出最后一个 ACK 后，它并不会立即关闭，而是会进入一个叫 <code>TIME_WAIT</code> 的状态，等待 <strong>2MSL</strong> (Maximum Segment Lifetime,约 2 分钟)。这是为了防备最后一个 ACK 丢包。如果服务器没收到最后的 ACK，会重发 FIN，客户端必须“活着”才能补发 ACK</p>
<h4 id="拥塞控制-congestion-control"><a class="markdownIt-Anchor" href="#拥塞控制-congestion-control"></a> 拥塞控制 / Congestion Control</h4>
<p>如果接收方处理得很快，但<strong>网络中间的路由器</strong>堵车了怎么办？流量控制对此无能为力<br>
TCP 必须具备感知网络拥堵的能力。它维护着一个<strong>拥塞窗口 (cwnd)</strong>：</p>
<ol>
<li><strong>慢启动</strong>: 连接刚建立时，发送速度指数级增长，试探网络负载</li>
<li><strong>拥塞避免</strong>: 达到阈值后，线性增长</li>
<li><strong>急刹车</strong>: 一旦检测到丢包，立即大幅削减窗口，给网络“让路”</li>
</ol>
<p>这边就不详细展开了，内容太多了</p>
<h5 id="take-a-look-at-tcp"><a class="markdownIt-Anchor" href="#take-a-look-at-tcp"></a> Take a look at TCP</h5>
<p>我们可以看看这样一个完整的tcp流程<br>
<img src="/Computer-Network/protobufTCP.png" alt="protobufTCP"></p>
<h2 id="网络层-network-layer"><a class="markdownIt-Anchor" href="#网络层-network-layer"></a> 网络层 / Network Layer</h2>
<p>网络层位于协议栈的核心位置，其主要职责是实现<strong>主机到主机 (Host-to-Host)</strong> 的逻辑通信。与数据链路层关注相邻节点间的帧传输不同，网络层必须解决如何在复杂的、由异构网络互连的互联网中，找到从源主机到目的主机的最佳路径</p>
<p><img src="/Computer-Network/Lan.png" alt="Lan"></p>
<h3 id="ip-服务模型-ip-service-model"><a class="markdownIt-Anchor" href="#ip-服务模型-ip-service-model"></a> IP 服务模型 / IP Service Model</h3>
<p>网际协议 (IP) 提供的是一种<strong>不可靠 (Unreliable)</strong>、<strong>无连接 (Connectionless)</strong> 的<strong>尽最大努力交付 (Best Effort)</strong> 服务。这种设计意味着 IP 路由器在转发分组时，不维护关于后续分组的状态信息，也不保证分组不丢失、不重复或按序到达。这种看似“不负责任”的设计简化了网络核心设备的复杂性，降低了造价，并将数据传输的可靠性控制交由网络边缘的主机（即上层的传输层，如 TCP）来处理</p>
<h4 id="ipv4-数据报-ipv4-datagram"><a class="markdownIt-Anchor" href="#ipv4-数据报-ipv4-datagram"></a> IPv4 数据报 / IPv4 Datagram</h4>
<p>IPv4 数据报由<strong>首部</strong>和<strong>数据部分</strong>组成。首部的前 20 字节是固定的，包含了网络传输所需的最关键控制信息。深入理解这些字段是掌握网络层机制的基础<br>
<img src="/Computer-Network/ipv4header.png" alt="ipv4header"></p>
<p><strong>基础控制字段</strong><br>
首部的开始部分包含版本号与长度信息。<strong>版本 (Version)</strong> 字段占 4 位，对于 IPv4 来说该值为 4<br>
紧接着是 <strong>首部长度 (IHL)</strong>，它以 4 字节为单位记录首部的总长度。由于 IP 首部可能包含可变长度的“选项”字段，因此需要该字段来确定数据部分的起始位置<br>
<strong>区分服务 (Type of Service)</strong> 字段用于标记数据报的优先级，以支持 QoS（服务质量）<br>
<strong>总长度 (Total Length)</strong> 字段占 16 位，指明了首部加上数据部分的总字节数，这意味着 IP 数据报的最大理论长度为 65,535 字节</p>
<p><strong>分片与重组字段</strong><br>
由于底层物理网络存在<strong>最大传输单元 (MTU)</strong> 的限制（如以太网 MTU 为 1500 字节），过大的数据报必须被切分<br>
<strong>标识 (Identification)</strong> 字段是一个计数器，用于标记属于同一个原始数据报的所有分片。<strong>标志 (Flags)</strong> 字段占 3 位，其中最低位 MF (More Fragments) 为 1 表示后面还有分片，中间位 DF (Don’t Fragment) 为 1 表示禁止分片。<strong>片偏移 (Fragment Offset)</strong> 指出该分片在原数据报中的相对位置，以 <strong>8 字节</strong>为单位。路由器利用这些字段进行分片，而目的主机利用它们完成重组<br>
<img src="/Computer-Network/ipfragmentation.jpg" alt="ipfragmentation"></p>
<p><strong>生命周期与协议分用</strong><br>
<strong>生存时间 (TTL)</strong> 字段至关重要，它代表数据报在网络中允许经过的最大跳数。每经过一个路由器，TTL 减 1，减为 0 时数据报被丢弃，从而防止路由环路。<strong>协议 (Protocol)</strong> 字段指示 IP 数据报的数据部分封装了何种上层协议（如 TCP=6, UDP=17, ICMP=1）。该字段实现了网络层的<strong>分用</strong>功能，告诉接收端应将数据上交给哪个模块</p>
<p><strong>校验与寻址</strong><br>
<strong>首部校验和 (Header Checksum)</strong> 仅检测首部是否出错，不检测数据部分。每经过一个路由器，由于 TTL 发生变化，校验和都需要重新计算。最后是 <strong>源地址</strong> 和 <strong>目的地址</strong>，各占 32 位，这是 IP 协议实现逻辑寻址的核心</p>
<h4 id="子网与-cidr-subnetting-cidr"><a class="markdownIt-Anchor" href="#子网与-cidr-subnetting-cidr"></a> 子网与 CIDR / Subnetting &amp; CIDR</h4>
<h5 id="分类编址-classful-addressing"><a class="markdownIt-Anchor" href="#分类编址-classful-addressing"></a> 分类编址 (Classful Addressing)</h5>
<p>在 ARPANET 的早期，IP 地址的设计非常简单粗暴——给每一个物理网络分配一个网络号。我们将 IP 分为 A、B、C、D、E 五类</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:left">前导位</th>
<th style="text-align:left">网络号范围 (第一字节)</th>
<th style="text-align:left">默认掩码</th>
<th style="text-align:left">网络数量</th>
<th style="text-align:left">单个网络最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A 类</strong></td>
<td style="text-align:left"><code>0</code></td>
<td style="text-align:left">1 - 126</td>
<td style="text-align:left">/8</td>
<td style="text-align:left">126 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^7-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>)</td>
<td style="text-align:left">16,777,214 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{24}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>)</td>
</tr>
<tr>
<td style="text-align:center"><strong>B 类</strong></td>
<td style="text-align:left"><code>10</code></td>
<td style="text-align:left">128 - 191</td>
<td style="text-align:left">/16</td>
<td style="text-align:left">16,384</td>
<td style="text-align:left">65,534</td>
</tr>
<tr>
<td style="text-align:center"><strong>C 类</strong></td>
<td style="text-align:left"><code>110</code></td>
<td style="text-align:left">192 - 223</td>
<td style="text-align:left">/24</td>
<td style="text-align:left">2,097,152</td>
<td style="text-align:left">254</td>
</tr>
<tr>
<td style="text-align:center"><img src="/Computer-Network/subnet.png" alt="subnet"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li><strong>127.x.x.x</strong> 也是 A 类，但它被保留作为<strong>环回地址 (Loopback)</strong></li>
<li><strong>D 类 (224-239)</strong> 用于组播 (Multicast)，<strong>E 类</strong> 保留科研</li>
</ol>
</blockquote>
<p>这种设计存在严重问题：</p>
<ul>
<li><strong>地址浪费</strong>：如果一个公司有 300 台主机，C 类（254个）不够用，分一个 B 类（6万多个）又太浪费</li>
<li><strong>路由表膨胀</strong>：每个网络都要占一行路由表，路由器压力山大</li>
</ul>
<h5 id="划分子网-subnetting"><a class="markdownIt-Anchor" href="#划分子网-subnetting"></a> 划分子网 (Subnetting)</h5>
<p>为了解决利用率低的问题，聪明的人们引入了<strong>子网</strong>的概念<br>
<strong>核心思想</strong>：从<strong>主机号</strong>借用几位作为<strong>子网号</strong></p>
<blockquote>
<p><strong>子网掩码 (Subnet Mask)</strong>：用于指示 IP 地址中哪些位是网络位，哪些位是主机位<br>
这里的逻辑运算是：<code>网络地址 = IP 地址 AND 子网掩码</code></p>
</blockquote>
<p><img src="/Computer-Network/subnet_mask.png" alt="subnet_mask"></p>
<h5 id="cidr"><a class="markdownIt-Anchor" href="#cidr"></a> CIDR</h5>
<p>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，但网络地址长度更加灵活可变，因而可以更加有效地分配 IPv4 的地址空间<br>
CIDR使用各种长度的“<strong>网络前缀”(network-prefix)</strong> 来代替分类地址中的网络号和子网号<br>
无分类的两级编址的记法是：</p>
<blockquote>
<p>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</p>
</blockquote>
<p>CIDR 还使用“斜线记法”：<br>
即在IP地址后面加上一个斜线“/”，后面写上网络前缀所占的比特数，如20.5.0.0/10，还可简写为20.5/10<br>
CIDR 将网络前缀相同的连续的 IP 地址组成“CIDR地址块”</p>
<p>在<strong>计算机基础知识竞赛</strong>里面有这样一个题目：</p>
<blockquote>
<p>需要将192.168.1.0/24 网络划分成4个大小相同的子网，每个子网需要容纳相同数量的主机</p>
<ul>
<li>则每个子网的子网掩码是：</li>
<li>每个子网可用的主机数量是：</li>
</ul>
</blockquote>
<p><em>IP地址</em>为<em>192.168.1.0</em>,也就是<em>1100’0000.1010’1000.0000’0001.0000’0000</em><br>
<em>CIDR</em>是<code>/24</code>，也就是<em>1111’1111.1111’1111.1111’1111.0000’0000</em><br>
如果你想要划分不同的子网，那么前 24 位是不动的，最后面的 <strong>8位</strong> (0000’0000) 本来全是留给主机的<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^n = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span><br>
So <code>n = 2</code><br>
也就是我们需要 <strong>2位</strong> 来表示这 4 个子网（00, 01, 10, 11所以，我们要从原本属于主机的 8 位里，<strong>“抢”</strong> 走最左边的 2 位给网络<br>
<em>1111’1111.1111’1111.1111’1111.1100’0000</em><br>
也就是<code>/26</code>，255.255.255.192</p>
<p>借走 2 位后，主机位还剩：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>−</mo><mn>2</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">8 - 2 = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 位</p>
<ul>
<li>总 IP 数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">2^6 = 64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span>。</li>
<li><strong>可用 IP 数</strong>：我们要减去 <strong>网络地址</strong> (全0) 和 <strong>广播地址</strong> (全1)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>−</mo><mn>2</mn><mo>=</mo><mn>62</mn></mrow><annotation encoding="application/x-tex">64 - 2 = 62</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">2</span></span></span></span></li>
</ul>
<table>
<thead>
<tr>
<th>子网索引</th>
<th>二进制借位 (SS)</th>
<th>剩下的主机范围 (HHHHHH)</th>
<th>对应十进制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>子网 1</strong></td>
<td><strong>00</strong></td>
<td>000000 ~ 111111</td>
<td>.0 ~ .63</td>
</tr>
<tr>
<td><strong>子网 2</strong></td>
<td><strong>01</strong></td>
<td>000000 ~ 111111</td>
<td>.64 ~ .127</td>
</tr>
<tr>
<td><strong>子网 3</strong></td>
<td><strong>10</strong></td>
<td>000000 ~ 111111</td>
<td>.128 ~ .191</td>
</tr>
<tr>
<td><strong>子网 4</strong></td>
<td><strong>11</strong></td>
<td>000000 ~ 111111</td>
<td>.192 ~ .255</td>
</tr>
</tbody>
</table>
<p>在路由查找过程中，如果一个目的地址匹配了路由表中的多个表项，路由器将遵循<strong>最长前缀匹配 (Longest Prefix Match)</strong> 原则，选择网络前缀最长（即子网掩码最长）的那一项进行转发，因为该路由指向的网络更具体、更精准</p>
<h4 id="ipv6-协议-ipv6"><a class="markdownIt-Anchor" href="#ipv6-协议-ipv6"></a> IPv6 协议 / IPv6</h4>
<p>IPv6 并非仅仅是扩展了地址空间，它对报文首部进行了彻底的重新设计，以适应现代高速网络的需求</p>
<p><img src="/Computer-Network/ipv6.png" alt="ipv6"><br>
<strong>地址空间的飞跃</strong><br>
IPv6 最显著的变化是将地址长度从 32 位扩展到了 <strong>128 位</strong>，从根本上解决了地址耗尽问题。这使得我们可以为地球上的每一粒沙子分配一个 IP 地址</p>
<p><strong>简化的基本首部</strong><br>
IPv6 采用了固定的 <strong>40 字节</strong>基本首部，去除了 IPv4 中许多不常用的字段以提高处理效率</p>
<ol>
<li><strong>取消了首部长度字段</strong>：因为首部长度固定为 40 字节。</li>
<li><strong>取消了首部校验和字段</strong>：现代链路层（如以太网、光纤）已具备很强的差错检测能力，传输层也有校验机制。去除该字段消除了路由器每跳重新计算校验和的开销，显著提升了转发速度</li>
<li><strong>取消了分片字段</strong>：IPv6 规定<strong>分片仅在源主机进行</strong>。如果路由器收到大于 MTU 的包，直接丢弃并回送 ICMPv6“分组过大”报文。这减轻了中间路由器的负担<br>
<img src="/Computer-Network/basic-IPv6-address.gif" alt="basic-IPv6-address"><br>
<strong>灵活的扩展机制</strong><br>
IPv4 中的“协议”字段在 IPv6 中被<strong>下一个首部 (Next Header)</strong> 字段取代<br>
它不仅可以指向 TCP 或 UDP，还可以指向各种<strong>扩展首部</strong>（如逐跳选项、路由选择、分片扩展等）<br>
这种链式结构使得 IPv6 具有极强的扩展性，能够灵活支持未来的新功能<br>
其他关键字段还包括<strong>流标号 (Flow Label)</strong>，用于支持实时音视频等需要特殊服务质量的数据流</li>
</ol>
<h3 id="dhcp-与-nat-dhcp-nat"><a class="markdownIt-Anchor" href="#dhcp-与-nat-dhcp-nat"></a> DHCP 与 NAT / DHCP &amp; NAT</h3>
<h4 id="动态主机配置协议-dhcp"><a class="markdownIt-Anchor" href="#动态主机配置协议-dhcp"></a> 动态主机配置协议 / DHCP</h4>
<p>Q:为什么现在连上NJUPT之后你不手动配置ip就可以上网？<br>
A:DHCP 服务器自动给连入网络的设备分配 IP 地址、子网掩码、网关和 DNS 地址</p>
<p>DHCP协议是一个局域网网络协议，使用 UDP 协议（67/68 端口）</p>
<ul>
<li><strong>DORA 流程</strong>:
<ol>
<li><strong>Discover</strong>: 客户端广播“有没有 DHCP 服务器？”</li>
<li><strong>Offer</strong>: 服务器广播“我有 IP 192.168.1.100，你要吗？”</li>
<li><strong>Request</strong>: 客户端广播“我要用 192.168.1.100。”</li>
<li><strong>Acknowledge</strong>: 服务器广播“确认分配，租期 24 小时。”</li>
</ol>
</li>
</ul>
<p><img src="/Computer-Network/DHCPv4.png" alt="DHCPv4"></p>
<h4 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 / NAT</h4>
<p>NAT 通过将私有 IP 转换为公网 IP，延缓了 IPv4 的耗尽<br>
<img src="/Computer-Network/NAT.png" alt="NAT"></p>
<blockquote>
<p><strong>Tip</strong><br>
这个软件是PNETlab<br>
如果对网络模拟器感兴趣可以使用这个<br>
<a href="https://pnetlab.com/pages/main">PNETLab : Lab is Simple</a></p>
</blockquote>
<h3 id="icmp-协议-icmp"><a class="markdownIt-Anchor" href="#icmp-协议-icmp"></a> ICMP 协议 / ICMP</h3>
<p><strong>ICMP</strong>：Internet Control Message Protocol，因特网控制报文协议<br>
方向：主机/路由器 -&gt; 源站(发送方)<br>
<img src="/Computer-Network/ICMP.jpeg" alt="ICMP"><br>
<code>ICMP</code> 报文分为两大类:<br>
<code>差错报告报文</code>和<code>提供信息的报文(询问报文)</code></p>
<ul>
<li>差错报告报文 (<code>Error Report Messages</code>)
<ul>
<li><code>3</code> 目的不可达 <code>Destination Unreachable</code></li>
<li><code>4</code> 源抑制 <code>Source Quench</code></li>
<li><code>5</code> 路由重定向 <code>Redirect (change a route)</code></li>
<li><code>11</code> 数据报超时 <code>Time Exceeded for a Datagram</code></li>
<li><code>12</code> 数据报参数问题 <code>Parameter Problem on a Datagram</code></li>
</ul>
</li>
<li>提供信息的报文 (询问报文) (<code>Information Request/Inquiry Messages</code>)
<ul>
<li><code>0</code> 回显应答 <code>Echo Reply</code></li>
<li><code>8</code> 回显请求 <code>Echo Request</code></li>
<li><code>9</code> 路由器广告 <code>Router Advertisement</code></li>
<li><code>10</code> 路由器请求 <code>Router Solicitation</code></li>
<li><code>13</code> 时间戳请求 <code>Timestamp Request</code></li>
<li><code>14</code> 时间戳应答 <code>Timestamp Reply</code></li>
<li><code>17</code> 地址掩码请求 <code>Address Mask Request</code></li>
<li><code>18</code> 地址掩码应答 <code>Address Mask Reply</code><br>
其中<code>3</code>、<code>11</code>、<code>0</code>、<code>8</code>常用</li>
</ul>
</li>
</ul>
<p><img src="/Computer-Network/ICMPcontent.jpg" alt="ICMPcontent"></p>
<h5 id="pingpacket-internet-groper"><a class="markdownIt-Anchor" href="#pingpacket-internet-groper"></a> PING(Packet InterNet Groper)</h5>
<p>PING 用来测试两个主机之间的连通性（可到达）<br>
使用了 ICMP 回送请求与回送回答报文<br>
PING 是应用层直接使用网络层 ICMP 的例子，它没有通过传输层的 TCP 或UDP<br>
<s>现在也有TCPing哦</s></p>
<p>当网络中存在网关或防火墙时，由于其防护和数据<br>
包过滤功能，连通性测试结果可能不正确。</p>
<h3 id="路由器体系结构-router-architecture"><a class="markdownIt-Anchor" href="#路由器体系结构-router-architecture"></a> 路由器体系结构 / Router Architecture</h3>
<p>路由器是网络层的核心专用计算机，其功能逻辑分为控制平面和数据平面<br>
<img src="/Computer-Network/route.png" alt="route"><br>
<strong>控制平面</strong>负责运行路由协议（如 OSPF、BGP），计算并生成路由表。<strong>数据平面</strong>则负责根据转发表，将输入端口到达的数据报通过交换结构，以线速交换到合适的输出端口</p>
<h3 id="路由选择协议-routing-protocols"><a class="markdownIt-Anchor" href="#路由选择协议-routing-protocols"></a> 路由选择协议 / Routing Protocols</h3>
<p>互联网被划分为许多<strong>自治系统 (AS)</strong>，路由协议因此分为内部网关协议 (IGP) 和外部网关协议 (EGP)</p>
<p><img src="/Computer-Network/AS.png" alt="AS"></p>
<p><strong>内部网关协议 (IGP)</strong> 主要处理 AS 内部路由。<strong>RIP</strong> 基于距离向量算法，受限于 15 跳，存在“坏消息传得慢”的问题。<strong>OSPF</strong> 基于链路状态算法，通过泛洪链路状态构建全网拓扑，并利用 <strong>Dijkstra 算法</strong> 计算最短路径，收敛快，适合大型网络</p>
<p><strong>外部网关协议 (EGP)</strong> 主要处理 AS 之间路由。<strong>BGP</strong> 是互联网的骨干协议，基于路径向量算法。它交换的是“可达性”信息，核心目标是控制<strong>路由策略</strong>（如政治、经济因素）而非单纯追求速度</p>
<h2 id="数据链路层-data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层-data-link-layer"></a> 数据链路层 / Data Link Layer</h2>
<p>数据链路层位于物理层与网络层之间，其核心职责是在<strong>相邻节点 (Node-to-Node)</strong> 之间提供可靠的帧传输服务。物理层传输的是非结构的比特流，而数据链路层通过<strong>封装成帧 (Framing)</strong>、<strong>差错检测</strong>和<strong>介质访问控制</strong>，将物理信道转变为逻辑上无差错的数据链路。在以太网 (Ethernet) 架构中，MAC 地址是该层识别设备的核心标识</p>
<h3 id="封装成帧-framing"><a class="markdownIt-Anchor" href="#封装成帧-framing"></a> 封装成帧 / Framing</h3>
<p>数据链路层将网络层传递下来的数据报（Packet）添加首部和尾部，封装成<strong>帧 (Frame)</strong>。帧不仅是数据链路层的传输单元，也界定了数据的起止位置（帧同步）<br>
<img src="/Computer-Network/frametransport.png" alt="frametransport"></p>
<p><strong>透明传输机制</strong><br>
为了防止数据载荷中出现的特定比特组合被误判为帧定界符（即“假标志”），必须采取透明传输措施：</p>
<ul>
<li><strong>字符填充法</strong>：在面向字节的协议（如 PPP）中，如果数据中出现控制字符，通过插入转义字符进行区分</li>
<li><strong>零比特填充法</strong>：在面向比特的协议（如 HDLC）中，若数据中连续出现 5 个“1”，则自动插入一个“0”，接收端执行逆操作。这确保了帧定界符（如 <code>01111110</code>）在数据流中的唯一性</li>
</ul>
<h3 id="差错控制-error-control"><a class="markdownIt-Anchor" href="#差错控制-error-control"></a> 差错控制 / Error Control</h3>
<p>物理信道受噪声影响可能产生比特差错<br>
数据链路层主要通过<strong>循环冗余校验 (CRC)</strong> 技术进行差错检测。发送端根据生成多项式计算出帧检验序列 (FCS) 并附加在帧尾；接收端通过模 2 运算验证数据的完整性</p>
<p>值得注意的是，现代以太网通常仅提供<strong>无差错接受</strong>（即凡是校验错误的帧直接丢弃，不负责重传），可靠传输通常由上层传输层（TCP）或特定的链路层协议（如无线链路）通过<strong>自动重传请求 (ARQ)</strong> 机制（包括停止-等待协议、后退 N 帧协议、选择重传协议）来实现</p>
<h3 id="介质访问控制-mac"><a class="markdownIt-Anchor" href="#介质访问控制-mac"></a> 介质访问控制 / MAC</h3>
<p>在广播信道（如总线型以太网或无线局域网）中，多个设备共享同一物理介质。为了解决多设备同时发送数据导致的<strong>冲突 (Collision)</strong>，必须采用介质访问控制协议</p>
<h4 id="载波监听多点接入-csma"><a class="markdownIt-Anchor" href="#载波监听多点接入-csma"></a> 载波监听多点接入 / CSMA</h4>
<p><strong>CSMA/CD (载波监听多点接入/碰撞检测)</strong><br>
有线以太网早期采用的随机接入协议。其工作流程遵循“先听后说，边听边说”原则：</p>
<ol>
<li><strong>载波监听</strong>：发送前检测信道是否空闲</li>
<li><strong>碰撞检测</strong>：发送过程中监控信道电压变化。一旦检测到冲突，立即停止发送并广播干扰信号</li>
<li><strong>二进制指数退避算法</strong>：发生冲突后，节点随机等待一段时间后重传。随着冲突次数增加，等待时间的随机范围呈指数级扩大，以降低再次冲突的概率</li>
</ol>
<p><strong>CSMA/CA (载波监听多点接入/碰撞避免)</strong><br>
无线局域网 (Wi-Fi) 由于无法在发送时准确检测碰撞（隐蔽站问题），采用了<strong>碰撞避免</strong>机制，通过帧间间隔 (IFS) 和预约信道（RTS/CTS 握手）来降低冲突概率</p>
<h3 id="mac-地址与以太网帧-mac-address-ethernet-frame"><a class="markdownIt-Anchor" href="#mac-地址与以太网帧-mac-address-ethernet-frame"></a> MAC 地址与以太网帧 / MAC Address &amp; Ethernet Frame</h3>
<p><strong>MAC 地址 (Media Access Control Address)</strong><br>
MAC 地址是烧录在网络接口控制器 (NIC) 上的 48 位全球唯一标识符，属于<strong>物理地址</strong>。与 IP 地址（逻辑地址）不同，MAC 地址是扁平化的，不具备层次结构，仅用于在局域网内部区分不同的硬件设备</p>
<p><strong>以太网帧结构</strong><br>
标准的以太网 V2 帧包含目的 MAC 地址、源 MAC 地址、类型字段（标识上层协议，如 IP）、数据载荷及帧检验序列 (FCS)。以太网规定了<strong>最大传输单元 (MTU)</strong>，通常为 1500 字节，限制了数据载荷的最大长度</p>
<h3 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 / ARP</h3>
<p>在实际通信中，发送方通常仅知晓目标的 IP 地址。ARP 协议解决了从 IP 地址到 MAC 地址的动态映射问题</p>
<p><strong>ARP 工作流程</strong></p>
<ol>
<li><strong>广播请求</strong>：源主机在局域网内广播发送 ARP 请求分组，询问特定 IP 地址对应的 MAC 地址</li>
<li><strong>单播响应</strong>：目标主机收到请求后，识别出自身的 IP 地址，并以单播形式返回包含自身 MAC 地址的 ARP 响应分组</li>
<li><strong>ARP 缓存</strong>：源主机收到响应后，将映射关系存入本地 ARP 高速缓存表，并设定老化时间，以避免重复广播</li>
</ol>
<p>我们可以用<code>arp -a</code>来看看arp自己电脑的arp表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">arp -a</span></span><br><span class="line">? (192.168.101.146) at c8:d3:ff:0f:70:0e [ether] on wlp4s0</span><br><span class="line">? (192.168.101.42) at 74:9e:f5:d7:f4:bb [ether] on wlp4s0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="交换机与-vlan-switch-vlan"><a class="markdownIt-Anchor" href="#交换机与-vlan-switch-vlan"></a> 交换机与 VLAN / Switch &amp; VLAN</h3>
<h4 id="交换机原理-switching"><a class="markdownIt-Anchor" href="#交换机原理-switching"></a> 交换机原理 / Switching</h4>
<p>传统的集线器工作在物理层，单纯转发比特，无法隔离冲突。交换机则是工作在数据链路层的多端口网桥</p>
<ul>
<li><strong>自学习算法</strong>：交换机通过分析进入端口的帧的<strong>源 MAC 地址</strong>，构建并维护 MAC 地址转发表</li>
<li><strong>帧转发</strong>：交换机根据<strong>目的 MAC 地址</strong>查找转发表，将帧精确转发至目标端口（若地址未知则泛洪）</li>
<li><strong>隔离冲突域</strong>：交换机的每个端口都是一个独立的冲突域，支持全双工通信，显著提升了网络性能</li>
</ul>
<h4 id="虚拟局域网-vlan"><a class="markdownIt-Anchor" href="#虚拟局域网-vlan"></a> 虚拟局域网 / VLAN</h4>
<p>虽然交换机隔离了冲突域，但所有端口仍属于同一个<strong>广播域</strong>。为了控制广播风暴和增强安全性，引入了 VLAN 技术（IEEE 802.1Q 标准）<br>
通过在以太网帧中插入 <strong>VLAN Tag（标签）</strong>，管理员可以在逻辑上将物理网络划分为多个独立的广播域。不同 VLAN 之间的通信无法直接通过二层交换实现，必须经过第三层设备（路由器或三层交换机）进行路由转发</p>
<p><img src="/Computer-Network/VLAN.png" alt="VLAN"></p>
<blockquote>
<p>小知识点</p>
</blockquote>
<ul>
<li>集线器 (Hub)：既不隔离冲突，也不隔离广播</li>
<li>交换机 (Switch)：隔离冲突，<strong>不</strong>隔离广播</li>
<li>路由器 (Router) / VLAN：隔离冲突，<strong>也</strong>隔离广播</li>
</ul>
<h3 id="广域网链路控制-wan-link-control"><a class="markdownIt-Anchor" href="#广域网链路控制-wan-link-control"></a> 广域网链路控制 / WAN Link Control</h3>
<p>与局域网不同，广域网 (WAN) 通常使用点对点连接，无需解决介质访问冲突问题，主要关注点对点的封装效率</p>
<ul>
<li><strong>PPP (Point-to-Point Protocol)</strong>：目前最广泛使用的广域网协议。它支持多种网络层协议，提供错误检测、链路配置（LCP）和网络控制（NCP）。PPP 是面向字节的，采用字节填充法实现透明传输</li>
<li><strong>HDLC (High-Level Data Link Control)</strong>：一种面向比特的同步数据链路层协议，采用零比特填充法。虽然具有较高的理论价值，但在实际互联网应用中已被 PPP 取代</li>
</ul>
<p><img src="/Computer-Network/PPP.png" alt="PPP"></p>
<h2 id="物理层-physical-layer"><a class="markdownIt-Anchor" href="#物理层-physical-layer"></a> 物理层 / Physical Layer</h2>
<p>物理层位于协议栈的最底层，其核心任务是确定传输介质的机械、电气、功能和过程特性，以便在物理媒体上透明地传输<strong>比特流 (Bit stream)</strong></p>
<h3 id="信号调制-signal-modulation"><a class="markdownIt-Anchor" href="#信号调制-signal-modulation"></a> 信号调制 / Signal Modulation</h3>
<p>计算机内部的数字信号需要转换为适合物理信道传输的模拟信号，这一过程称为调制</p>
<ul>
<li><strong>基带传输</strong>：直接传输数字基带信号的电压脉冲，通常用于近距离传输（如局域网）。</li>
<li><strong>频带传输</strong>：利用载波将数字信号搬移到较高的频段。常见的调制方法包括调幅 (ASK)、调频 (FSK) 和调相 (PSK)<br>
<img src="/Computer-Network/QAM.png" alt="QAM"></li>
</ul>
<h3 id="奈奎斯特定理-nyquist-theorem"><a class="markdownIt-Anchor" href="#奈奎斯特定理-nyquist-theorem"></a> 奈奎斯特定理 / Nyquist Theorem</h3>
<p>1924 年，奈奎斯特推导出了在<strong>理想低通（无噪声）</strong> 信道下的极限数据传输速率。该定理指出，为了避免<strong>码间串扰 (ISI)</strong>，信道的最高码元传输速率受限于信道带宽</p>
<p>公式表达为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>C</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mn>2</mn><mi>W</mi><mo>×</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>V</mi></mrow><annotation encoding="application/x-tex">C_{max} = 2W \times \log_2 V 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 为信道带宽 (Hz)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 为信号电平的离散等级数。该定理揭示了在无噪声环境下，提升数据传输率的唯一途径是采用更高阶的调制技术（增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>），从而使每个码元携带更多的比特信息</p>
<h3 id="香农定理-shannon-theorem"><a class="markdownIt-Anchor" href="#香农定理-shannon-theorem"></a> 香农定理 / Shannon Theorem</h3>
<p>1948 年，香农进一步提出了在<strong>高斯白噪声</strong>干扰下的信道容量极限。该定理定义了数据传输速率的绝对物理上限</p>
<p>公式表达为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>B</mi><mo>×</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = B \times \log_2(1 + \frac{S}{N}) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 为带宽，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为信噪比（功率比）。香农定理表明，在噪声不可避免的实际信道中，通过无限增加信号电平级数并不能无限提升速率，因为过密的电平会被噪声淹没</p>
<blockquote>
<p><strong>实际信道的极限传输速率由奈奎斯特定理和香农定理计算结果的较小值决定</strong></p>
</blockquote>
<h3 id="数据编码-data-encoding"><a class="markdownIt-Anchor" href="#数据编码-data-encoding"></a> 数据编码 / Data Encoding</h3>
<p>数据编码涉及将比特转换为具体的信号波形，重点在于时钟同步与频谱效率</p>
<p><strong>非归零编码 (NRZ)</strong><br>
NRZ 用高低电平直接表示 1 和 0。其主要缺陷是缺乏自同步能力，长串的连续 0 或 1 会导致接收端时钟漂移，且存在直流分量</p>
<p><strong>曼彻斯特编码 (Manchester)</strong><br>
曼彻斯特编码规定每个比特周期的中心必须发生电压跳变。这种跳变既代表数据（例如低到高为 0，高到低为 1），也作为时钟信号供接收端同步。虽然它实现了<strong>自同步</strong>，但其代价是频带宽度需求加倍（调制速率是数据率的 2 倍）</p>
<p><strong>差分曼彻斯特编码</strong><br>
这是一种抗干扰能力更强的编码。它同样在位中心跳变用于同步，但利用<strong>位开始边界</strong>是否发生跳变来表示数据（如无跳变表示 1，有跳变表示 0）<br>
<img src="/Computer-Network/01010101.png" alt="01010101"></p>
<h3 id="传输介质与模式-media-modes"><a class="markdownIt-Anchor" href="#传输介质与模式-media-modes"></a> 传输介质与模式 / Media &amp; Modes</h3>
<p>物理层的传输介质主要分为导引型（如双绞线、光纤）和非导引型（如无线电波）。光纤利用光的全反射原理传输，其中<strong>单模光纤</strong>因纤芯极细、无模间色散而适用于长距离主干传输；<strong>多模光纤</strong>则适用于短距离传输<br>
<img src="/Computer-Network/Single_mode_vs_Multimode_fiber.png" alt="Single_mode_vs_Multimode_fiber"></p>
<p>在通信交互方式上，分为三种模式：</p>
<ul>
<li><strong>单工</strong>：仅允许单方向传输</li>
<li><strong>半双工</strong>：允许双向传输，但某一时刻只能单向进行</li>
<li><strong>全双工</strong>：允许通信双方同时进行双向传输<br>
<img src="/Computer-Network/full_duplex_half_duplex.png" alt="full_duplex_half_duplex"></li>
</ul>
<h3 id="互连设备-interconnection-devices"><a class="markdownIt-Anchor" href="#互连设备-interconnection-devices"></a> 互连设备 / Interconnection Devices</h3>
<p>物理层设备主要包括中继器和集线器<br>
<strong>中继器 (Repeater)</strong> 的作用是对衰减的信号进行<strong>整形与再生</strong>，以恢复波形并延长传输距离<br>
<strong>集线器 (Hub)</strong> 实质上是一个多端口中继器。由于它将输入信号广播到所有端口，导致所有连接设备处于同一个<strong>冲突域</strong>，总带宽由所有用户共享，且网络效率随节点增加而急剧下降</p>
]]></content>
      <categories>
        <category>Computer Networks</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>My-Fedora-Journey</title>
    <url>/My-Fedora-Journey/</url>
    <content><![CDATA[<blockquote>
<p>冷知识:</p>
<ul>
<li>F2是机械革命翼龙15pro开bios的按键</li>
<li>fedora是rpm系，可以直接用dnf install xxx.rpm</li>
<li>fedora不是arch</li>
<li>fedora的重音是这样的 fe’dora</li>
</ul>
</blockquote>
<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-desktopkde-plasma-6stop-using-gnome">1. Desktop(KDE plasma 6)::stop using GNOME!</a>
<ul>
<li><a href="#11-%E9%85%8D%E7%BD%AE">1.1. 配置</a></li>
<li><a href="#12-%E6%A1%8C%E9%9D%A2%E4%BC%98%E5%8C%96">1.2. 桌面优化</a></li>
<li><a href="#13-tricks">1.3. Tricks</a>
<ul>
<li><a href="#131-%E7%AA%97%E5%8F%A3%E5%88%86%E5%B1%8F">1.3.1. 窗口分屏</a></li>
<li><a href="#132-krunner">1.3.2. KRunner</a></li>
<li><a href="#133-%E5%88%87%E6%8D%A2%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2">1.3.3. 切换虚拟桌面</a></li>
<li><a href="#134-%E5%88%87%E6%8D%A2%E5%BA%94%E7%94%A8">1.3.4. 切换应用</a></li>
<li><a href="#135-%E6%A1%8C%E9%9D%A2%E8%A7%86%E5%9B%BE">1.3.5. 桌面视图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bootrefinduefi-boot-manager">2. Boot(rEFInd)::UEFI Boot Manager</a>
<ul>
<li><a href="#21-uefi--bios">2.1. UEFI &amp; BIOS</a></li>
<li><a href="#22-efi%E9%87%8C%E9%9D%A2%E7%9A%84xdx">2.2. efi里面的xdx</a></li>
</ul>
</li>
<li><a href="#3-systemfedoramaybe-u-should-know-something-about-this">3. System(fedora)::maybe U should know something about this</a></li>
<li><a href="#4-optimizationsudousing-sudo-without-password">4. Optimization(sudo)::using sudo without password</a></li>
<li><a href="#5-optimizationauto-loginlogin-without-password">5. Optimization(auto login)::login without password</a></li>
<li><a href="#6-optimizationsuper-desktop%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E4%B9%A6%E5%86%99">6. Optimization(super .desktop)::快捷方式书写</a></li>
<li><a href="#7-optimizationtlpbattery">7. Optimization(tlp)::Battery</a></li>
<li><a href="#8-optimizationbluemanbluetooth">8. Optimization(blueman)::Bluetooth</a></li>
<li><a href="#9-toolneofetchshow-your-os">9. Tool(neofetch)::Show your OS</a></li>
<li><a href="#10-toolbleachbitrubbish-sorting">10. Tool(bleachbit)::Rubbish Sorting</a></li>
<li><a href="#11-toolweztermfishcome-and-use-wezterm">11. Tool(wezTerm+fish)::Come and use wezTerm!</a></li>
<li><a href="#12-toolfcitx5input-method">12. Tool(Fcitx5)::Input method</a></li>
<li><a href="#13-toolsnapperbackup">13. Tool(snapper)::Backup</a></li>
<li><a href="#14-toolvscode%E7%B1%B3%E5%A5%87%E5%A6%99%E5%A6%99%E7%89%A9">14. Tool(vscode)::米奇妙妙物</a></li>
<li><a href="#15-toolvirtualizationvisual-machine">15. Tool(virtualization)::Visual Machine</a></li>
<li><a href="#16-tooltermiusssh-helper">16. Tool(Termius)::ssh helper</a></li>
<li><a href="#17-workshopobsidiangdrivercloneworking-with-different-workspaces">17. Workshop(Obsidian+Gdrive+rclone)::working with different workspaces</a></li>
<li><a href="#18-environmentrust%E5%8A%A0%E5%85%A5rust%E7%A5%9E%E6%95%99%E5%96%B5%E5%96%B5%E5%8A%A0%E5%85%A5rust%E7%A5%9E%E6%95%99">18. Environment(rust)::加入rust神教喵喵加入rust神教</a></li>
<li><a href="#19-environmentccnjupt-wanted">19. Environment(c/c++)::NJUPT wanted</a></li>
<li><a href="#20-environmentfront-endnonononode_module">20. Environment(Front-end)::nonononode_module</a></li>
<li><a href="#21-environmentdockercontainer">21. Environment(docker)::Container</a></li>
<li><a href="#22-environmentk8scontainer">22. Environment(k8s)::Container</a>
<ul>
<li><a href="#221-k8s%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8Cnginx%E6%9C%8D%E5%8A%A1%E5%99%A8">22.1. k8s简单实验：nginx服务器</a></li>
<li><a href="#222-k8s%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%92%8Cminikube%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">22.2. k8s概念简单解析和minikube使用方法</a>
<ul>
<li><a href="#2221-k8s%E5%86%85%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5">22.2.1. k8s内重要概念</a></li>
<li><a href="#2222-kubectl">22.2.2. kubectl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-gaminggamemodegames-optimize">23. Gaming(gamemode)::Games optimize</a></li>
<li><a href="#24-sideloadinglegacy-ios-kit">24. Sideloading(legacy-ios-kit)</a></li>
<li><a href="#25-trickwayland-docker-osxbuilding-macos-with-docker">25. Trick(Wayland-Docker-OSX)::Building macOS with docker</a></li>
<li><a href="#26-tricksystemd-analyze-blameoptimization">26. Trick(systemd-analyze blame)::Optimization</a></li>
<li><a href="#27-trickmtu-testnetwork">27. Trick(MTU test)::Network</a></li>
<li><a href="#28-previewdesktop">28. Preview(Desktop)</a></li>
</ul>
</details>
<h2 id="1-desktopkde-plasma-6stop-using-gnome"><a class="markdownIt-Anchor" href="#1-desktopkde-plasma-6stop-using-gnome"></a> 1. Desktop(KDE plasma 6)::stop using GNOME!</h2>
<p>前端本来用的是默认的<code>GNOME</code>，因为没有桌面很难受所以换成了<code>KDE plasma</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install @kde-desktop-environment</span></span><br></pre></td></tr></table></figure>
<p>后面可以在登录页面切换桌面前端</p>
<h3 id="11-配置"><a class="markdownIt-Anchor" href="#11-配置"></a> 1.1. 配置</h3>
<p>s3是果粉</p>
<ul>
<li><code>显示和监视器配置-显示器配置-旧式应用程序(X11)</code> 一定要选 <code>由应用程序进行缩放</code></li>
<li><code>颜色和主题-全局主题</code>：WhiteSur-Dark</li>
<li><code>颜色和主题-全局主题-颜色</code>有问题，不能自动下下来暗色配色，要去<a href="https://store.kde.org/p/1398831">WhiteSur Color - KDE Store</a>手动下载，然后 从文件安装 选择<code>WhiteSurDark.colors</code></li>
<li><code>颜色和主题-全局主题-光标</code>：Breeze微风深色    官方这个很好看了</li>
<li><code>颜色和主题-全局主题-应用程序外观样式</code>：Breeze微风</li>
<li><code>颜色和主题-全局主题-应用程序外观样式-配置GNOME/GTK应用程序外观样式</code>：WhiteSur-Dark</li>
<li><code>文字和字体-文字</code>：FiraCode Nerd Font 11pt   （有没有推荐的好字体awa）<br>
<strong><code>动效</code></strong></li>
<li>窗口打开/关闭：按比例缩放</li>
<li>窗口最大化：拉伸动效</li>
<li>窗口最小化：最小过渡动画(收缩)</li>
<li>窗口全屏：拉伸效果</li>
<li>虚拟桌面切换器：滑动<br>
点一下<code>更多效果设置</code>来到<code>窗口管理-桌面特效</code><br>
以下只写出我勾选的选项</li>
<li>外观增强-无响应窗口灰化</li>
<li>外观增强-窗口背景虚化</li>
<li>外观增强-窗口透明度-常规透明度设置-仅仅稍微降低了一点<code>移动中窗口</code>的透明度</li>
<li>外观增强-高亮显示屏幕和周围四角</li>
<li>窗口管理功能-桌面概览</li>
</ul>
<h3 id="12-桌面优化"><a class="markdownIt-Anchor" href="#12-桌面优化"></a> 1.2. 桌面优化</h3>
<ul>
<li><code>下方面板设置：</code>对齐：居中;宽度：填满宽度;显示/隐藏：总是显示;不透明度：自适应;悬浮：面板和小程序;面板高度：40</li>
</ul>
<blockquote>
<p>添加的组件：右侧：虚拟桌面切换器，暂时显示桌面</p>
</blockquote>
<ul>
<li>上方面板设置：对齐：靠左;宽度：填满宽度;显示/隐藏：总是显示;不透明度：自适应;悬浮：已禁用;面板高度：32</li>
</ul>
<blockquote>
<p>添加的组件：左侧：应用程序启动器<br>
右侧从右到左：数字时钟-搜索-系统托盘</p>
</blockquote>
<ul>
<li><code>桌面添加组件</code>:媒体相框，二进制时钟，窗口列表，网络速度（修改成了内存使用率）</li>
</ul>
<blockquote>
<p>Fedora 43默认使用的已经变成了KDE plasma<br>
去掉了X11<br>
Do you like Wayland?</p>
</blockquote>
<h3 id="13-tricks"><a class="markdownIt-Anchor" href="#13-tricks"></a> 1.3. Tricks</h3>
<p>在<code>KDE plasma</code>上，有一些功能你会很喜欢的</p>
<h4 id="131-窗口分屏"><a class="markdownIt-Anchor" href="#131-窗口分屏"></a> 1.3.1. 窗口分屏</h4>
<p>快捷键<code>Meta</code>+<code>键盘左键和右键和上下键</code><br>
当然也可以直接拖动窗口到左右边缘也可以分屏</p>
<h4 id="132-krunner"><a class="markdownIt-Anchor" href="#132-krunner"></a> 1.3.2. KRunner</h4>
<p>快捷键<code>alt</code>+<code>空格</code><br>
全局搜索和应用启动等等等等<br>
功能可以自行探索</p>
<h4 id="133-切换虚拟桌面"><a class="markdownIt-Anchor" href="#133-切换虚拟桌面"></a> 1.3.3. 切换虚拟桌面</h4>
<p>快捷键<code>ctrl</code>+<code>Meta</code>+<code>键盘左右键</code><br>
如果配置了桌面循环切换食用更佳a</p>
<h4 id="134-切换应用"><a class="markdownIt-Anchor" href="#134-切换应用"></a> 1.3.4. 切换应用</h4>
<p>快捷键<code>Meta</code>+<code>tab</code>或者<code>alt</code>+<code>tab</code></p>
<h4 id="135-桌面视图"><a class="markdownIt-Anchor" href="#135-桌面视图"></a> 1.3.5. 桌面视图</h4>
<p>快捷键<code>Meta</code>+<code>G</code><br>
使用起来很方便</p>
<h2 id="2-bootrefinduefi-boot-manager"><a class="markdownIt-Anchor" href="#2-bootrefinduefi-boot-manager"></a> 2. Boot(rEFInd)::UEFI Boot Manager</h2>
<p>因为电脑上是双系统，因此需要一个折中的启动方案<br>
没有选择使用grub引导启动，而是使用了<code>rEFInd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install rEFInd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> refind-install</span></span><br><span class="line">ShimSource is none</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line"></span><br><span class="line">CAUTION: Your computer appears to be booted with Secure Boot, but you haven&#x27;t</span><br><span class="line">specified a valid shim.efi file source. Chances are you should re-run with</span><br><span class="line">the --shim option. You can read more about this topic at</span><br><span class="line">http://www.rodsbooks.com/refind/secureboot.html.</span><br><span class="line"></span><br><span class="line">Do you want to proceed with installation (Y/N)? n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这看出来问题了，脚本并不能自主识别本地efi在哪个地方<br>
因此使用了<code>sudo refind-install --shim /boot/efi/EFI/fedora/shimx64.efi</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> refind-install --shim /boot/efi/EFI/fedora/shimx64.efi</span></span><br><span class="line">ShimSource is /boot/efi/EFI/fedora/shimx64.efi</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line">Installing driver for ext4 (ext4_x64.efi)</span><br><span class="line">Storing copies of rEFInd Secure Boot public keys in //etc/refind.d/keys</span><br><span class="line">Copied rEFInd binary files</span><br><span class="line"></span><br><span class="line">Copying sample configuration file as refind.conf; edit this file to configure</span><br><span class="line">rEFInd.</span><br><span class="line"></span><br><span class="line">Creating new NVRAM entry</span><br><span class="line">rEFInd is set as the default boot manager.</span><br><span class="line">Creating //boot/refind_linux.conf; edit it to adjust kernel options.</span><br><span class="line">The appropriate Secure Boot key is already enrolled.</span><br><span class="line"></span><br><span class="line">Installation has completed successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这边看起来说都弄好了，结果我到MoK那边去找的时候傻眼了，发现这个keys目录是空的啊！<br>
折腾死了，最后还是选择关掉了<code>Secure Boot</code><br>
目前配置仍有问题，自动的识别会多出来很多的启动项<br>
不过确实可以自动扫到windows和fedora,能统一启动是事实，但目前体验感不好</p>
<blockquote>
<p>最新消息：<br>
使用默认主题选到不需要的启动项可以使用Del按键选择隐藏，因此可以修改好之后再启动</p>
</blockquote>
<p>同时如果类似fedora这种可以扫出来很多内容，要注意保留的是什么，我就用我自己扫到的举个例子</p>
<ul>
<li>Boot Microsoft EFI boot from EFI System Partition</li>
<li>Boot EFI\fedora\grubx64.efi from EFI System Partition</li>
<li>Boot EFI\fedora\gcdx64.efi from EFI System Partition</li>
<li>Boot Fallback boot loader from EFI System Partition</li>
<li>Boot vmlinuz-6.16.12-200.fc42.x86_64 from 1024 MiB ext4 Volume</li>
</ul>
<p>这边只需要保留<code>Microsoft EFI boot</code>和最后一个 <code>vmlinuz</code></p>
<p>使用的主题是<br>
<a href="https://github.com/catppuccin/refind">GitHub - catppuccin/refind: 🔄 Soothing pastel theme for rEFInd</a></p>
<blockquote>
<p>知识拓展</p>
</blockquote>
<h3 id="21-uefi-bios"><a class="markdownIt-Anchor" href="#21-uefi-bios"></a> 2.1. UEFI &amp; BIOS</h3>
<p>BIOS(<strong>Basic Input/Output System</strong>)</p>
<ol>
<li><strong>POST (Power-On Self-Test，开机自检)</strong>：
<ul>
<li>它会先清点一遍家当，快速检查所有核心硬件是否连接正常并能工作。如果发现严重问题（比如没插内存条），它就会通过鸣叫来报警。</li>
</ul>
</li>
<li><strong>寻找“交接手册”</strong>：
<ul>
<li>自检通过后，老管家需要找到操作系统的“启动说明书”。它不知道 Windows 或 Linux 是什么，但它知道要去一个<strong>固定的地方</strong>找。这个地方就是硬盘的<strong>第一个扇区</strong>，一个仅有 512 字节的微小空间，被称为<strong>主引导记录 (MBR - Master Boot Record)</strong>。</li>
</ul>
</li>
<li><strong>加载并执行</strong>：
<ul>
<li>BIOS 会把 MBR 里的这段代码加载到内存中，然后把计算机的控制权完全交给它。BIOS 的任务到此基本结束。</li>
</ul>
</li>
<li><strong>交接班</strong>：
<ul>
<li>从 MBR 开始，后续的引导加载程序会一步步接力，最终将整个操作系统加载到内存中并运行起来。</li>
</ul>
</li>
</ol>
<blockquote>
<p>在几十年的时间里，BIOS 工作得非常出色。它简单、可靠、标准化。但随着计算机技术爆炸式发展，这位老管家开始显得力不从心，他的几个“老毛病”越来越严重：</p>
</blockquote>
<ul>
<li><strong>视野太窄（2.2TB 硬盘限制）</strong>：MBR 使用 32 位地址来记录分区，这导致它能管理的最大硬盘容量只有 2.2TB。在今天 4TB、8TB 硬盘普及的时代，这成了一个无法逾越的障碍。</li>
<li><strong>启动太慢</strong>：BIOS 只能以 16 位的“老模式”运行，内存寻址能力只有 1MB，并且它是一个个地初始化硬件，效率低下。</li>
<li><strong>不够安全</strong>：BIOS 没有任何安全校验机制。黑客可以制造一种叫“Bootkit”的病毒，在操作系统启动前就感染 MBR，从而获得最高控制权，极难被发现和清除。</li>
<li><strong>界面古老</strong></li>
</ul>
<p>在老式的 BIOS 启动方式下，电脑启动时会去硬盘的主引导记录 MBR 寻找启动代码，这种方法较为死板，因此聪明的人们就想到了另一种启动方式：UEFI<br>
UEFI 统一可扩展固件接口启动方式，它不依赖于某个固定位置，而是规定硬盘上必须有一个特殊的小分区，这就是 ESP(<strong>EFI System Partition</strong>)</p>
<p>ESP的特点：</p>
<ul>
<li><strong>格式特殊</strong>：它必须是 FAT32 格式。这是为了确保所有操作系统和 UEFI 固件都能无障碍地读写它</li>
<li><strong>功能专一</strong>：它的唯一作用就是存放<strong>引导加载程序 (Bootloader)</strong></li>
</ul>
<p><strong>ESP 是所有已安装操作系统的启动程序的存放地和调度中心</strong></p>
<p>UEFI 的革命性优势</p>
<ol>
<li><strong>全新的启动方式：GPT 分区与 ESP 分区</strong>
<ul>
<li><strong>告别 MBR，拥抱 GPT</strong>：UEFI 不再使用 MBR，而是使用全新的 <strong>GPT (GUID Partition Table)</strong> 分区方案。GPT 使用 64 位地址，理论上可以支持高达 9.4 ZB (94 亿 TB) 的硬盘，彻底解决了容量限制问题。同时，它还支持多达 128 个主分区。</li>
<li><strong>告别固定位置，启用 ESP</strong>：UEFI 不再去硬盘的第一个扇区找启动代码。而是在硬盘上建立一个标准化的 <strong>EFI 系统分区 (ESP)</strong>。所有操作系统的引导加载程序（.efi 文件）都以普通文件的形式存放在这个分区里。UEFI 固件会扫描并读取这些文件，生成一个启动菜单。这就像从“在门缝下塞纸条”升级到了“拥有一个标准的公告板”。</li>
</ul>
</li>
<li><strong>安全启动 (Secure Boot)</strong>
<ul>
<li>这是 UEFI 最核心的优势之一。它建立了一个“信任链”。主板固件内置了一些受信任的公钥（通常是微软和硬件厂商的）。</li>
<li>在启动时，UEFI 会校验引导加载程序（如 gcdx64.efi）的数字签名。如果签名无效或被篡改，UEFI 会拒绝执行它，从而从根源上杜绝了 Bootkit 病毒的入侵。</li>
</ul>
</li>
<li><strong>现代化的人机交互</strong>
<ul>
<li>UEFI 拥有<strong>图形化界面</strong>，支持鼠标操作，分辨率更高，设置选项也更丰富、更人性化。</li>
<li>它是一个可扩展的平台，主板厂商可以在 UEFI 界面中内置各种高级功能，比如硬件诊断工具、在线固件更新，甚至是一个简易的网页浏览器。</li>
</ul>
</li>
<li><strong>无与伦比的性能和速度</strong>
<ul>
<li>UEFI 以 32 位或 64 位模式运行，可以访问全部系统内存，没有 1MB 的限制。</li>
<li>它可以并行初始化硬件设备，大大缩短了开机自检时间，实现了“秒速开机”。</li>
</ul>
</li>
<li><strong>强大的扩展性</strong>
<ul>
<li>UEFI 可以加载独立的硬件驱动程序。这意味着它在操作系统启动前就能识别并使用更多的硬件，比如网卡（实现网络启动或远程诊断）。</li>
</ul>
</li>
</ol>
<h3 id="22-efi里面的xdx"><a class="markdownIt-Anchor" href="#22-efi里面的xdx"></a> 2.2. efi里面的xdx</h3>
<p>Boot EFI\fedora\grubx64.efi from EFI System Partition<br>
我们以这个为例子，这是grub，Fedora 的主要引导加载程序 GRUB2(<em>GRand Unified Bootloader</em>)</p>
<p>Boot EFI\fedora\gcdx64.efi from EFI System Partition<br>
这个是为了兼容<strong>Secure Boot</strong> 功能而存在的特殊程序<strong>Secure Boot Shim</strong>。安全启动是 UEFI 的一个安全特性，它要求所有启动代码都必须有受信任的数字签名，以防止恶意软件在操作系统启动前运行<br>
grubx64.efi 没有微软的签名，而这个使用了shim来签名，很多时候这个都是默认的启动方式</p>
<p>Boot Fallback boot loader from EFI System Partition<br>
这是<strong>备用/应急引导加载程序</strong>，UEFI 规范定义了一个标准的、通用的启动路径：EFI\BOOT\BOOTX64.EFI。如果因为某些原因（比如系统配置错误、NVRAM 记录丢失），UEFI 找不到为系统设置的特定启动项，它会最后尝试去寻找这个“备用路径”。</p>
<p>Boot vmlinuz-6.16.12-200.fc42.x86_64 from 1024 MiB ext4 Volume<br>
这是直接从 Linux 文件系统启动 Linux 内核。现代 Linux 内核支持一种叫 EFISTUB 的技术，允许 UEFI 固件像运行一个 .efi 程序一样，直接加载并运行内核文件<br>
我目前开机使用的就是这个，因为它确实快一些</p>
<h2 id="3-systemfedoramaybe-u-should-know-something-about-this"><a class="markdownIt-Anchor" href="#3-systemfedoramaybe-u-should-know-something-about-this"></a> 3. System(fedora)::maybe U should know something about this</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf update</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf upgrade --refresh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf search htop <span class="comment"># 搜索包</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf remove htop <span class="comment"># 删除</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf list installed <span class="comment"># 查看安装的包</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf autoremove    <span class="comment"># 删除孤立的依赖包</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf clean all    <span class="comment"># 清理 DNF 缓存</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lha <span class="comment"># 以更易读的格式 (-h) 显示详细信息 (-l)，包括隐藏文件 (-a)。</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/nginx <span class="comment"># cd .. cd ~ or cd：</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span> <span class="comment"># 康康你在哪里口牙</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> Projects</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> source.txt destination.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r source_folder/ destination_folder/：-r 表示递归复制整个文件夹。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> journalctl --vacuum-time=2weeks   <span class="comment"># 仅保留两周日志</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">flatpak uninstall --unused  <span class="comment"># flatpak 不使用的包</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">du</span> -sh ~/.cache</span></span><br><span class="line">6.2G    /home/s3loy/.cache</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -rf ~/.cache/*</span></span><br></pre></td></tr></table></figure>
<p>不想写，用什么查什么吧<br>
如果有的指令可以看看<a href="https://njupt-sast.feishu.cn/wiki/OU2Ow2GxuiG2tVkPfLvcmfWxnEd">运维组第一次授课 虚拟机和命令行 - 飞书云文档</a></p>
<h2 id="4-optimizationsudousing-sudo-without-password"><a class="markdownIt-Anchor" href="#4-optimizationsudousing-sudo-without-password"></a> 4. Optimization(sudo)::using sudo without password</h2>
<p>因为每次用<code>sudo</code>都需要密码觉得太麻烦了，所以修改了一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> visudo</span></span><br></pre></td></tr></table></figure>
<p>修改了这一行<br>
<code>%wheel ALL=(ALL)       NOPASSWD: ALL</code><br>
然后保存就行了，因为本身用户就在wheel用户组内</p>
<h2 id="5-optimizationauto-loginlogin-without-password"><a class="markdownIt-Anchor" href="#5-optimizationauto-loginlogin-without-password"></a> 5. Optimization(auto login)::login without password</h2>
<p>系统设置-外观和样式-颜色和主题-全局主题-登录屏幕(SDDM)-右上角的“行为…”-自动登录 选择账户和前端并输入密码</p>
<h2 id="6-optimizationsuper-desktop快捷方式书写"><a class="markdownIt-Anchor" href="#6-optimizationsuper-desktop快捷方式书写"></a> 6. Optimization(super .desktop)::快捷方式书写</h2>
<p><code>~/.local/share/applications/feishu.desktop</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Name=飞书</span><br><span class="line">Comment=Feishu | Lark, a work collaboration platform</span><br><span class="line">Exec=/opt/bytedance/feishu/feishu %U</span><br><span class="line">Icon=/opt/bytedance/feishu/product_logo_256.png</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Network;Office;InstantMessaging;</span><br></pre></td></tr></table></figure>
<h2 id="7-optimizationtlpbattery"><a class="markdownIt-Anchor" href="#7-optimizationtlpbattery"></a> 7. Optimization(tlp)::Battery</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install tlp tlp-rdw</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> tlp.service</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf copr <span class="built_in">enable</span> sunwire/envycontrol</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install python3-envycontrol</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">sudo</span> envycontrol -q</span></span><br><span class="line">hybrid</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> envycontrol --switch integrated <span class="comment"># 集成显卡模式</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> envycontrol --switch hybrid <span class="comment"># 混合模式</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> envycontrol --switch discrete <span class="comment"># 独显直连模式</span></span></span><br></pre></td></tr></table></figure>
<h2 id="8-optimizationbluemanbluetooth"><a class="markdownIt-Anchor" href="#8-optimizationbluemanbluetooth"></a> 8. Optimization(blueman)::Bluetooth</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install bluez gnome-bluetooth</span></span><br><span class="line">仓库更新和加载中:</span><br><span class="line">仓库加载完成。</span><br><span class="line">Package &quot;bluez-5.84-2.fc42.x86_64&quot; is already installed.</span><br><span class="line">Package &quot;gnome-bluetooth-1:47.1-2.fc42.x86_64&quot; is already installed.</span><br><span class="line"></span><br><span class="line">Nothing to do.</span><br></pre></td></tr></table></figure>
<p>但发现仍然识别不到耳机，<br>
于是使用另外一个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install blueman</span></span><br></pre></td></tr></table></figure>
<p>连接成功</p>
<h2 id="9-toolneofetchshow-your-os"><a class="markdownIt-Anchor" href="#9-toolneofetchshow-your-os"></a> 9. Tool(neofetch)::Show your OS</h2>
<p><code>fedora</code>的官方仓库里面是没有neofetch的，但是可以<br>
<code>sudo dnf install fastfetch</code><br>
作为替代<br>
但是官方其实也有给出解决方案<br>
<a href="https://github.com/dylanaraps/neofetch/wiki/Installation#fedora--rhel--centos--mageia--openmandriva">Installation · dylanaraps/neofetch Wiki · GitHub</a></p>
<h2 id="10-toolbleachbitrubbish-sorting"><a class="markdownIt-Anchor" href="#10-toolbleachbitrubbish-sorting"></a> 10. Tool(bleachbit)::Rubbish Sorting</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install bleachbit</span></span><br></pre></td></tr></table></figure>
<h2 id="11-toolweztermfishcome-and-use-wezterm"><a class="markdownIt-Anchor" href="#11-toolweztermfishcome-and-use-wezterm"></a> 11. Tool(wezTerm+fish)::Come and use wezTerm!</h2>
<p>默认的终端应用是<code>konsole</code>,有一点不满意，于是换成了<strong>wezTerm</strong>+<strong>fish</strong>+<strong>oh my fish</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf copr <span class="built_in">enable</span> wezfurlong/wezterm-nightly</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install wezterm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chsh -s /usr/bin/fish</span></span><br></pre></td></tr></table></figure>
<p>在<a href="https://www.nerdfonts.com/font-downloads">nerd fonts</a><br>
下载了FiraCode Nerd Font,解压到了<code>~/.fonts</code>文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fc-cache -fv</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nano ~/.wezterm.lua</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> wezterm = <span class="built_in">require</span> <span class="string">&#x27;wezterm&#x27;</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">config</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> wezterm.config_builder <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">config</span> = wezterm.config_builder()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.font = wezterm.font_with_fallback(&#123;</span><br><span class="line">  <span class="string">&#x27;FiraCode Nerd Font&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Noto Color Emoji&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.harfbuzz_features = &#123;<span class="string">&#x27;calt=1&#x27;</span>, <span class="string">&#x27;clig=1&#x27;</span>, <span class="string">&#x27;liga=1&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.color_scheme = <span class="string">&#x27;Catppuccin Mocha&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.window_background_opacity = <span class="number">0.95</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.window_padding = &#123;</span><br><span class="line">  left = <span class="number">15</span>,</span><br><span class="line">  right = <span class="number">15</span>,</span><br><span class="line">  top = <span class="number">15</span>,</span><br><span class="line">  bottom = <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.hide_tab_bar_if_only_one_tab = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.default_cursor_style = <span class="string">&#x27;BlinkingBar&#x27;</span></span><br><span class="line"><span class="built_in">config</span>.enable_scroll_bar = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>.keys = &#123;</span><br><span class="line">  <span class="comment">-- 关闭当前窗格 (Pane)</span></span><br><span class="line">  &#123;</span><br><span class="line">    key = <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    mods = <span class="string">&#x27;ALT&#x27;</span>,</span><br><span class="line">    action = wezterm.action.CloseCurrentPane &#123; confirm = <span class="literal">true</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 关闭当前标签页 (Tab)</span></span><br><span class="line">  &#123;</span><br><span class="line">    key = <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    mods = <span class="string">&#x27;CTRL|SHIFT&#x27;</span>,</span><br><span class="line">    action = wezterm.action.CloseCurrentTab &#123; confirm = <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 水平分割窗格 (左右)</span></span><br><span class="line">  &#123;</span><br><span class="line">    key = <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">    mods = <span class="string">&#x27;ALT&#x27;</span>,</span><br><span class="line">    action = wezterm.action.SplitHorizontal &#123; domain = <span class="string">&#x27;CurrentPaneDomain&#x27;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 垂直分割窗格 (上下)</span></span><br><span class="line">  &#123;</span><br><span class="line">    key = <span class="string">&#x27;=&#x27;</span>,</span><br><span class="line">    mods = <span class="string">&#x27;ALT&#x27;</span>,</span><br><span class="line">    action = wezterm.action.SplitVertical &#123; domain = <span class="string">&#x27;CurrentPaneDomain&#x27;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">config</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://raw.githubusercontent.com/oh-my-fish/oh-my-fish/master/bin/install | fish</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">omf install pure</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install fzf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install grc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">omf install fzf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">omf install grc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">omf install nvm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">omf install z</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用的是<code>pure</code>主题</p>
<blockquote>
<p>主题预览<br>
<img src="/My-Fedora-Journey/pure.png" alt="preview"></p>
</blockquote>
<h2 id="12-toolfcitx5input-method"><a class="markdownIt-Anchor" href="#12-toolfcitx5input-method"></a> 12. Tool(Fcitx5)::Input method</h2>
<p>一开始使用了<code>IBus</code><br>
其中碰到的问题例如Obsidian不能使用中文输入法<br>
在启动命令行参数里面添加了<br>
<code>--enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime</code><br>
但是修改之后qq又不能输入了<br>
然后又换回了<code>Fcitx5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-qt</span></span><br></pre></td></tr></table></figure>
<p>看有推荐使用Fcitx5 rime的，还没进行尝试</p>
<p>使用主题：<a href="https://github.com/thep0y/fcitx5-themes-candlelight">GitHub - thep0y/fcitx5-themes-candlelight: fcitx5的简约风格皮肤——烛光。</a><br>
里面的winter<br>
它的mac主题遮罩都有明显问题，观感不好不推荐使用</p>
<p>配置修改：</p>
<ul>
<li>临时在当前和第一个输入法之间切换 绑定 <code>Shift</code> 可以方便适应</li>
<li>开启云拼音，把后端改成百度</li>
<li>去拼音里面把前后鼻音啥的纠错打打开</li>
</ul>
<blockquote>
<p>已知问题：<br>
在使用qq的时候智能使用默认的双行输入而不是单行 即使通过<code>ctrl</code>+<code>alt</code>+<code>P</code> 也不可以更改输入模式</p>
</blockquote>
<p>后续问题：<br>
漏字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/environment</span></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line"></span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加了如下环境变量</p>
<h2 id="13-toolsnapperbackup"><a class="markdownIt-Anchor" href="#13-toolsnapperbackup"></a> 13. Tool(snapper)::Backup</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install snapper python3-dnf-plugin-snapper</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper -c root create-config /</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它会自动进行备份</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ 类型   │ 前期 <span class="comment"># │ 日期                               │ 用户 │ 清空     │ 描述</span></span></span><br><span class="line">     │ 用户数据</span><br><span class="line">──┼────────┼────────┼────────────────────────────────────┼──────┼──────────┼──────────┼─────────</span><br><span class="line">0 │ single │        │                                    │ root │          │ current  │</span><br><span class="line">1 │ single │        │ 2025年10月21日 星期二 19时00分00秒 │ root │ timeline │ timeline │</span><br><span class="line">2 │ single │        │ 2025年10月21日 星期二 20时00分00秒 │ root │ timeline │ timeline │</span><br><span class="line">3 │ single │        │ 2025年10月21日 星期二 21时00分00秒 │ root │ timeline │ timeline │</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以参考<a href="https://documentation.suse.com/zh-cn/sles/12-SP5/html/SLES-all/cha-snapper.html">通过 Snapper 进行系统恢复和快照管理 | 管理指南 | SLES 12 SP5</a></p>
<p><code>sudo snapper create --description &quot;进行重要操作前的备份&quot;</code></p>
<p>后编：<br>
<code>btrfs</code>下<code>snapper</code>保存快照太狠了，s3一看发现<code>df -h </code>和 <code>du -h</code>两边差距非常大，电脑出现了几十个G的幽灵文件<br>
这一看<code>sudo snapper list</code> 发现存爆了都<br>
所以需要删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper delete --<span class="built_in">sync</span> 1-97</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper create --<span class="built_in">type</span> single --description <span class="string">&quot;手动备份-准备清理旧快照&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper set-config <span class="string">&quot;TIMELINE_LIMIT_HOURLY=0&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper set-config <span class="string">&quot;TIMELINE_LIMIT_DAILY=7&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snapper set-config <span class="string">&quot;TIMELINE_LIMIT_MONTHLY=3&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>一下子干净多了<br>
qaq</p>
<h2 id="14-toolvscode米奇妙妙物"><a class="markdownIt-Anchor" href="#14-toolvscode米奇妙妙物"></a> 14. Tool(vscode)::米奇妙妙物</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> rpm --import https://packages.microsoft.com/keys/microsoft.asc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf check-update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install code</span></span><br></pre></td></tr></table></figure>
<p>插件: 还没有分类</p>
<ul>
<li>Better Comments Next</li>
<li>bis</li>
<li>Bookmarks</li>
<li>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</li>
<li>Code Spell Checker</li>
<li>CodeLLDB</li>
<li>Container Tools</li>
<li>Dependi</li>
<li>Dev Containers</li>
<li>Dotenv</li>
<li>Dotenv Official +Vault</li>
<li>Easy CodeSnap</li>
<li>Even Better TOML</li>
<li>Git Graph v3</li>
<li>GitHub Copilot</li>
<li>GitHub Copilot Chat</li>
<li>Go</li>
<li>Golang Tools</li>
<li>Kubernetes</li>
<li>LLDB DAP</li>
<li>Makefile Tools</li>
<li>Markdown All in One</li>
<li>markdownlint</li>
<li>Prettier - Code format</li>
<li>Pylance</li>
<li>Python</li>
<li>Python Debugger</li>
<li>Python Environments</li>
<li>Remote - SSH</li>
<li>Remote - SSH: Editing</li>
<li>Remote - Tunnels</li>
<li>Remote Development</li>
<li>Remote Explorer</li>
<li>Rust Syntax</li>
<li>rust-analyzer</li>
<li>Slidev</li>
<li>Svelte for VS Code</li>
<li>Swift</li>
<li>TODO Highlight</li>
<li>YAML</li>
</ul>
<h2 id="15-toolvirtualizationvisual-machine"><a class="markdownIt-Anchor" href="#15-toolvirtualizationvisual-machine"></a> 15. Tool(virtualization)::Visual Machine</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install @virtualization</span></span><br></pre></td></tr></table></figure>
<p>要关防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl stop firewalld</span></span><br></pre></td></tr></table></figure>
<p>ps：这个防火墙真的很烦人啊<br>
然后还可以使用VMware Workstation</p>
<h2 id="16-tooltermiusssh-helper"><a class="markdownIt-Anchor" href="#16-tooltermiusssh-helper"></a> 16. Tool(Termius)::ssh helper</h2>
<p>官方只提供了<code>.deb</code>包，因此使用snap仓库内的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snap install termius-app</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处不推荐使用flatpak,因为文件不共享会导致SFTP不好用</p>
</blockquote>
<p>然后就可以去应用程序那边找到了<br>
<code>termius</code> 可以白嫖学生认证，用github账户关联下就可以了</p>
<p>ssh 连接服务器，然后爽用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install openssh-server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>
<h2 id="17-workshopobsidiangdrivercloneworking-with-different-workspaces"><a class="markdownIt-Anchor" href="#17-workshopobsidiangdrivercloneworking-with-different-workspaces"></a> 17. Workshop(Obsidian+Gdrive+rclone)::working with different workspaces</h2>
<p>方案：</p>
<ul>
<li>markdown：<strong>Obsidian+OneDrive</strong></li>
<li>coding：<strong>github&amp;gitlab</strong></li>
<li>[ ] TODO： CI/CD</li>
</ul>
<p><a href="https://github.com/abraunegg/onedrive/blob/master/docs/install.md">OneDrive for linux</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install onedrive</span></span><br></pre></td></tr></table></figure>
<p>OneDrive失败，<strong>南邮管理员没开启认证</strong></p>
<blockquote>
<p>切换方案 Google Drive</p>
</blockquote>
<p><a href="https://rclone.org/"><strong>rclone</strong></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> -v ; curl https://rclone.org/install.sh | <span class="built_in">sudo</span> bash</span></span><br><span class="line">...</span><br><span class="line">rclone v1.71.1 has successfully installed.</span><br><span class="line">Now run &quot;rclone config&quot; for setup. Check https://rclone.org/docs/ for more details.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后续可以参考https://www.cnblogs.com/Undefined443/p/18615701</span></span><br></pre></td></tr></table></figure>
<p>使用方法:</p>
<blockquote>
<p>我的本地config命名就是 <strong>work_space</strong> ()<br>
所以如果config命名不一样救修改 &quot; : &quot;前面的那个work_space即可<br>
位置要根据自己文件存放的位置使用</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从上游拉下来</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">sync</span> -P work_space:work_space /workshop/work_space/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从本地提交上去</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">sync</span> -P /workshop/work_space/ work_space:work_space</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone lsd work_space:work_space</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">ls</span> work_space:work_space</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">blog备份</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">sync</span> -P /workshop/Blog/source/_posts  work_space:work_space/s3_workshop/Blogs</span>  </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">sync</span> -P work_space: /workshop/work_space/ --drive-root-folder-id 1gQg-FNNg2kLR8vnQMV9b5-Mqpro2roMN <span class="comment">#下载</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone <span class="built_in">sync</span> -P /workshop/work_space/ work_space: --drive-root-folder-id 1gQg-FNNg2kLR8vnQMV9b5-Mqpro2roMN <span class="comment">#上传</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>新的方法：<br>
使用了fish的自定义函数，创建了一个workshop指令</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> workshop --description <span class="string">&quot;Sync local workshop directory with Google Drive&quot;</span></span><br><span class="line">    <span class="built_in">set</span> filter_file ~/.config/rclone/filter-rules.txt</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> rclone_opts --checkers=16 --transfers=2 --low-level-retries=20</span><br><span class="line"></span><br><span class="line">    switch <span class="variable">$argv</span>[1]</span><br><span class="line">        <span class="keyword">case</span> pull</span><br><span class="line">            <span class="built_in">echo</span> (set_color green)<span class="string">&quot;⬇️  Syncing from Google Drive to local...&quot;</span>(set_color normal)</span><br><span class="line">            rclone <span class="built_in">sync</span> -P work_space: /workshop/work_space/ --drive-root-folder-id 1gQg-FNNg2kLR8vnQMV9b5-Mqpro2roMN --filter-from <span class="variable">$filter_file</span> <span class="variable">$rclone_opts</span></span><br><span class="line">            <span class="built_in">echo</span> (set_color green)<span class="string">&quot;✅ Pull complete.&quot;</span>(set_color normal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> push</span><br><span class="line">            <span class="built_in">echo</span> (set_color cyan)<span class="string">&quot;⬆️  Syncing from local to Google Drive...&quot;</span>(set_color normal)</span><br><span class="line">            rclone <span class="built_in">sync</span> -P /workshop/work_space/ work_space: --drive-root-folder-id 1gQg-FNNg2kLR8vnQMV9b5-Mqpro2roMN --filter-from <span class="variable">$filter_file</span> <span class="variable">$rclone_opts</span></span><br><span class="line">            <span class="built_in">echo</span> (set_color cyan)<span class="string">&quot;✅ Push complete.&quot;</span>(set_color normal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Usage: workshop [subcommand]&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Subcommands:&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> (set_color green)<span class="string">&quot;  pull&quot;</span>(set_color normal)<span class="string">&quot;   Download changes from Google Drive&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> (set_color cyan)<span class="string">&quot;  push&quot;</span>(set_color normal)<span class="string">&quot;   Upload local changes to Google Drive&quot;</span></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="18-environmentrust加入rust神教喵喵加入rust神教"><a class="markdownIt-Anchor" href="#18-environmentrust加入rust神教喵喵加入rust神教"></a> 18. Environment(rust)::加入rust神教喵喵加入rust神教</h2>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh  </code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span>  </span><br><span class="line">info: downloading installer  </span><br><span class="line">  </span><br><span class="line">Welcome to Rust!  </span><br><span class="line">  </span><br><span class="line">This will download and install the official compiler for the Rust  </span><br><span class="line">programming language, and its package manager, Cargo.  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">1) Proceed with standard installation (default - just press enter)  </span><br><span class="line">2) Customize installation  </span><br><span class="line">3) Cancel installation</span><br></pre></td></tr></table></figure>
<p>直接回车就好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">info: default toolchain set to &#x27;stable-x86_64-unknown-linux-gnu&#x27;  </span><br><span class="line">  </span><br><span class="line"> stable-x86_64-unknown-linux-gnu installed - rustc 1.90.0 (1159e78c4 2025-09-14)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">Rust is installed now. Great!  </span><br><span class="line">  </span><br><span class="line">To get started you may need to restart your current shell.  </span><br><span class="line">This would reload your PATH environment variable to include  </span><br><span class="line">Cargo&#x27;s bin directory ($HOME/.cargo/bin).  </span><br><span class="line">  </span><br><span class="line">To configure your current shell, you need to source  </span><br><span class="line">the corresponding env file under $HOME/.cargo.  </span><br><span class="line">  </span><br><span class="line">This is usually done by running one of the following (note the leading DOT):  </span><br><span class="line">. &quot;$HOME/.cargo/env&quot;            # For sh/bash/zsh/ash/dash/pdksh  </span><br><span class="line">source &quot;$HOME/.cargo/env.fish&quot;  # For fish  </span><br><span class="line">source $&quot;($nu.home-path)/.cargo/env.nu&quot;  # For nushell</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s3loy@fedora:~$ rustc --version</span><br><span class="line">rustc 1.90.0 (1159e78c4 2025-09-14)</span><br><span class="line">s3loy@fedora:~$ cargo --version</span><br><span class="line">cargo 1.90.0 (840b83a10 2025-07-30)</span><br></pre></td></tr></table></figure>
<h2 id="19-environmentccnjupt-wanted"><a class="markdownIt-Anchor" href="#19-environmentccnjupt-wanted"></a> 19. Environment(c/c++)::NJUPT wanted</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf group install development-tools</span><br><span class="line"></span><br><span class="line">sudo dnf install gcc-c++</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb --version</span></span><br><span class="line">GNU gdb (Fedora Linux) 16.3-1.fc42</span><br><span class="line">Copyright (C) 2024 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ --version</span></span><br><span class="line">g++ (GCC) 15.2.1 20250808 (Red Hat 15.2.1-1)</span><br><span class="line">Copyright © 2025 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc --version</span></span><br><span class="line">gcc (GCC) 15.2.1 20250808 (Red Hat 15.2.1-1)</span><br><span class="line">Copyright © 2025 Free Software Foundation, Inc.</span><br><span class="line">本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">包括没有适销性和某一专用目的下的适用性担保。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Something U can use.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf install cmake</span><br><span class="line"></span><br><span class="line">sudo dnf install qt6-qtbase-devel qt6-qtsvg-devel qt6-qttools-devel</span><br><span class="line"></span><br><span class="line">sudo dnf install qt-creator</span><br></pre></td></tr></table></figure>
<h2 id="20-environmentfront-endnonononode_module"><a class="markdownIt-Anchor" href="#20-environmentfront-endnonononode_module"></a> 20. Environment(Front-end)::nonononode_module</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dnf install nodejs npm</span><br><span class="line"></span><br><span class="line">sudo dnf install google-chrome</span><br><span class="line"></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br><span class="line"></span><br><span class="line">nvm install --lts</span><br><span class="line">nvm use --lts</span><br><span class="line">nvm alias default lts/*</span><br><span class="line"></span><br><span class="line">npm install -g pnpm@latest-10</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pnpm -v</span></span><br><span class="line">10.17.1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm -v</span></span><br><span class="line">11.6.1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm -v</span></span><br><span class="line">0.39.7</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node -v</span></span><br><span class="line">v22.20.0</span><br></pre></td></tr></table></figure>
<h2 id="21-environmentdockercontainer"><a class="markdownIt-Anchor" href="#21-environmentdockercontainer"></a> 21. Environment(docker)::Container</h2>
<p><a href="https://docs.docker.com/engine/install/fedora/">Install Docker Engine on Fedora</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf upgrade --refresh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf -y install dnf-plugins-core</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf remove docker \</span></span><br><span class="line"><span class="language-bash">                  docker-client \</span></span><br><span class="line"><span class="language-bash">                  docker-client-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-common \</span></span><br><span class="line"><span class="language-bash">                  docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-selinux \</span></span><br><span class="line"><span class="language-bash">                  docker-engine-selinux \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf -y install dnf-plugins-core</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf-3 config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你要自启用这个</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start docker</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run hello-world</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span></span><br><span class="line">Created symlink &#x27;/etc/systemd/system/multi-user.target.wants/docker.service&#x27; → &#x27;/usr/lib/systemd/system/docker.service&#x27;.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run hello-world</span></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">17eec7bbc9d7: Pull complete</span><br><span class="line">Digest: sha256:54e66cc1dd1fcb1c3c58bd8017914dbed8701e2d8c74d9262e26bd9cc1642d31</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<h2 id="22-environmentk8scontainer"><a class="markdownIt-Anchor" href="#22-environmentk8scontainer"></a> 22. Environment(k8s)::Container</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> rpm -Uvh minikube-latest.x86_64.rpm</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube kubectl -- get pods -A</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl completion fish | <span class="built_in">source</span></span></span><br><span class="line">fish: kubectl: 未找到命令...</span><br><span class="line">提供此文件的软件包是：</span><br><span class="line">&#x27;kubernetes1.29-client&#x27;</span><br><span class="line">&#x27;kubernetes1.30-client&#x27;</span><br><span class="line">&#x27;kubernetes1.31-client&#x27;</span><br><span class="line">&#x27;kubernetes1.32-client&#x27;</span><br><span class="line">&#x27;kubernetes1.33-client&#x27;</span><br><span class="line">&#x27;kubernetes1.34-client&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install kubernetes1.34-client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl completion fish | <span class="built_in">source</span></span></span><br></pre></td></tr></table></figure>
<h3 id="221-k8s简单实验nginx服务器"><a class="markdownIt-Anchor" href="#221-k8s简单实验nginx服务器"></a> 22.1. k8s简单实验：nginx服务器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment nginx-deployment --image=nginx</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment</span></span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   1/1     1            1           43s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-7457467ffd-6fxtv   1/1     Running   0          87s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=NodePort --port=80</span></span><br><span class="line">service/nginx-deployment exposed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get service nginx-deployment</span></span><br><span class="line">NAME               TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-deployment   NodePort   10.98.106.65   &lt;none&gt;        80:31891/TCP   18s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube service nginx-deployment</span></span><br><span class="line">┌───── ┬─────────┬────── ┬───────────── ┐</span><br><span class="line">│ NAMESPACE │       NAME       │ TARGET PORT │            URL            │</span><br><span class="line">├───── ┼─────────┼────── ┼───────────── ┤</span><br><span class="line">│ default   │ nginx-deployment │ 80          │ http://192.168.49.2:31891 │</span><br><span class="line">└───── ┴─────────┴────── ┴───────────── ┘</span><br><span class="line">🎉  正通过默认浏览器打开服务 default/nginx-deployment...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你怎么歪了</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://192.168.49.2:31891/</span> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>二则 多容器实验</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployment nginx-deployment --replicas=3</span></span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-7457467ffd-489qf   1/1     Running   0          25s</span><br><span class="line">nginx-deployment-7457467ffd-6fxtv   1/1     Running   0          7m5s</span><br><span class="line">nginx-deployment-7457467ffd-b6km2   1/1     Running   0          25s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete service nginx-deployment</span></span><br><span class="line">service &quot;nginx-deployment&quot; deleted from default namespace</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete deployment nginx-deployment</span></span><br><span class="line">deployment.apps &quot;nginx-deployment&quot; deleted from default namespace</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://192.168.49.2:31891/</span></span><br><span class="line">curl: (7) Failed to connect to 192.168.49.2 port 31891 after 0 ms: Could not connect to server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line">No resources found in default namespace.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube stop</span></span><br><span class="line">✋  正在停止节点 &quot;minikube&quot; ...</span><br><span class="line">🛑  正在通过 SSH 关闭“minikube”…</span><br><span class="line">🛑  1 个节点已停止。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube delete</span></span><br><span class="line">🔥  正在删除 docker 中的“minikube”…</span><br><span class="line">🔥  正在删除容器 &quot;minikube&quot; ...</span><br><span class="line">🔥  正在移除 /home/s3loy/.minikube/machines/minikube…</span><br><span class="line">💀  已删除所有关于 &quot;minikube&quot; 集群的痕迹。</span><br></pre></td></tr></table></figure>
<p>三则 多节点创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start --nodes 3 -p multi-node-cluster</span></span><br><span class="line">😄  Fedora 42 上的 [multi-node-cluster] minikube v1.37.0</span><br><span class="line">✨  自动选择 docker 驱动。其他选项：podman, qemu2, none, ssh</span><br><span class="line">📌  使用具有 root 权限的 Docker 驱动程序</span><br><span class="line">👍  在集群中 &quot;multi-node-cluster&quot; 启动节点 &quot;multi-node-cluster&quot; primary control-plane</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.48 ...</span><br><span class="line">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.48, but successfully downloaded docker.io/kicbase/stable:v0.0.48@sha256:7171c97a51623558720f8e5878e4f4637da093e2f2ed589997bedc6c1549b2b1 as a fallback image</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=3072MB）...</span><br><span class="line">🐳  正在 Docker 28.4.0 中准备 Kubernetes v1.34.0…</span><br><span class="line">🔗  配置 CNI (Container Networking Interface) ...</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line">    ▪ 正在使用镜像 gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">🌟  启用插件： storage-provisioner, default-storageclass</span><br><span class="line"></span><br><span class="line">👍  在集群中 &quot;multi-node-cluster&quot; 启动节点 &quot;multi-node-cluster-m02&quot; worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.48 ...</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=3072MB）...</span><br><span class="line">🌐  找到的网络选项：</span><br><span class="line">    ▪ NO_PROXY=192.168.49.2</span><br><span class="line">🐳  正在 Docker 28.4.0 中准备 Kubernetes v1.34.0…</span><br><span class="line">    ▪ env NO_PROXY=192.168.49.2</span><br><span class="line">🔎  正在验证 Kubernetes 组件...</span><br><span class="line"></span><br><span class="line">👍  在集群中 &quot;multi-node-cluster&quot; 启动节点 &quot;multi-node-cluster-m03&quot; worker</span><br><span class="line">🚜  正在拉取基础镜像 v0.0.48 ...</span><br><span class="line">🔥  创建 docker container（CPU=2，内存=3072MB）...</span><br><span class="line">🌐  找到的网络选项：</span><br><span class="line">    ▪ NO_PROXY=192.168.49.2,192.168.49.3</span><br><span class="line">🐳  正在 Docker 28.4.0 中准备 Kubernetes v1.34.0…</span><br><span class="line">    ▪ env NO_PROXY=192.168.49.2</span><br><span class="line">    ▪ env NO_PROXY=192.168.49.2,192.168.49.3                                                                                                                                         🔎  正在验证 Kubernetes 组件...</span><br><span class="line">🏄  完成！kubectl 现在已配置，默认使用&quot;multi-node-cluster&quot;集群和&quot;default&quot;命名空间</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME                     STATUS   ROLES           AGE     VERSION</span><br><span class="line">multi-node-cluster       Ready    control-plane   3m21s   v1.34.0</span><br><span class="line">multi-node-cluster-m02   Ready    &lt;none&gt;          3m8s    v1.34.0</span><br><span class="line">multi-node-cluster-m03   Ready    &lt;none&gt;          2m58s   v1.34.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube status -p multi-node-cluster</span></span><br><span class="line">multi-node-cluster</span><br><span class="line">type: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br><span class="line"></span><br><span class="line">multi-node-cluster-m02</span><br><span class="line">type: Worker</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line"></span><br><span class="line">multi-node-cluster-m03</span><br><span class="line">type: Worker</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment nginx-deployment --image=nginx</span></span><br><span class="line">deployment.apps/nginx-deployment created</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployment nginx-deployment --replicas=6</span></span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE   IP           NODE                     NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deployment-7457467ffd-67tv9   1/1     Running   0          54s   10.244.2.2   multi-node-cluster-m03   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-7457467ffd-6vt69   1/1     Running   0          54s   10.244.2.3   multi-node-cluster-m03   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-7457467ffd-8wsmk   1/1     Running   0          54s   10.244.1.3   multi-node-cluster-m02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-7457467ffd-g9ngm   1/1     Running   0          54s   10.244.0.4   multi-node-cluster       &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-7457467ffd-gjk49   1/1     Running   0          75s   10.244.1.2   multi-node-cluster-m02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-7457467ffd-vffxz   1/1     Running   0          54s   10.244.0.3   multi-node-cluster       &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube profile list</span></span><br><span class="line">┌──────────┬────┬──── ┬───────┬──── ┬────┬─── ┬────────┬──────────┐</span><br><span class="line">│      PROFILE       │ DRIVER │ RUNTIME │      IP      │ VERSION │ STATUS │ NODES │ ACTIVE PROFILE │ ACTIVE KUBECONTEXT │</span><br><span class="line">├──────────┼────┼──── ┼───────┼──── ┼────┼─── ┼────────┼──────────┤</span><br><span class="line">│ multi-node-cluster │ docker │ docker  │ 192.168.49.2 │ v1.34.0 │ OK     │ 3     │                │ *                  │</span><br><span class="line">└──────────┴────┴──── ┴───────┴──── ┴────┴─── ┴────────┴──────────┘</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment nginx-deployment --<span class="built_in">type</span>=NodePort --port=80</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube ip -p multi-node-cluster</span></span><br><span class="line">192.168.49.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 192.168.49.2</span></span><br><span class="line">curl: (7) Failed to connect to 192.168.49.2 port 80 after 0 ms: Could not connect to server</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get service nginx-deployment</span></span><br><span class="line">NAME               TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-deployment   NodePort   10.106.236.139   &lt;none&gt;        80:32530/TCP   3m38s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://192.168.49.2:32530/</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete service nginx-deployment</span></span><br><span class="line">service &quot;nginx-deployment&quot; deleted from default namespace</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete deployment nginx-deployment</span></span><br><span class="line">deployment.apps &quot;nginx-deployment&quot; deleted from default namespace</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube delete -p multi-node-cluster</span></span><br><span class="line">🔥  正在删除 docker 中的“multi-node-cluster”…</span><br><span class="line">🔥  正在删除容器 &quot;multi-node-cluster&quot; ...</span><br><span class="line">🔥  正在删除容器 &quot;multi-node-cluster-m02&quot; ...</span><br><span class="line">🔥  正在删除容器 &quot;multi-node-cluster-m03&quot; ...</span><br><span class="line">🔥  正在移除 /home/s3loy/.minikube/machines/multi-node-cluster…</span><br><span class="line">🔥  正在移除 /home/s3loy/.minikube/machines/multi-node-cluster-m02…</span><br><span class="line">🔥  正在移除 /home/s3loy/.minikube/machines/multi-node-cluster-m03…</span><br><span class="line">💀  已删除所有关于 &quot;multi-node-cluster&quot; 集群的痕迹。</span><br></pre></td></tr></table></figure>
<h3 id="222-k8s概念简单解析和minikube使用方法"><a class="markdownIt-Anchor" href="#222-k8s概念简单解析和minikube使用方法"></a> 22.2. k8s概念简单解析和minikube使用方法</h3>
<h4 id="2221-k8s内重要概念"><a class="markdownIt-Anchor" href="#2221-k8s内重要概念"></a> 22.2.1. k8s内重要概念</h4>
<ul>
<li>Pod (最小工作单元)</li>
</ul>
<blockquote>
<p>Pod 是 K8s 中可以创建和管理的最小部署单元。一个 Pod 包含一个或多个紧密相关的容器（比如一个主应用容器和一个日志收集容器）。这些容器共享同一个网络环境和存储卷，可以把它们看作一个整体。<br>
通常使用更高层管理。</p>
</blockquote>
<ul>
<li>Deployment (部署)</li>
</ul>
<blockquote>
<p>确保指定数量的 Pod 正在运行。副本管理，滚动更新，回滚三大功能。</p>
</blockquote>
<ul>
<li>Service (服务)</li>
</ul>
<blockquote>
<p>服务发现，会自动跟踪其后端 Pod 的变化；负载均衡，将请求优先发送到健康 Pod</p>
</blockquote>
<ul>
<li>Namespace (命名空间)</li>
</ul>
<blockquote>
<p>资源进行逻辑上的隔离,创建的 Deployment、Service 等资源都属于某一个 Namespace。默认情况下，它们都在 default 命名空间里.</p>
</blockquote>
<h4 id="2222-kubectl"><a class="markdownIt-Anchor" href="#2222-kubectl"></a> 22.2.2. kubectl</h4>
<p><a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/"><strong>kube control</strong></a>用于 K8s 集群交互</p>
<p>使用方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] [flags]</span></span><br></pre></td></tr></table></figure>
<h2 id="23-gaminggamemodegames-optimize"><a class="markdownIt-Anchor" href="#23-gaminggamemodegames-optimize"></a> 23. Gaming(gamemode)::Games optimize</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> dnf install gamemode</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl --user <span class="built_in">enable</span> gamemoded.service &amp;&amp; systemctl --user start gamemoded.service</span></span><br></pre></td></tr></table></figure>
<h2 id="24-sideloadinglegacy-ios-kit"><a class="markdownIt-Anchor" href="#24-sideloadinglegacy-ios-kit"></a> 24. Sideloading(legacy-ios-kit)</h2>
<p><a href="https://github.com/LukeZGD/Legacy-iOS-Kit">GitHub - LukeZGD/Legacy-iOS-Kit: An all-in-one tool to restore/downgrade, save SHSH blobs, jailbreak legacy iOS devices, and more</a></p>
<p>目前还没有使用过，但看起来是一个很好的侧载方案</p>
<h2 id="25-trickwayland-docker-osxbuilding-macos-with-docker"><a class="markdownIt-Anchor" href="#25-trickwayland-docker-osxbuilding-macos-with-docker"></a> 25. Trick(Wayland-Docker-OSX)::Building macOS with docker</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it \ </span>                                                          </span><br><span class="line">             --device /dev/kvm \</span><br><span class="line">             -p 50922:10022 \</span><br><span class="line">             -e XDG_RUNTIME_DIR=/tmp \</span><br><span class="line">             -e WAYLAND_DISPLAY=$WAYLAND_DISPLAY \</span><br><span class="line">             -v $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY:/tmp/$WAYLAND_DISPLAY  \</span><br><span class="line">             -e GENERATE_UNIQUE=true \</span><br><span class="line">             -e MASTER_PLIST_URL=&#x27;https://raw.githubusercontent.com/sickcodes/osx-serial-generator/master/config-custom.plist&#x27; \</span><br><span class="line">             -e SHORTNAME=sonoma \</span><br><span class="line">             sickcodes/docker-osx:latest</span><br><span class="line">             </span><br></pre></td></tr></table></figure>
<p>还没有成功，死在了盘都装好了打不开来，但因为<code>wayland</code>的<code>display</code>和<code>x11</code>有所区别,所以得参考<code>github</code>内<code>issues</code></p>
<h2 id="26-tricksystemd-analyze-blameoptimization"><a class="markdownIt-Anchor" href="#26-tricksystemd-analyze-blameoptimization"></a> 26. Trick(systemd-analyze blame)::Optimization</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ systemd-analyze blame</span><br><span class="line">5.338s NetworkManager-wait-online.service</span><br><span class="line">4.232s sys-module-fuse.device</span><br><span class="line">4.171s sys-devices-LNXSYSTM:00-LNXSYBUS:00-MSFT0101:00-tpm-tpm0.device</span><br><span class="line">4.171s dev-tpm0.device</span><br><span class="line">4.117s dev-ttyS3.device</span><br><span class="line">4.117s sys-devices-platform-serial8250-serial8250:0-serial8250:0.3-tty-ttyS3.de&gt;</span><br><span class="line">4.115s sys-devices-platform-serial8250-serial8250:0-serial8250:0.2-tty-ttyS2.de&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">感觉性能优化的时候用得到</span><br></pre></td></tr></table></figure>
<h2 id="27-trickmtu-testnetwork"><a class="markdownIt-Anchor" href="#27-trickmtu-testnetwork"></a> 27. Trick(MTU test)::Network</h2>
<p>因为发现向<code>google drive</code>上传的时候很慢，刚刚好看一下是不是这一块的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping -c 3 -M <span class="keyword">do</span> -s 1453 8.8.8.8</span></span><br><span class="line">ping: sendmsg: 消息过长</span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 1453(1481) 字节的数据。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping -c 3 -M <span class="keyword">do</span> -s 1452 8.8.8.8</span></span><br><span class="line">PING 8.8.8.8 (8.8.8.8) 1452(1480) 字节的数据。</span><br><span class="line">1460 字节，来自 8.8.8.8: icmp_seq=1 ttl=112 时间=45.7 毫秒</span><br></pre></td></tr></table></figure>
<p>顺手把<code>tun</code>模式换成了<code>System</code>,因为<code>System</code>快啊</p>
<blockquote>
<p>好像是因为ICMP和TCP的区别<br>
呜呜有没有大神教我计网</p>
</blockquote>
<h2 id="28-previewdesktop"><a class="markdownIt-Anchor" href="#28-previewdesktop"></a> 28. Preview(Desktop)</h2>
<p><img src="/My-Fedora-Journey/desktop.png" alt="desktop"><br>
<s>我不是福瑞控🐾</s></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>fedora</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Network-Layer</title>
    <url>/Network-Layer/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-network-layer">1. Network Layer</a>
<ul>
<li><a href="#11-ip">1.1. IP</a>
<ul>
<li><a href="#111-ipv4-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">1.1.1. IPv4 数据报格式</a></li>
<li><a href="#112-ip-%E5%88%86%E7%89%87-fragmentation">1.1.2. IP 分片 (Fragmentation)</a></li>
</ul>
</li>
<li><a href="#12-icmp">1.2. ICMP</a>
<ul>
<li><a href="#121-%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8icmp%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B">1.2.1. 几种常用ICMP报文类型</a>
<ul>
<li><a href="#1211-%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%8A%A5%E6%96%873">1.2.1.1. 目的不可达报文（3）</a></li>
<li><a href="#1212-%E8%B6%85%E6%97%B6%E6%8A%A5%E6%96%8711">1.2.1.2. 超时报文（11）</a></li>
<li><a href="#1213-%E5%9B%9E%E5%BA%94%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87-%E7%B1%BB%E5%9E%8B-8-%E5%92%8C-0">1.2.1.3. <strong>回应请求与应答报文 (类型 8 和 0)</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-arp-address-resolution-protocol">1.3. ARP (Address Resolution Protocol)</a></li>
<li><a href="#14-dhcp-dynamic-host-configuration-protocol">1.4. DHCP (Dynamic Host Configuration Protocol)</a></li>
<li><a href="#15-%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-routing-protocols">1.5. 路由协议 (Routing Protocols)</a>
<ul>
<li><a href="#151-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-igp---interior-gateway-protocol">1.5.1. 内部网关协议 (IGP - Interior Gateway Protocol)</a></li>
<li><a href="#152-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-egp---exterior-gateway-protocol">1.5.2. 外部网关协议 (EGP - Exterior Gateway Protocol)</a></li>
</ul>
</li>
<li><a href="#16-ipv6">1.6. IPv6</a></li>
<li><a href="#17-igmp-internet-group-management-protocol">1.7. IGMP (Internet Group Management Protocol)</a></li>
<li><a href="#18-nat-network-address-translation">1.8. NAT (Network Address Translation)</a></li>
<li><a href="#19-ipsec-internet-protocol-security">1.9. IPsec (Internet Protocol Security)</a></li>
<li><a href="#110-vrrp-virtual-router-redundancy-protocol">1.10. VRRP (Virtual Router Redundancy Protocol)</a></li>
<li><a href="#111-mpls-multiprotocol-label-switching">1.11. MPLS (Multiprotocol Label Switching)</a></li>
</ul>
</li>
</ul>
</details>
<h1 id="1-network-layer"><a class="markdownIt-Anchor" href="#1-network-layer"></a> 1. Network Layer</h1>
<blockquote>
<p>网络层是<code>OSI</code>模型中的第三层，它负责在不同网络之间（端到端）提供数据包的路由和转发。网络互联的本质是通过<code>IP</code>协议实现的，而数据传输的基本单元是<code>IP</code>数据报。本章将详细介绍网络层的核心协议与技术。</p>
</blockquote>
<p>网络互连<code>本质</code>是通过<code>ip</code>实现的，<code>传输</code>是以<code>ip数据报</code>为介质。</p>
<h2 id="11-ip"><a class="markdownIt-Anchor" href="#11-ip"></a> 1.1. IP</h2>
<p><code>IP</code>协议是无连接、不可靠的数据报服务。</p>
<ul>
<li><strong>无连接 (<code>Connectionless</code>)</strong>：发送方在发送数据前，不需要与接收方建立连接。每个数据报都是独立传输的，因此到达顺序、完整性都不能保证。</li>
<li><strong>不可靠 (<code>Unreliable</code>)</strong>：<code>IP</code>协议不提供错误恢复或重传机制。如果数据报在传输中丢失或损坏，<code>IP</code>层本身不会处理，而是交由上层协议（如<code>TCP</code>）来确保可靠性。</li>
</ul>
<h3 id="111-ipv4-数据报格式"><a class="markdownIt-Anchor" href="#111-ipv4-数据报格式"></a> 1.1.1. IPv4 数据报格式</h3>
<p>一个<code>IP</code>数据报由<code>首部 (Header)</code>和<code>数据 (Data)</code>两部分组成。首部通常为20字节，包含了路由和转发所需的所有关键信息。</p>
<ul>
<li><strong>版本 (<code>Version</code>)</strong> (4位): 指示<code>IP</code>协议的版本，对于<code>IPv4</code>，该值为 4。</li>
<li><strong>首部长度 (<code>IHL - Internet Header Length</code>)</strong> (4位): 表示整个<code>IP</code>首部的长度，单位是 <strong>4字节</strong>（32位）。例如，如果该值为5，则首部长度为 5 * 4 = 20 字节。最小值为5（20字节），最大值为15（60字节）。</li>
<li><strong>服务类型 (<code>ToS - Type of Service</code>)</strong> (8位): 用于指定数据报的优先级和服务质量（<code>QoS</code>）要求，例如最小延迟、最大吞吐量等。</li>
<li><strong>总长度 (<code>Total Length</code>)</strong> (16位): 指示整个<code>IP</code>数据报（包括首部和数据）的总长度，单位是字节。最大长度为 <code>65535</code> 字节。</li>
<li><strong>标识 (<code>Identification</code>)</strong> (16位): 该字段唯一标识一个数据报。当数据报因为过大而被分片时，所有分片都将拥有相同的标识号，以便接收方能够将它们重新组装。</li>
<li><strong>标志 (<code>Flags</code>)</strong> (3位):
<ul>
<li>第1位：保留，必须为0。</li>
<li>第2位：<strong><code>DF (Don't Fragment)</code></strong>。如果设为1，则禁止路由器对该数据报进行分片。如果数据报过大而无法通过，路由器将丢弃它并返回一个<code>ICMP</code>错误消息。</li>
<li>第3位：<strong><code>MF (More Fragments)</code></strong>。如果设为1，表示后面还有更多的分片；如果为0，表示这是最后一个分片（或未分片）。</li>
</ul>
</li>
<li><strong>片偏移 (<code>Fragment Offset</code>)</strong> (13位): 指示当前分片在原始数据报中的位置。偏移量以 <strong><code>8字节</code></strong> 为单位。</li>
<li><strong>生存时间 (<code>TTL - Time to Live</code>)</strong> (8位): 设置数据报在网络中可以存活的最大跳数（经过的路由器数）。每经过一个路由器，<code>TTL</code>值减1。当<code>TTL</code>减为0时，路由器将丢弃该数据报，并向源主机发送一个<code>ICMP</code>超时消息。这可以防止数据报在网络中无限循环。</li>
<li><strong>协议 (<code>Protocol</code>)</strong> (8位): 指示<code>IP</code>数据报的数据部分承载的是哪个上层协议。例如，<code>6 </code>代表<code>TCP</code>，<code>17 </code>代表<code>UDP</code>，1 代表<code>ICMP</code>。</li>
<li><strong>首部检验和 (<code>Header Checksum</code>)</strong> (16位): 用于校验<code>IP</code>首部在传输过程中是否出错。它只对首部进行计算，不包括数据部分。</li>
<li><strong>源IP地址 (<code>Source IP Address</code>)</strong> (32位): 发送方设备的<code>IP</code>地址。</li>
<li><strong>目的IP地址 (<code>Destination IP Address</code>)</strong> (32位): 接收方设备的<code>IP</code>地址。</li>
<li><strong>选项 (<code>Options</code>)</strong> (可变长): 用于一些特殊处理，如记录路由、时间戳等。由于选项会增加首部长度并降低处理效率，因此不常用。如果存在，首部长度字段会大于5。</li>
</ul>
<h3 id="112-ip-分片-fragmentation"><a class="markdownIt-Anchor" href="#112-ip-分片-fragmentation"></a> 1.1.2. IP 分片 (Fragmentation)</h3>
<p>当一个<code>IP</code>数据报的长度超过了链路的<strong>最大传输单元 (<code>MTU</code>)</strong> 时，路由器就需要将其分割成多个更小的数据报，这个过程称为分片。</p>
<ul>
<li>标识、标志和片偏移这三个字段共同协作，以确保分片能够在目的主机被正确地重组。</li>
<li>所有分片共享相同的标识号。</li>
<li>除了最后一个分片，其他所有分片的<code>MF</code>标志位都为1。</li>
<li>片偏移字段记录了每个分片数据在原始数据中的相对位置。</li>
</ul>
<hr>
<h2 id="12-icmp"><a class="markdownIt-Anchor" href="#12-icmp"></a> 1.2. ICMP</h2>
<p><strong>ICMP</strong>：<code>Internet Control Message Protocol</code> ，因特网控制报文协议</p>
<p>方向：主机/路由器 -&gt; 源站(发送方)</p>
<p><img src="/Network-Layer/54070be665d2466175453f2c7153900f-1740404253149-1.jpeg" alt></p>
<p><code>代码</code> 提供了进一步的描述信息，在此不进一步提供描述信息，<s>即代码的代码（？</s>。</p>
<hr>
<p><strong>However</strong>, 首先想区分一下这边的四个字节vs图上的内容vs十六进制和二进制</p>
<p>图上的<code>0  8  16  31</code>一共有32位，指的是二进制的32位，这个<code>类型</code>是1字节，2个16进制。也就是在读数据报的时候你看到的是两个十六进制的字符。<s>然而图上很喜欢使用二进制长度来表示</s></p>
<p><code>8位二进制</code>=<code>2位十六进制</code>=<code>1字节</code></p>
<hr>
<table>
<thead>
<tr>
<th>类型字段</th>
<th>ICMP报文类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>回显应答 Echo Reply</td>
</tr>
<tr>
<td>3</td>
<td>目的不可达 Destination Unreachable</td>
</tr>
<tr>
<td>4</td>
<td>源抑制 Source Quench</td>
</tr>
<tr>
<td>5</td>
<td>路由重定向 Redirect (change a route)</td>
</tr>
<tr>
<td>8</td>
<td>回显请求 Echo Request</td>
</tr>
<tr>
<td>9</td>
<td>路由器广告 Router Advertisement</td>
</tr>
<tr>
<td>10</td>
<td>路由器请求 Router Solicitation</td>
</tr>
<tr>
<td>11</td>
<td>数据报超时 Time Exceeded for a Datagram</td>
</tr>
<tr>
<td>12</td>
<td>数据报参数问题 Parameter Problem on a Datagram</td>
</tr>
<tr>
<td>13</td>
<td>时间戳请求 Timestamp Request</td>
</tr>
<tr>
<td>14</td>
<td>时间戳应答 Timestamp Reply</td>
</tr>
<tr>
<td>15</td>
<td>信息请求（废弃） Information Request (obsolete)</td>
</tr>
<tr>
<td>16</td>
<td>信息应答（废弃） Information Reply (obsolete)</td>
</tr>
<tr>
<td>17</td>
<td>地址掩码请求 Address Mask Request</td>
</tr>
<tr>
<td>18</td>
<td>地址掩码应答 Address Mask Reply</td>
</tr>
</tbody>
</table>
<p><code>ICMP</code> 报文分为两大类</p>
<p><code>差错报告报文</code>和<code>提供信息的报文(询问报文)</code></p>
<ul>
<li>
<p>差错报告报文 (<code>Error Report Messages</code>)</p>
<ul>
<li>
<p><code>3</code> 目的不可达 <code>Destination Unreachable</code></p>
</li>
<li>
<p><code>4</code> 源抑制 <code>Source Quench</code></p>
</li>
<li>
<p><code>5</code> 路由重定向 <code>Redirect (change a route)</code></p>
</li>
<li>
<p><code>11</code> 数据报超时 <code>Time Exceeded for a Datagram</code></p>
</li>
<li>
<p><code>12</code> 数据报参数问题 <code>Parameter Problem on a Datagram</code></p>
</li>
</ul>
</li>
<li>
<p>提供信息的报文 (询问报文) (<code>Information Request/Inquiry Messages</code>)</p>
<ul>
<li>
<p><code>0</code> 回显应答 <code>Echo Reply</code></p>
</li>
<li>
<p><code>8</code> 回显请求 <code>Echo Request</code></p>
</li>
<li>
<p><code>9</code> 路由器广告 <code>Router Advertisement</code></p>
</li>
<li>
<p><code>10</code> 路由器请求 <code>Router Solicitation</code></p>
</li>
<li>
<p><code>13</code> 时间戳请求 <code>Timestamp Request</code></p>
</li>
<li>
<p><code>14</code> 时间戳应答 <code>Timestamp Reply</code></p>
</li>
<li>
<p><code>17</code> 地址掩码请求 <code>Address Mask Request</code></p>
</li>
<li>
<p><code>18</code> 地址掩码应答 <code>Address Mask Reply</code></p>
</li>
</ul>
</li>
</ul>
<p>其中<code>3</code>、<code>11</code>、<code>0</code>、<code>8</code>常用</p>
<p><code>3</code>、<code>11</code>是<code>差错报告报文</code></p>
<p><code>0</code>、<code>8</code>是<code>提供信息的报文</code></p>
<h3 id="121-几种常用icmp报文类型"><a class="markdownIt-Anchor" href="#121-几种常用icmp报文类型"></a> 1.2.1. 几种常用ICMP报文类型</h3>
<h4 id="1211-目的不可达报文3"><a class="markdownIt-Anchor" href="#1211-目的不可达报文3"></a> 1.2.1.1. 目的不可达报文（3）</h4>
<p>顾名思义，<code>目的不可达报文</code>就是目的不可达，<code>代码</code>部分进一步阐述</p>
<p><img src="/Network-Layer/eaba7cf385281339afc9f7083d44ea17-1740404253149-2.jpeg" alt></p>
<p>相当于<code>代码</code>那块就是<code>00</code>,<code>01</code>…这样的十六进制</p>
<blockquote>
<p><code>MTU</code>是指一个网络接口上能够传输的最大数据包大小。</p>
<p><code>路径最小MTU</code>影响数据在网络中的传输，尤其在路径中包含不同的网络设备时，如果路径中的任何设备不能处理过大的数据包，它就会丢弃该数据包或将其分片。</p>
<p>所以<code>“路径最小MTU发现”应用</code>可以实现 <code> MTU</code>探测 和 避免分片</p>
</blockquote>
<h4 id="1212-超时报文11"><a class="markdownIt-Anchor" href="#1212-超时报文11"></a> 1.2.1.2. 超时报文（11）</h4>
<p><code>代码</code>说明超时的性质：</p>
<p><code>00</code>  传输过程中IP <code>TTL（time to live）</code>超时</p>
<p><code>01</code>   分片重装超时</p>
<blockquote>
<p>TTL超时可用于实现路由跟踪（<code>tracert</code>）</p>
<p><em>路由跟踪的工作原理总结：</em></p>
<ul>
<li>路由跟踪工具利用<code>TTL</code>字段逐步发送数据包，每次增加<code>TTL</code>值以遍历路径。</li>
<li>每经过一个路由器，<code>TTL</code>值会减1，直到数据包的<code>TTL</code>变为0，路由器丢弃数据包并返回一个<code>ICMP</code>“时间超时”消息。</li>
<li>通过收集每个中间路由器的回应，路由跟踪工具能够显示整个路径以及每跳的延迟。</li>
</ul>
</blockquote>
<p><img src="/Network-Layer/4c779b318b1952f5114d3ac31802c576_720-1740404253150-3.jpg" alt></p>
<h4 id="1213-回应请求与应答报文-类型-8-和-0"><a class="markdownIt-Anchor" href="#1213-回应请求与应答报文-类型-8-和-0"></a> 1.2.1.3. <strong>回应请求与应答报文 (类型 8 和 0)</strong></h4>
<p>这是我们最熟悉的<code>ping</code>命令所使用的报文。</p>
<ul>
<li><strong>PING (<code>Packet InterNet Groper</code>)</strong>：用于测试两台主机之间的连通性。</li>
<li>主机A向主机B发送一个<code>ICMP</code>回显请求报文（类型8）。</li>
<li>如果主机B接收到该报文，它会回复一个<code>ICMP</code>回显应答报文（类型0）。</li>
<li><code>ping</code>是一个应用层程序直接使用网络层<code>ICMP</code>的典型例子，它绕过了传输层的<code>TCP</code>或<code>UDP</code>。</li>
</ul>
<hr>
<h2 id="13-arp-address-resolution-protocol"><a class="markdownIt-Anchor" href="#13-arp-address-resolution-protocol"></a> 1.3. ARP (Address Resolution Protocol)</h2>
<p>在任何局域网（如以太网）中，数据帧的传输最终依赖的是<strong>MAC地址（物理地址）</strong>，而不是<code>IP</code>地址。那么，当一台主机（例如 <code>192.168.1.100</code>）想要与同一网络中的另一台主机（例如 <code>192.168.1.50</code>）通信时，它如何知道对方的<code>MAC</code>地址呢？这就是<code>ARP</code>协议的作用。</p>
<p><strong>定义</strong>：<code>ARP (Address Resolution Protocol)</code>，地址解析协议。它负责将一个已知的<code>IP</code>地址（网络层地址）解析（映射）为对应的MAC地址（数据链路层地址）。</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>检查<code>ARP</code>缓存</strong>：主机 A 首先会检查自己的 <strong><code>ARP</code>缓存表</strong>，看是否已经有目标<code>IP</code>地址 <code>192.168.1.50</code> 对应的<code>MAC</code>地址记录。如果存在，则直接使用该<code>MAC</code>地址封装数据帧并发送。</li>
<li><strong>发送<code>ARP</code>请求</strong>：如果在缓存中找不到记录，主机 A 会在局域网内广播一个 <strong><code>ARP</code>请求</strong> 报文。这个报文的核心内容是：“<strong>谁的<code>IP</code>地址是 192.168.1.50？请把你的<code>MAC</code>地址告诉我。</strong>” 这个请求是广播的，意味着网络内所有设备都会收到它。</li>
<li><strong>单播<code>ARP</code>响应</strong>：网络中的所有设备都会解析这个<code>ARP</code>请求。但只有<code>IP</code>地址为 <code>192.168.1.50</code> 的主机 B 会响应。主机 B 会直接向主机 A 发送一个 <strong><code>ARP</code>响应</strong> 报文（单播），内容是：“<strong>我的<code>IP</code>地址是 <code>192.168.1.50</code>，我的<code>MAC</code>地址是<code> XX:XX:XX:XX:XX:XX</code>。</strong>”</li>
<li><strong>更新<code>ARP</code>缓存</strong>：主机 A 收到响应后，就知道了主机 B 的<code>MAC</code>地址，并将这个映射关系（<code>IP -&gt; MAC</code>）存入自己的<code>ARP</code>缓存表中，以备后续使用。然后，它就可以将数据发送给主机 B 了。</li>
</ol>
<p><strong><code>ARP</code>缓存</strong>：每个主机都维护一个ARP缓存，用于存储近期解析过的<code>IP</code>地址与<code>MAC</code>地址的对应关系。缓存条目有生命周期（通常是几分钟），过期后会被删除，以确保信息的时效性。</p>
<hr>
<h2 id="14-dhcp-dynamic-host-configuration-protocol"><a class="markdownIt-Anchor" href="#14-dhcp-dynamic-host-configuration-protocol"></a> 1.4. DHCP (Dynamic Host Configuration Protocol)</h2>
<p>当一台新设备（如笔记本电脑或手机）接入网络时，它需要一个<code>IP</code>地址才能通信。手动为每台设备配置IP地址、子网掩码、默认网关和<code>DNS</code>服务器是非常繁琐且容易出错的。<code>DHCP</code>协议就是为了自动化这个过程而设计的。</p>
<p><strong>定义</strong>：<strong>动态主机配置协议 (<code>DHCP, Dynamic Host Configuration Protocol</code>)</strong> 是一个应用层协议（基于<code>UDP</code>），允许网络中的<code>DHCP</code>服务器自动地为客户端分配IP地址及其他网络配置参数。</p>
<p><strong>工作流程 (<code>DORA</code>)</strong>：这个过程通常被称为**<code>DORA</code>**，代表四个核心步骤。</p>
<ol>
<li><strong><code>Discover</code> (发现)</strong>：客户端（新设备）在网络中<strong>广播</strong>一个 <strong><code>DHCP Discover</code></strong> 报文，试图找到可用的<code>DHCP</code>服务器。报文大意是：“<strong>我需要一个<code>IP</code>地址，网络里有<code>DHCP</code>服务器吗？</strong>”</li>
<li><strong><code>Offer</code> (提供)</strong>：所有收到<code>Discover</code>报文的<code>DHCP</code>服务器都会从自己的地址池中选择一个可用的<code>IP</code>地址，并通过一个 <strong><code>DHCP Offer</code></strong> 报文（单播或广播）提供给客户端。报文大意是：“<strong>你好，我这里有一个<code>IP</code>地址 <code>192.168.1.123</code> 可以给你用，同时还有这些其他的配置信息。</strong>”</li>
<li><strong><code>Request (请求)</code></strong>：客户端可能会收到多个<code>Offer</code>。它会选择其中一个（通常是第一个收到的），然后<strong>广播</strong>一个 <strong><code>DHCP Request</code></strong> 报文，正式请求使用这个<code>IP</code>地址。广播的目的是通知所有<code>DHCP</code>服务器（包括那些也提供了Offer的服务器），它已经做出了选择。报文大意是：“<strong>各位，我决定使用服务器X提供的<code>IP</code>地址 <code>192.168.1.123</code>。</strong>”</li>
<li><strong><code>Acknowledge (确认)</code></strong>：被选中的<code>DHCP</code>服务器会发送一个 <strong><code>DHCP ACK</code></strong> 报文，确认将该<code>IP</code>地址租借给客户端，并规定了租期。此时，客户端就可以使用这个IP地址进行网络通信了。</li>
</ol>
<hr>
<h2 id="15-路由协议-routing-protocols"><a class="markdownIt-Anchor" href="#15-路由协议-routing-protocols"></a> 1.5. 路由协议 (Routing Protocols)</h2>
<p>IP协议本身只负责数据报的转发，但它并不知道如何选择最佳路径。<strong>路由器</strong>通过运行<strong>路由协议</strong>来学习网络的拓扑结构，并创建<strong>路由表</strong>，从而做出智能的路径选择决策。路由协议主要分为两大类：</p>
<h3 id="151-内部网关协议-igp-interior-gateway-protocol"><a class="markdownIt-Anchor" href="#151-内部网关协议-igp-interior-gateway-protocol"></a> 1.5.1. 内部网关协议 (IGP - Interior Gateway Protocol)</h3>
<p>IGP在一个<strong>自治系统 (<code>AS - Autonomous System</code>)</strong> 内部交换路由信息。一个<code>AS</code>可以是一个公司、一所大学或一个互联网服务提供商（<code>ISP</code>）的网络。</p>
<ul>
<li><strong>RIP (<code>Routing Information Protocol</code>)</strong>
<ul>
<li><strong>类型</strong>：距离矢量协议 (<code>Distance-Vector</code>)。</li>
<li><strong>工作原理</strong>：RIP路由器周期性地与邻居交换整个路由表。它使用“<strong>跳数 (<code>Hop Count</code>)</strong>”作为度量值来衡量路径的好坏，即经过的路由器数量越少，路径越优。</li>
<li><strong>特点</strong>：实现简单，但有明显缺点，如最大跳数限制（15跳）、收敛速度慢、容易产生路由环路等。现在已基本被<code>OSPF</code>取代。</li>
</ul>
</li>
<li><strong>OSPF (<code>Open Shortest Path First</code>)</strong>
<ul>
<li><strong>类型</strong>：链路状态协议 (<code>Link-State</code>)。</li>
<li><strong>工作原理</strong>：<code>OSPF</code>路由器不交换路由表，而是交换<strong>链路状态通告 (<code>LSA</code>)</strong>。每个路由器都收集网络中所有的<code>LSA</code>，从而在本地构建一个完整的网络拓扑图。然后，它使用**<code>Dijkstra</code>算法**计算出到达每个目的地的最短路径。</li>
<li><strong>特点</strong>：收敛速度快，无路由环路，支持可变长子网掩码（<code>VLSM</code>），支持区域划分以实现更好的扩展性。是当今企业网络中最主流的<code>IGP</code>协议。</li>
</ul>
</li>
</ul>
<h3 id="152-外部网关协议-egp-exterior-gateway-protocol"><a class="markdownIt-Anchor" href="#152-外部网关协议-egp-exterior-gateway-protocol"></a> 1.5.2. 外部网关协议 (EGP - Exterior Gateway Protocol)</h3>
<p><code>EGP</code>用于在不同的自治系统（<code>AS</code>）之间交换路由信息，是构成整个互联网的骨架。</p>
<ul>
<li><strong>BGP (<code>Border Gateway Protocol</code>)</strong>
<ul>
<li><strong>定义</strong>：边界网关协议是目前唯一在使用的<code>EGP</code>。它不仅仅是寻找最短路径，更重要的是，它是一个“<strong>路径矢量协议</strong>”，能够根据管理员设定的策略（如费用、安全、政治因素等）来选择最佳路由。</li>
<li><strong>特点</strong>：极其稳定和可扩展，是互联网的核心路由协议，负责连接全球成千上万个自治系统。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="16-ipv6"><a class="markdownIt-Anchor" href="#16-ipv6"></a> 1.6. IPv6</h2>
<p>随着物联网的兴起和互联网的蓬勃发展，<code>IPv4</code>的地址空间（约43亿个）已完全耗尽。<code>IPv6</code>作为其继任者，提供了海量的地址空间和诸多改进。</p>
<p><strong>主要优势</strong>：</p>
<ol>
<li><strong>巨大的地址空间</strong>：<code>IPv6</code>使用128位地址，理论上可提供<code> 2^128</code> 个地址，这个数字足以满足未来数百年内任何可以想象到的需求。</li>
<li><strong>简化的首部格式</strong>：<code>IPv6</code>的首部是固定的40字节，移除了<code>IPv4</code>中不常用或冗余的字段（如<code>IHL</code>、标识、标志、片偏移、首部检验和），使得路由器处理数据包的效率更高。</li>
<li><strong>不再由路由器分片</strong>：<code>IPv6</code>要求发送方主机在发送前完成“路径<code>MTU</code>发现”（<code>PMTUD</code>），确保数据包大小不超过路径中的最小<code>MTU</code>。路由器不再进行分片，大大减轻了路由器的负担。</li>
<li><strong>增强的安全性</strong>：<code>IPsec</code>（IP安全协议）被设计为<code>IPv6</code>的强制组成部分（尽管后来变为可选），为网络层提供了端到端的加密和认证，安全性远超<code>IPv4</code>。</li>
<li><strong>支持无状态地址自动配置 (<code>SLAAC</code>)</strong>：<code>IPv6</code>主机可以根据路由器通告的前缀和自身的<code>MAC</code>地址等信息，自动生成全局唯一的<code>IP</code>地址，无需<code>DHCP</code>服务器介入即可上网。</li>
<li><strong>改进的邻居发现协议 (<code>NDP</code>)</strong>：<code>IPv6</code>使用<strong>邻居发现协议 (<code>NDP</code>)</strong>，它基于<code>ICMPv6</code>，取代了<code>IPv4</code>中的<code>ARP</code>和<code>ICMP</code>路由器发现等功能，实现了地址解析、路由器发现、重复地址检测（<code>DAD</code>）等，更加高效和强大。</li>
</ol>
<hr>
<h2 id="17-igmp-internet-group-management-protocol"><a class="markdownIt-Anchor" href="#17-igmp-internet-group-management-protocol"></a> 1.7. IGMP (Internet Group Management Protocol)</h2>
<p>当数据需要发送给一组特定的、感兴趣的主机而不是单个主机（单播）或所有主机（广播）时，就需要<strong>组播 (<code>Multicast</code>)</strong>。<code>IGMP</code>协议就是用于管理这种组播组成员关系的。</p>
<p><strong>定义</strong>：IGMP (<code>Internet Group Management Protocol</code>)，因特网组管理协议。它允许主机通知其本地路由器，表示自己希望加入或离开某个特定的组播组。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li><strong>加入组</strong>：当一个主机上的某个应用希望接收特定组播组（例如一个视频流）的数据时，主机会向其本地路由器发送一个<code>IGMP</code><strong>成员关系报告</strong>报文。</li>
<li><strong>维护关系</strong>：路由器会周期性地发送<code>IGMP</code><strong>查询</strong>报文，询问本地网络上是否还有成员对某个组播组感兴趣。仍在组内的成员会回复报告报文。</li>
<li><strong>离开组</strong>：当主机不再希望接收数据时，它会发送一个<code>IGMP</code><strong>离开组</strong>报文。</li>
</ul>
<p><code>IGMP</code>只负责在主机和本地路由器之间进行通信。路由器之间则需要运行专门的组播路由协议（如<code>PIM</code>）来构建组播数据的分发路径。</p>
<hr>
<h2 id="18-nat-network-address-translation"><a class="markdownIt-Anchor" href="#18-nat-network-address-translation"></a> 1.8. NAT (Network Address Translation)</h2>
<p><code>NAT</code>是为了延缓<code>IPv4</code>地址耗尽而设计出的一种关键技术。它允许一个机构内部的众多计算机使用<strong>私有<code>IP</code>地址</strong>上网，但在与外部互联网通信时，共享一个或少数几个<strong>公有<code>IP</code>地址</strong>。</p>
<p><strong>定义</strong>：<strong>网络地址转换 (<code>NAT</code>)</strong> 工作在路由器或防火墙上，负责在私有网络和公有网络之间转换<code>IP</code>数据报的源/目的地址和端口号。</p>
<p><strong>私有<code>IP</code>地址段</strong> (不会在公网路由):</p>
<ul>
<li><code>10.0.0.0</code> 到 <code>10.255.255.255</code> (A类)</li>
<li><code>172.16.0.0</code> 到 <code>172.31.255.255</code> (B类)</li>
<li><code>192.168.0.0</code> 到 <code>192.168.255.255</code> (C类)</li>
</ul>
<p><strong>工作原理与类型</strong>：</p>
<ol>
<li><strong>静态NAT (<code>Static NAT</code>)</strong>：
<ul>
<li>将一个私有<code>IP</code>地址<strong>一对一</strong>地映射到一个公有IP地址。</li>
<li>主要用于内部服务器（如Web服务器）需要被外部网络稳定访问的场景。</li>
</ul>
</li>
<li><strong>动态NAT (<code>Dynamic NAT</code>)</strong>：
<ul>
<li>维护一个公有<code>IP</code>地址池。当内部主机需要访问互联网时，从地址池中<strong>临时分配</strong>一个未使用的公有<code>IP</code>地址给它。</li>
<li>当通信结束时，该公有<code>IP</code>地址被回收，可供其他主机使用。</li>
</ul>
</li>
<li><strong>PAT (<code>Port Address Translation</code>) / NAPT</strong>：
<ul>
<li>这是目前<strong>最常用</strong>的<code>NAT</code>形式，也称为<code>NAPT</code>（网络地址端口转换）。它将多个私有<code>IP</code>地址映射到<strong>同一个公有IP地址</strong>的不同<strong>端口</strong>上。</li>
<li><strong>流程</strong>：当内部主机 <code>192.168.1.100 </code>使用端口 <code>50000 </code>访问外部服务器时，<code>NAT</code>路由器会将源地址和端口转换为 (公有IP, 新端口号)，例如 (<code>202.100.1.1</code>, <code>60001</code>)，并记录这个映射关系。当外部服务器响应数据到 (<code>202.100.1.1</code>, <code>60001</code>) 时，路由器根据记录将数据包的目的地址和端口改回 (<code>192.168.1.100</code>, <code>50000</code>)，并发送给内部主机。</li>
<li><strong>优点</strong>：极大地节约了公有<code>IP</code>地址，仅用一个公有<code>IP</code>就能让成百上千台设备同时上网。</li>
<li><strong>缺点</strong>：破坏了端到端的连接模型，可能导致某些<code>P2P</code>应用或<code>VoIP</code>协议出现问题。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="19-ipsec-internet-protocol-security"><a class="markdownIt-Anchor" href="#19-ipsec-internet-protocol-security"></a> 1.9. IPsec (Internet Protocol Security)</h2>
<p><strong><code>IPsec</code></strong> 是一套协议簇，用于在网络层为<code>IP</code>通信提供高质量、可互操作的、基于密码学的安全保障。它能提供数据来源认证、数据完整性、数据机密性（加密）和防重放攻击等服务，是构建**<code>VPN</code> (虚拟专用网络)** 的核心技术。</p>
<p><strong>两种工作模式</strong>：</p>
<ol>
<li><strong>传输模式 (<code>Transport Mode</code>)</strong>：
<ul>
<li><strong>工作方式</strong>：只对IP数据报的<strong>数据部分（<code>Payload</code>）</strong> 进行加密或认证。原始的IP头部保持不变，只插入了<code>IPsec</code>头部。</li>
<li><strong>用途</strong>：主要用于两台主机之间的<strong>端到端</strong>安全通信。</li>
</ul>
</li>
<li><strong>隧道模式 (<code>Tunnel Mode</code>)</strong>：
<ul>
<li><strong>工作方式</strong>：将<strong>整个原始<code>IP</code>数据报（包括头部和数据）</strong> 都进行加密和认证，然后将其封装在一个新的IP数据报中。</li>
<li><strong>用途</strong>：主要用于两个网络（如公司总部和分部）之间的<strong>网关到网关</strong>安全通信，由网络边缘的<code>VPN</code>网关来处理。这是构建<code>VPN</code>最常见的方式。</li>
</ul>
</li>
</ol>
<p><strong>核心协议</strong>：</p>
<ul>
<li><strong>AH (<code>Authentication Header</code>)</strong>：只提供<strong>数据完整性</strong>和<strong>身份验证</strong>，但不提供加密。它确保数据在传输中未被篡改，但传输内容是明文的。</li>
<li><strong>ESP (<code>Encapsulating Security Payload</code>)</strong>：提供<strong>数据完整性</strong>、<strong>身份验证</strong>和<strong>数据机密性（加密）</strong>。这是目前应用最广泛的IPsec协议。</li>
</ul>
<hr>
<h2 id="110-vrrp-virtual-router-redundancy-protocol"><a class="markdownIt-Anchor" href="#110-vrrp-virtual-router-redundancy-protocol"></a> 1.10. VRRP (Virtual Router Redundancy Protocol)</h2>
<p>在局域网中，如果作为默认网关的路由器发生故障，整个网络的主机将无法访问外部网络，这形成了一个<strong>单点故障</strong>。<code>VRRP</code>就是为了解决这个问题而设计的网关冗余协议。</p>
<p><strong>定义</strong>：<strong>虚拟路由器冗余协议 (<code>VRRP</code>)</strong> 是一种容错协议，可以将多台物理路由器组织成一个“<strong>虚拟路由器</strong>”，从而对外提供一个高可用的默认网关。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>虚拟路由器</strong>：在一个<code>VRRP</code>组中，多台物理路由器共享一个<strong>虚拟<code>IP</code>地址</strong>和<strong>虚拟<code>MAC</code>地址</strong>。网络中的所有客户端都将这个虚拟<code>IP</code>地址配置为它们的默认网关。</li>
<li><strong><code>Master</code>和<code>Backup</code></strong>：在任何时刻，<code>VRRP</code>组中只有一台路由器处于 <strong><code>Master </code>(主)</strong> 状态，它实际拥有虚拟IP地址并负责转发数据包。组内其他路由器则处于 <strong><code>Backup</code> (备)</strong> 状态。</li>
<li><strong>心跳检测</strong>：<code>Master</code>路由器会周期性地发送<code>VRRP</code>通告报文（心跳），向<code>Backup</code>路由器宣告自己处于活动状态。</li>
<li><strong>故障切换</strong>：如果<code>Backup</code>路由器在一定时间内没有收到<code>Master</code>的心跳报文，它会认为<code>Master</code>已经出现故障。此时，优先级最高的<code>Backup</code>路由器会自动切换为新的<code>Master</code>，接管虚拟<code>IP</code>地址和<code>MAC</code>地址，并开始转发数据。</li>
<li><strong>无缝切换</strong>：这个切换过程对客户端是完全透明的，客户端无需进行任何更改，从而保证了网络连接的连续性。</li>
</ol>
<hr>
<h2 id="111-mpls-multiprotocol-label-switching"><a class="markdownIt-Anchor" href="#111-mpls-multiprotocol-label-switching"></a> 1.11. MPLS (Multiprotocol Label Switching)</h2>
<p><code>MPLS</code>是一种高性能的电信级网络技术，它在传统的IP路由（第三层）和数据链路层交换（第二层）之间工作，常被称为“<strong>2.5层</strong>”技术。</p>
<p><strong>定义</strong>：<strong>多协议标签交换 (<code>MPLS</code>)</strong> 通过给数据包预先分配简短、固定长度的“<strong>标签（<code>Label</code>）</strong>”，并根据标签进行转发，而不是像传统路由那样在每一跳都查找复杂的IP路由表。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>标签分发</strong>：<code>MPLS</code>网络中的路由器（称为<code>LSR</code> - 标签交换路由器）会通过<code>LDP</code>（标签分发协议）等协议，预先为网络中的IP前缀（路由）建立标签映射关系，形成<strong>标签转发信息库 (<code>LFIB</code>)</strong>。</li>
<li><strong>入口打标 (<code>Push</code>)</strong>：当一个IP数据包进入<code>MPLS</code>网络时，入口路由器（<code>Ingress LER</code>）会进行一次常规的<code>IP</code>路由查找，然后给这个数据包压入一个或多个<code>MPLS</code>标签，形成一个带标签的数据包。</li>
<li><strong>标签交换 (<code>Swap</code>)</strong>：在<code>MPLS</code>网络内部，核心的<code>LSR</code>路由器不再查看<code>IP</code>头部。它们只需读取最外层的标签，在<code>LFIB</code>中进行极速查找，然后“交换”（替换）标签，并将数据包转发到下一个<code>LSR</code>。</li>
<li><strong>出口弹标 (<code>Pop</code>)</strong>：当数据包到达<code>MPLS</code>网络的出口路由器（<code>Egress LER</code>）时，标签被移除（弹出），恢复成原始的<code>IP</code>数据包，然后继续进行标准的<code>IP</code>转发。</li>
</ol>
<p><strong>主要优势</strong>：</p>
<ul>
<li><strong>高速转发</strong>：基于标签的精确匹配交换比基于<code>IP</code>地址的最长前缀匹配查找要快得多。</li>
<li><strong>流量工程 (<code>Traffic Engineering</code>)</strong>：<code>MPLS</code>可以预先设定数据流的路径（建立<code>LSP</code> - 标签交换路径），而不必完全遵循<code>IGP</code>计算出的最短路径。这使得网络管理员可以精细地控制流量，以优化带宽利用率或绕过拥塞点。</li>
<li><strong>VPN支持</strong>：<code>MPLS</code>是构建大规模、高性能<code>VPN</code>（特别是<code>MPLS</code> <code>L3VPN</code>）的基础技术，被全球各大<code>ISP</code>广泛采用。</li>
</ul>
<p>仍在咕咕咕中</p>
]]></content>
      <categories>
        <category>Computer Networks</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-algorithm</title>
    <url>/Python-algorithm/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 核心数据类型</a>
<ul>
<li><a href="#11-%E6%95%B4%E6%95%B0-int">1.1. 整数 (int)</a></li>
<li><a href="#12-%E6%B5%AE%E7%82%B9%E6%95%B0-float">1.2. 浮点数 (float)</a></li>
<li><a href="#13-%E5%B8%83%E5%B0%94%E5%80%BC-bool">1.3. 布尔值 (bool)</a></li>
<li><a href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2-str">1.4. 字符串 (str)</a></li>
</ul>
</li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2. 核心数据结构</a>
<ul>
<li><a href="#21-%E5%88%97%E8%A1%A8-list">2.1. 列表 (List)</a>
<ul>
<li><a href="#211-%E5%88%9B%E5%BB%BA">2.1.1. 创建</a></li>
<li><a href="#212-%E8%AE%BF%E9%97%AE">2.1.2. 访问</a></li>
<li><a href="#213-%E5%88%87%E7%89%87">2.1.3. 切片</a></li>
<li><a href="#214-%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C">2.1.4. 列表的常用函数和操作</a></li>
<li><a href="#215-%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.1.5. 列表的常用方法</a></li>
</ul>
</li>
<li><a href="#22-%E5%AD%97%E5%85%B8-dictionary--hash-map">2.2. 字典 (Dictionary / Hash Map)</a>
<ul>
<li><a href="#221-%E5%88%9B%E5%BB%BA">2.2.1. 创建</a></li>
<li><a href="#222-%E6%93%8D%E4%BD%9C">2.2.2. 操作</a></li>
</ul>
</li>
<li><a href="#23-%E9%9B%86%E5%90%88-set">2.3. 集合 (Set)</a>
<ul>
<li><a href="#231-%E5%88%9B%E5%BB%BA">2.3.1. 创建</a></li>
<li><a href="#232-%E6%93%8D%E4%BD%9C">2.3.2. 操作</a></li>
</ul>
</li>
<li><a href="#24-%E5%AD%97%E7%AC%A6%E4%B8%B2-string">2.4. 字符串 (String)</a>
<ul>
<li><a href="#241-%E6%93%8D%E4%BD%9C">2.4.1. 操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E6%8E%A7%E5%88%B6%E6%B5%81%E4%B8%8E%E9%80%BB%E8%BE%91">3. 控制流与逻辑</a>
<ul>
<li><a href="#31-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADifelifelse">3.1. 条件判断 (if/elif/else)</a></li>
<li><a href="#32-%E5%BE%AA%E7%8E%AF">3.2. 循环</a>
<ul>
<li><a href="#321-for%E5%BE%AA%E7%8E%AF">3.2.1. for循环</a></li>
<li><a href="#322-while%E5%BE%AA%E7%8E%AF">3.2.2. while 循环</a></li>
</ul>
</li>
<li><a href="#33-%E5%87%BD%E6%95%B0">3.3. 函数</a></li>
</ul>
</li>
<li><a href="#4-%E9%80%9A%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">4. 通用内置函数</a>
<ul>
<li><a href="#41-lenobj">4.1. len(obj)</a></li>
<li><a href="#42-sumiterable">4.2. sum(iterable)</a></li>
<li><a href="#43-miniterablemaxiterable">4.3. min(iterable) / max(iterable)</a></li>
<li><a href="#44-sortediterable">4.4. sorted(iterable)</a></li>
<li><a href="#45-absx">4.5. abs(x)</a></li>
<li><a href="#46-rangestart-stop-step">4.6. range(start, stop, step)</a></li>
<li><a href="#47-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">4.7. 类型转换函数</a>
<ul>
<li><a href="#471-intx">4.7.1. int(x)</a></li>
<li><a href="#472-strobj">4.7.2. str(obj)</a></li>
<li><a href="#473-listiterable">4.7.3. list(iterable)</a></li>
<li><a href="#474-setiterable">4.7.4. set(iterable)</a></li>
</ul>
</li>
<li><a href="#48-enumerateiterable">4.8. enumerate(iterable)</a></li>
<li><a href="#49-zip">4.9. zip()</a></li>
<li><a href="#410-mapfunction-iterable">4.10. map(function, iterable)</a></li>
</ul>
</li>
<li><a href="#5-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95">5. 核心数据类型方法</a>
<ul>
<li><a href="#51-%E5%AD%97%E7%AC%A6%E4%B8%B2-str">5.1. 字符串 (str)</a>
<ul>
<li><a href="#511-strsplitsep">5.1.1. str.split(sep)</a></li>
<li><a href="#512-sepjoinlist">5.1.2. sep.join(list)</a></li>
<li><a href="#513-strfindsub">5.1.3. str.find(sub)</a></li>
<li><a href="#514-strcountsub">5.1.4. str.count(sub)</a></li>
<li><a href="#515-strstrip">5.1.5. str.strip()</a></li>
<li><a href="#516-strisdigit">5.1.6. str.isdigit()</a></li>
</ul>
</li>
<li><a href="#52-%E5%88%97%E8%A1%A8-list">5.2. 列表 (list)</a>
<ul>
<li><a href="#521-listindexx-start-end">5.2.1. list.index(x[, start[, end]])</a></li>
<li><a href="#522-listappendx">5.2.2. list.append(x)</a></li>
<li><a href="#523-listpopi">5.2.3. list.pop(i)</a></li>
<li><a href="#524-listsortcmpnone-keynone-reversefalse">5.2.4. list.sort(cmp=None, key=None, reverse=False)</a></li>
<li><a href="#525-listreverse">5.2.5. list.reverse()</a></li>
<li><a href="#526-listremoveobj">5.2.6. list.remove(obj)</a></li>
</ul>
</li>
<li><a href="#53-%E5%AD%97%E5%85%B8-dict">5.3. 字典 (dict)</a>
<ul>
<li><a href="#531-dictgetkey-default">5.3.1. dict.get(key, default)</a></li>
<li><a href="#532-dictkeys">5.3.2. dict.keys()</a></li>
<li><a href="#533-dictvalues">5.3.3. dict.values()</a></li>
<li><a href="#534-dictitems">5.3.4. dict.items()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-collections">6. Collections</a>
<ul>
<li><a href="#defaultdict">defaultdict</a></li>
</ul>
</li>
</ul>
</details>
<h2 id="1-核心数据类型"><a class="markdownIt-Anchor" href="#1-核心数据类型"></a> 1. 核心数据类型</h2>
<h3 id="11-整数-int"><a class="markdownIt-Anchor" href="#11-整数-int"></a> 1.1. 整数 (int)</h3>
<p>x = 10, y = -5</p>
<h3 id="12-浮点数-float"><a class="markdownIt-Anchor" href="#12-浮点数-float"></a> 1.2. 浮点数 (float)</h3>
<p>pi = 3.14</p>
<h3 id="13-布尔值-bool"><a class="markdownIt-Anchor" href="#13-布尔值-bool"></a> 1.3. 布尔值 (bool)</h3>
<p>flag = True, flag = False</p>
<h3 id="14-字符串-str"><a class="markdownIt-Anchor" href="#14-字符串-str"></a> 1.4. 字符串 (str)</h3>
<p>s = “hello world”</p>
<p><code>a, b = b, a</code> 交换变量</p>
<h2 id="2-核心数据结构"><a class="markdownIt-Anchor" href="#2-核心数据结构"></a> 2. 核心数据结构</h2>
<h3 id="21-列表-list"><a class="markdownIt-Anchor" href="#21-列表-list"></a> 2.1. 列表 (List)</h3>
<h4 id="211-创建"><a class="markdownIt-Anchor" href="#211-创建"></a> 2.1.1. 创建</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">ans = []</span><br></pre></td></tr></table></figure>
<h4 id="212-访问"><a class="markdownIt-Anchor" href="#212-访问"></a> 2.1.2. 访问</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first = nums[<span class="number">0</span>] <span class="comment"># 正向索引，从0开始</span></span><br><span class="line"></span><br><span class="line">last = nums[-<span class="number">1</span>] <span class="comment"># 反向索引，从-1开始</span></span><br></pre></td></tr></table></figure>
<h4 id="213-切片"><a class="markdownIt-Anchor" href="#213-切片"></a> 2.1.3. 切片</h4>
<p>创建子列表，语法 [start:stop:step]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">copy = nums[:] <span class="comment"># 创建列表浅拷贝</span></span><br><span class="line"></span><br><span class="line">reverse = nums[::-<span class="number">1</span>] <span class="comment"># 翻转列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="214-列表的常用函数和操作"><a class="markdownIt-Anchor" href="#214-列表的常用函数和操作"></a> 2.1.4. 列表的常用函数和操作</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(nums)          <span class="comment"># 获取长度</span></span><br><span class="line"><span class="built_in">sum</span>(nums)          <span class="comment"># 对数字列表求和</span></span><br><span class="line"><span class="built_in">min</span>(nums) / <span class="built_in">max</span>(nums) <span class="comment"># 求最值</span></span><br><span class="line"><span class="built_in">sorted</span>(nums)       <span class="comment"># 返回一个排好序的新列表</span></span><br><span class="line">value <span class="keyword">in</span> nums      <span class="comment"># 成员检查 (O(n))</span></span><br></pre></td></tr></table></figure>
<h4 id="215-列表的常用方法"><a class="markdownIt-Anchor" href="#215-列表的常用方法"></a> 2.1.5. 列表的常用方法</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.append(value)   <span class="comment"># 在末尾添加</span></span><br><span class="line">nums.pop(index)      <span class="comment"># 删除并返回元素</span></span><br><span class="line">nums.sort()          <span class="comment"># 原地排序</span></span><br><span class="line">nums.reverse()       <span class="comment"># 原地反转</span></span><br><span class="line">nums.index(value)    <span class="comment"># 查找索引</span></span><br></pre></td></tr></table></figure>
<h3 id="22-字典-dictionary-hash-map"><a class="markdownIt-Anchor" href="#22-字典-dictionary-hash-map"></a> 2.2. 字典 (Dictionary / Hash Map)</h3>
<p>字典是无序的键值对 (key: value) 集合。它通过哈希表实现，查找、插入、删除的平均时间复杂度为 O(1)</p>
<h4 id="221-创建"><a class="markdownIt-Anchor" href="#221-创建"></a> 2.2.1. 创建</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lookup = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line">empty_dict = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="222-操作"><a class="markdownIt-Anchor" href="#222-操作"></a> 2.2.2. 操作</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = lookup[<span class="string">&#x27;name&#x27;</span>] <span class="comment"># 不存在会报错</span></span><br><span class="line">lookup[<span class="string">&#x27;id&#x27;</span>] = <span class="number">456</span> <span class="comment"># 添加新的键值对</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;id&#x27;</span> <span class="keyword">in</span> lookup <span class="comment"># 检查键是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> lookup[<span class="string">&#x27;id&#x27;</span>] <span class="comment"># 删除键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> lookup.keys() <span class="comment"># 遍历所有键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> lookup.values() <span class="comment"># 遍历所有值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> lookup.items() <span class="comment"># 同时遍历键和值</span></span><br></pre></td></tr></table></figure>
<h3 id="23-集合-set"><a class="markdownIt-Anchor" href="#23-集合-set"></a> 2.3. 集合 (Set)</h3>
<p>集合是无序、不重复的元素集合。其底层也是哈希表，因此<strong>检查一个元素是否存在</strong>的速度极快 (O(1))</p>
<h4 id="231-创建"><a class="markdownIt-Anchor" href="#231-创建"></a> 2.3.1. 创建</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unique_nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">empty_set = <span class="built_in">set</span>() <span class="comment"># 不可以使用&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">from_list = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]) <span class="comment"># -&gt; &#123;1, 2, 3&#125; (天然去重)</span></span><br></pre></td></tr></table></figure>
<h4 id="232-操作"><a class="markdownIt-Anchor" href="#232-操作"></a> 2.3.2. 操作</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unique_nums.add(<span class="number">4</span>) <span class="comment"># 添加元素</span></span><br><span class="line">unique_nums.remove(<span class="number">3</span>) <span class="comment"># 删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> unique_nums <span class="comment"># 检查成员是否存在</span></span><br><span class="line"></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集 (intersection) - 两个集合中都有的元素</span></span><br><span class="line">intersection = set1 &amp; set2  <span class="comment"># -&gt; &#123;3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集 (union) - 两个集合中所有的元素</span></span><br><span class="line">union = set1 | set2         <span class="comment"># -&gt; &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集 (difference) - 在 set1 中但不在 set2 中的元素</span></span><br><span class="line">difference = set1 - set2    <span class="comment"># -&gt; &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="24-字符串-string"><a class="markdownIt-Anchor" href="#24-字符串-string"></a> 2.4. 字符串 (String)</h3>
<p>不可变的文本序列</p>
<h4 id="241-操作"><a class="markdownIt-Anchor" href="#241-操作"></a> 2.4.1. 操作</h4>
<p><strong>切片和索引</strong>与<strong>列表</strong>完全相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_str = str1 + str2</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; &#x27;</span>.join([<span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;222&#x27;</span>, <span class="string">&#x27;333&#x27;</span>]) <span class="comment"># -&gt; &quot;111 222 333&quot; (将列表连接成字符串)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span>.split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># -&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] (将字符串分割成列表)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-控制流与逻辑"><a class="markdownIt-Anchor" href="#3-控制流与逻辑"></a> 3. 控制流与逻辑</h2>
<h3 id="31-条件判断-ifelifelse"><a class="markdownIt-Anchor" href="#31-条件判断-ifelifelse"></a> 3.1. 条件判断 (if/elif/else)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> score &gt; <span class="number">90</span>:</span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> score &gt; <span class="number">80</span>:</span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>三元运算符 (Ternary Operator)</strong>: result = “Even” if num % 2 == 0 else “Odd”</p>
<h3 id="32-循环"><a class="markdownIt-Anchor" href="#32-循环"></a> 3.2. 循环</h3>
<h4 id="321-for循环"><a class="markdownIt-Anchor" href="#321-for循环"></a> 3.2.1. for循环</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 range() 进行固定次数的循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="comment"># 循环 0, 1, 2, 3, 4</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 enumerate</span></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="322-while-循环"><a class="markdownIt-Anchor" href="#322-while-循环"></a> 3.2.2. while 循环</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="33-函数"><a class="markdownIt-Anchor" href="#33-函数"></a> 3.3. 函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">parameter1, parameter2</span>):</span><br><span class="line">    <span class="comment"># 1. 初始化变量</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 核心逻辑</span></span><br><span class="line">    <span class="comment"># ... (使用循环、判断等)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="4-通用内置函数"><a class="markdownIt-Anchor" href="#4-通用内置函数"></a> 4. 通用内置函数</h2>
<h3 id="41-lenobj"><a class="markdownIt-Anchor" href="#41-lenobj"></a> 4.1. len(obj)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">length = <span class="built_in">len</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>])      <span class="comment"># -&gt; 3</span></span><br><span class="line">str_len = <span class="built_in">len</span>(<span class="string">&quot;hello&quot;</span>)       <span class="comment"># -&gt; 5</span></span><br><span class="line">dict_len = <span class="built_in">len</span>(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;) <span class="comment"># -&gt; 2</span></span><br></pre></td></tr></table></figure>
<h3 id="42-sumiterable"><a class="markdownIt-Anchor" href="#42-sumiterable"></a> 4.2. sum(iterable)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 适用于数字组成的列表、元组等</span></span><br><span class="line">total = <span class="built_in">sum</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])    <span class="comment"># -&gt; 60</span></span><br></pre></td></tr></table></figure>
<h3 id="43-miniterable-maxiterable"><a class="markdownIt-Anchor" href="#43-miniterable-maxiterable"></a> 4.3. min(iterable) / max(iterable)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 适用于可比较元素组成的序列</span></span><br><span class="line">min_val = <span class="built_in">min</span>([<span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>])  <span class="comment"># -&gt; 1</span></span><br><span class="line">max_val = <span class="built_in">max</span>([<span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>])  <span class="comment"># -&gt; 9</span></span><br><span class="line">min_char = <span class="built_in">min</span>(<span class="string">&quot;database&quot;</span>)   <span class="comment"># -&gt; &#x27;a&#x27; (按字母序)</span></span><br></pre></td></tr></table></figure>
<h3 id="44-sortediterable"><a class="markdownIt-Anchor" href="#44-sortediterable"></a> 4.4. sorted(iterable)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回一个全新的排好序的列表，不改变原对象</span></span><br><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">new_sorted_list = <span class="built_in">sorted</span>(nums) <span class="comment"># -&gt; [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># print(nums) 仍然是 [3, 1, 4, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字符串排序会得到字符列表</span></span><br><span class="line">sorted_chars = <span class="built_in">sorted</span>(<span class="string">&quot;bca&quot;</span>) <span class="comment"># -&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="45-absx"><a class="markdownIt-Anchor" href="#45-absx"></a> 4.5. abs(x)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">abs</span>(-<span class="number">5</span>) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h3 id="46-rangestart-stop-step"><a class="markdownIt-Anchor" href="#46-rangestart-stop-step"></a> 4.6. range(start, stop, step)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># range(stop)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># -&gt; 依次输出 0, 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range(start, stop)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># -&gt; 依次输出 1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range(start, stop, step)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># -&gt; 依次输出 0, 2, 4</span></span><br></pre></td></tr></table></figure>
<h3 id="47-类型转换函数"><a class="markdownIt-Anchor" href="#47-类型转换函数"></a> 4.7. 类型转换函数</h3>
<h4 id="471-intx"><a class="markdownIt-Anchor" href="#471-intx"></a> 4.7.1. int(x)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>) <span class="comment"># -&gt; 123 </span></span><br></pre></td></tr></table></figure>
<h4 id="472-strobj"><a class="markdownIt-Anchor" href="#472-strobj"></a> 4.7.2. str(obj)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">str</span>(<span class="number">123</span>) <span class="comment"># -&gt; &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="473-listiterable"><a class="markdownIt-Anchor" href="#473-listiterable"></a> 4.7.3. list(iterable)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>)) <span class="comment"># -&gt; [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<h4 id="474-setiterable"><a class="markdownIt-Anchor" href="#474-setiterable"></a> 4.7.4. set(iterable)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_set=<span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># -&gt; &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="48-enumerateiterable"><a class="markdownIt-Anchor" href="#48-enumerateiterable"></a> 4.8. enumerate(iterable)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在循环中同时需要下标和元素的最佳方式</span></span><br><span class="line">letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(letters):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;index&#125;</span>, Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># -&gt; Index: 0, Value: a</span></span><br><span class="line"><span class="comment"># -&gt; Index: 1, Value: b</span></span><br><span class="line"><span class="comment"># -&gt; Index: 2, Value: c</span></span><br></pre></td></tr></table></figure>
<h3 id="49-zip"><a class="markdownIt-Anchor" href="#49-zip"></a> 4.9. zip()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多个列表/元组等并行打包遍历</span></span><br><span class="line">names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">scores = [<span class="number">95</span>, <span class="number">88</span>]</span><br><span class="line"><span class="keyword">for</span> name, score <span class="keyword">in</span> <span class="built_in">zip</span>(names, scores):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># -&gt; Alice: 95</span></span><br><span class="line"><span class="comment"># -&gt; Bob: 88 </span></span><br></pre></td></tr></table></figure>
<h3 id="410-mapfunction-iterable"><a class="markdownIt-Anchor" href="#410-mapfunction-iterable"></a> 4.10. map(function, iterable)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将函数应用于序列的每个元素，返回一个迭代器</span></span><br><span class="line">str_nums = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br><span class="line"><span class="comment"># 需要用 list() 来获取所有结果</span></span><br><span class="line">int_nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, str_nums)) <span class="comment"># -&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line = <span class="string">&quot;10 20 30&quot;</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split())) <span class="comment"># -&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure>
<h2 id="5-核心数据类型方法"><a class="markdownIt-Anchor" href="#5-核心数据类型方法"></a> 5. 核心数据类型方法</h2>
<h3 id="51-字符串-str"><a class="markdownIt-Anchor" href="#51-字符串-str"></a> 5.1. 字符串 (str)</h3>
<h4 id="511-strsplitsep"><a class="markdownIt-Anchor" href="#511-strsplitsep"></a> 5.1.1. str.split(sep)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">words = s.split(<span class="string">&#x27; &#x27;</span>)     <span class="comment"># -&gt; [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line"></span><br><span class="line">csv = <span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">items = csv.split(<span class="string">&#x27;,&#x27;</span>)   <span class="comment"># -&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="512-sepjoinlist"><a class="markdownIt-Anchor" href="#512-sepjoinlist"></a> 5.1.2. sep.join(list)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line">s = <span class="string">&quot; &quot;</span>.join(words)      <span class="comment"># -&gt; &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">chars = [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">result = <span class="string">&quot;-&quot;</span>.join(chars) <span class="comment"># -&gt; &quot;p-y&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="513-strfindsub"><a class="markdownIt-Anchor" href="#513-strfindsub"></a> 5.1.3. str.find(sub)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="comment"># 找不到时返回 -1</span></span><br><span class="line">index1 = s.find(<span class="string">&#x27;na&#x27;</span>)    <span class="comment"># -&gt; 2 (首次出现的位置)</span></span><br><span class="line">index2 = s.find(<span class="string">&#x27;z&#x27;</span>)     <span class="comment"># -&gt; -1</span></span><br></pre></td></tr></table></figure>
<h4 id="514-strcountsub"><a class="markdownIt-Anchor" href="#514-strcountsub"></a> 5.1.4. str.count(sub)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;banana&quot;</span></span><br><span class="line">count = s.count(<span class="string">&#x27;a&#x27;</span>)     <span class="comment"># -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="515-strstrip"><a class="markdownIt-Anchor" href="#515-strstrip"></a> 5.1.5. str.strip()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;  hello  &quot;</span></span><br><span class="line">clean_s = s.strip()      <span class="comment"># -&gt; &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="516-strisdigit"><a class="markdownIt-Anchor" href="#516-strisdigit"></a> 5.1.6. str.isdigit()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;123&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;a123&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.isdigit())      <span class="comment"># -&gt; True</span></span><br><span class="line"><span class="built_in">print</span>(s2.isdigit())      <span class="comment"># -&gt; False</span></span><br></pre></td></tr></table></figure>
<h3 id="52-列表-list"><a class="markdownIt-Anchor" href="#52-列表-list"></a> 5.2. 列表 (list)</h3>
<h4 id="521-listindexx-start-end"><a class="markdownIt-Anchor" href="#521-listindexx-start-end"></a> 5.2.1. list.index(x[, start[, end]])</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aList = [<span class="number">123</span>, <span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">index1 = aList.index( <span class="string">&#x27;xyz&#x27;</span> )   <span class="comment"># 1</span></span><br><span class="line">index2 = aList.index( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="number">3</span> ) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="522-listappendx"><a class="markdownIt-Anchor" href="#522-listappendx"></a> 5.2.2. list.append(x)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums.append(<span class="number">3</span>)           <span class="comment"># nums 变为 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="523-listpopi"><a class="markdownIt-Anchor" href="#523-listpopi"></a> 5.2.3. list.pop(i)</h4>
<p>时间复杂度为O(n),list模拟队列效率很低</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">last = nums.pop()        <span class="comment"># -&gt; 30, nums 变为 [10, 20]</span></span><br><span class="line"><span class="comment"># 删除并返回指定索引的元素</span></span><br><span class="line">first = nums.pop(<span class="number">0</span>)      <span class="comment"># -&gt; 10, nums 变为 [20]</span></span><br></pre></td></tr></table></figure>
<h4 id="524-listsortcmpnone-keynone-reversefalse"><a class="markdownIt-Anchor" href="#524-listsortcmpnone-keynone-reversefalse"></a> 5.2.4. list.sort(cmp=None, key=None, reverse=False)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">nums.sort()              <span class="comment"># nums 本身变为 [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序排序</span></span><br><span class="line">nums.sort(reverse=<span class="literal">True</span>)  <span class="comment"># nums 变为 [4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表的第二个元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">takeSecond</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 指定第二个元素排序</span></span><br><span class="line">random.sort(key=takeSecond) <span class="comment"># 排序列表： [(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="525-listreverse"><a class="markdownIt-Anchor" href="#525-listreverse"></a> 5.2.5. list.reverse()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">nums.reverse()           <span class="comment"># nums 变为 [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<h4 id="526-listremoveobj"><a class="markdownIt-Anchor" href="#526-listremoveobj"></a> 5.2.6. list.remove(obj)</h4>
<p>删掉第一个匹配的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>]  </span><br><span class="line">list1.remove(<span class="string">&#x27;Taobao&#x27;</span>)  <span class="comment"># [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Baidu&#x27;]</span></span><br><span class="line">list1.remove(<span class="string">&#x27;Baidu&#x27;</span>)   <span class="comment"># [&#x27;Google&#x27;, &#x27;Runoob&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="53-字典-dict"><a class="markdownIt-Anchor" href="#53-字典-dict"></a> 5.3. 字典 (dict)</h3>
<h4 id="531-dictgetkey-default"><a class="markdownIt-Anchor" href="#531-dictgetkey-default"></a> 5.3.1. dict.get(key, default)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment"># 获取键 &#x27;b&#x27; 的值</span></span><br><span class="line">val1 = counts.get(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>)  <span class="comment"># -&gt; 1</span></span><br><span class="line"><span class="comment"># 获取键 &#x27;c&#x27; 的值，因不存在，返回默认值 0</span></span><br><span class="line">val2 = counts.get(<span class="string">&#x27;c&#x27;</span>, <span class="number">0</span>)  <span class="comment"># -&gt; 0</span></span><br></pre></td></tr></table></figure>
<h4 id="532-dictkeys"><a class="markdownIt-Anchor" href="#532-dictkeys"></a> 5.3.2. dict.keys()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> counts.keys():</span><br><span class="line">    <span class="built_in">print</span>(key) <span class="comment"># -&gt; 依次输出 &#x27;a&#x27;, &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">sorted_keys = <span class="built_in">sorted</span>(counts.keys()) <span class="comment"># -&gt; [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="533-dictvalues"><a class="markdownIt-Anchor" href="#533-dictvalues"></a> 5.3.3. dict.values()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> counts.values():</span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment"># -&gt; 依次输出 2, 1</span></span><br><span class="line"></span><br><span class="line">values_list = <span class="built_in">list</span>(counts.values()) <span class="comment"># -&gt; [2, 1]</span></span><br></pre></td></tr></table></figure>
<h4 id="534-dictitems"><a class="markdownIt-Anchor" href="#534-dictitems"></a> 5.3.4. dict.items()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># -&gt; a: 2</span></span><br><span class="line"><span class="comment"># -&gt; b: 1</span></span><br></pre></td></tr></table></figure>
<h2 id="6-collections"><a class="markdownIt-Anchor" href="#6-collections"></a> 6. Collections</h2>
<h3 id="defaultdict"><a class="markdownIt-Anchor" href="#defaultdict"></a> defaultdict</h3>
<p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">&#x27;N/A&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用<code>lambda</code> 可创建默认值<br>
否则的话默认是0</p>
<blockquote>
<p>这边还在等待更新中<br>
其实是刷题刷着刷着觉得应该开始总结经验还有防止忘记</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-enginex</title>
    <url>/Nginx-enginex/</url>
    <content><![CDATA[<details>
  <summary>索引</summary>
<ul>
<li><a href="#1-installation">1. installation</a></li>
<li><a href="#2-feature">2. feature</a>
<ul>
<li><a href="#21-nginx-%E7%9A%84%E7%81%B5%E9%AD%82%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9E%B6%E6%9E%84">2.1. <strong>Nginx 的灵魂</strong>:<strong>事件驱动的异步非阻塞架构</strong></a>
<ul>
<li><a href="#211-%E4%BC%A0%E7%BB%9F-read--write-%E6%96%B9%E5%BC%8F">2.1.1. 传统 read() + write() 方式</a></li>
<li><a href="#212-sendfile-%E6%96%B9%E5%BC%8F">2.1.2. sendfile() 方式</a></li>
</ul>
</li>
<li><a href="#22-master-worker">2.2. Master-Worker</a>
<ul>
<li><a href="#221-master-process">2.2.1. Master Process</a></li>
<li><a href="#222-worker-processes">2.2.2. Worker Processes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<h2 id="1-installation"><a class="markdownIt-Anchor" href="#1-installation"></a> 1. installation</h2>
<p><strong>on arch linux</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> pacman -Syu</span><br><span class="line">$ <span class="built_in">sudo</span> pacman -S nginx</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl start nginx.service</span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> nginx.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ sudo systemctl status nginx.service</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3loy@archlinux ~]$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:4f:fa:7f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp2s1</span><br><span class="line">    altname enx000c294ffa7f</span><br><span class="line">    inet 192.168.209.128/24 brd 192.168.209.255 scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft 1592sec preferred_lft 1367sec</span><br><span class="line">    inet6 fe80::98ef:2b0d:cbd3:648c/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"> <span class="comment">#  inet 192.168.209.128</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主机直接访问<a href="http://192.168.209.128/">http://192.168.209.128/</a>    就可以看到<code>Welcome to nginx!</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#user http;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load all installed modules</span></span><br><span class="line">include modules.d/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>block</code>
<ul>
<li><code>http { ... }</code>: 配置 <code>HTTP </code>相关功能的顶级块。几乎所有的 Web 服务配置都在这里面。</li>
<li><code>server { ... }</code>: 定义一个“虚拟主机”,可以在一个 <code>Nginx</code> 里配置多个 <code>server</code> 块，来托管不同的网站</li>
<li><code>location / { ... }</code>: 定义当请求的 URL 匹配某个路径时，应该如何处理。<code>location / </code>表示匹配所有请求。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/my-website/images</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;hello,this is our first website&lt;/h1&gt;&quot;</span> &gt; ~/my-website/index.html</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;this is about&lt;/p&gt;&quot;</span> &gt; ~/my-website/about.html</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak</span><br><span class="line"><span class="comment"># backup</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line"><span class="comment"># ... http 块内部 ...</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost; </span><br><span class="line">    <span class="comment"># ... 其他配置 ...</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /home/s3loy/my-website;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ... 其他配置 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> nginx -t</span><br><span class="line"><span class="comment">#配置成功即可</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl reload nginx</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://192.168.209.128/about.html">http://192.168.209.128/about.html</a>   发现<code>403 Forbidden</code></p>
<p>此时考虑到文件夹为新建且处于<code>whoami</code>用户下，所以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep <span class="string">&quot;nginx: worker process&quot;</span></span><br><span class="line">http        2179  0.0  0.1  15388  5140 ?        S    16:13   0:00 nginx: worker process</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">chmod</span> o+x /home/s3loy</span><br><span class="line">$ <span class="built_in">ls</span> -ld ~/my-website</span><br><span class="line">drwxr-xr-x 3 s3loy s3loy 4096 Jul 23 16:10 /home/s3loy/my-website</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接重返链接就发现页面可以刷新出来了</p>
<p><strong>当然这也很明显，请不要把网站放在自己的目录当中</strong>。出于隐私和安全考虑，默认权限非常严格</p>
<p>在<code>arch linux</code>当中，<code>http</code>推荐放在<code>/srv/http</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -ld /srv/http</span><br><span class="line">drwxr-xr-x 2 root root 4096 May  3 19:26 /srv/http</span><br></pre></td></tr></table></figure>
<p>在其他很多 <code>Linux</code> 系统上，常用目录是 <code>/var/www/html</code></p>
<h2 id="2-feature"><a class="markdownIt-Anchor" href="#2-feature"></a> 2. feature</h2>
<h3 id="21-nginx-的灵魂事件驱动的异步非阻塞架构"><a class="markdownIt-Anchor" href="#21-nginx-的灵魂事件驱动的异步非阻塞架构"></a> 2.1. <strong>Nginx 的灵魂</strong>:<strong>事件驱动的异步非阻塞架构</strong></h3>
<p>我们以这个简单的静态网页为例，当你请求静态文件时，<code>Nginx</code> 的 <code>Worker</code> 进程接收到请求，告诉操作系统内核：“把 <code>~/my-website/index.html</code> 这个文件的数据发给这个用户”。然后 <code>Worker</code> 进程就去处理其他请求了。当内核把文件数据准备好后，会通知 <code>Worker</code> 进程，<code>Worker</code> 进程再把数据发回给浏览器。这个过程极其高效，因为它利用了操作系统的 <code>sendfile</code> 机制，避免了数据在内核和用户空间之间的多次复制，<code>CPU</code> 占用极低。</p>
<hr>
<blockquote>
<p><code>sendfile</code>机制</p>
</blockquote>
<p><strong>用户空间 (<code>User Space</code>)</strong> 和 <strong>内核空间 (<code>Kernel Space</code>)</strong>。</p>
<ul>
<li><strong>用户空间：</strong> 你的应用程序（如 <code>Nginx</code> 进程）运行的地方。</li>
<li><strong>内核空间：</strong> 操作系统内核运行的地方，它能直接操作硬件（如磁盘、网卡）。</li>
</ul>
<h4 id="211-传统-read-write-方式"><a class="markdownIt-Anchor" href="#211-传统-read-write-方式"></a> 2.1.1. 传统 read() + write() 方式</h4>
<p>当 <code>Nginx</code> 需要发送一个静态文件给客户端时，传统的 I/O 流程如下：</p>
<ol>
<li><strong><code>read()</code> 系统调用：</strong> <code>Nginx</code> 进程发起 <code>read() </code>系统调用，请求读取文件。这会导致一次从<strong>用户空间到内核空间</strong>的上下文切换。</li>
<li><strong>第一次数据复制 (<code>DMA</code>)：</strong> <code>CPU</code> 指示 <code>DMA </code>控制器将文件内容从磁盘读取到<strong>内核空间的缓冲区</strong>。</li>
<li><strong>第二次数据复制 (<code>CPU</code>)：</strong> <code>CPU</code> 将数据从<strong>内核空间缓冲区</strong>复制到<strong>用户空间的 <code>Nginx </code>缓冲区</strong>。<code>read()</code> 调用返回，发生一次从<strong>内核空间到用户空间</strong>的上下文切换。</li>
<li><strong><code>write()</code> 系统调用：</strong> <code>Nginx</code> 进程拿到数据后，发起 <code>write() </code>系统调用，请求发送数据。再次发生一次从<strong>用户空间到内核空间</strong>的上下文切换。</li>
<li><strong>第三次数据复制 (<code>CPU</code>)：</strong> <code>CPU</code> 将数据从<strong>用户空间的<code>Nginx</code>缓冲区</strong>复制到<strong>内核空间的 <code>Socket </code>缓冲区</strong>（与网卡关联）。</li>
<li><strong>第四次数据复制 (<code>DMA</code>)：</strong> <code>DMA</code> 控制器将数据从<strong>内核空间的 <code>Socket</code> 缓冲区</strong>复制到网卡硬件中，然后发送出去。<code>write() </code>调用返回，再次发生一次从<strong>内核空间到用户空间</strong>的上下文切换。</li>
</ol>
<h4 id="212-sendfile-方式"><a class="markdownIt-Anchor" href="#212-sendfile-方式"></a> 2.1.2. sendfile() 方式</h4>
<p><code>sendfile()</code> 是一个系统调用，它把上述过程大大简化了。</p>
<ol>
<li><strong><code>sendfile() </code>系统调用：</strong> <code>Nginx</code> 进程发起<code>sendfile()</code>系统调用，它包含了输入（文件描述符）和输出（<code>Socket </code>描述符）的信息。发生一次从<strong>用户空间到内核空间</strong>的上下文切换。</li>
<li><strong>第一次数据复制 (<code>DMA</code>)：</strong> <code>DMA</code> 控制器将文件内容从磁盘读取到<strong>内核空间的缓冲区</strong>。</li>
<li><strong>第二次数据复制 (<code>CPU</code>)：</strong> <code>CPU</code> 将数据<strong>直接从内核空间的读缓冲区复制到内核空间的<code>Socket</code>缓冲区</strong>。数据完全没有进入过用户空间！</li>
<li><strong>第三次数据复制 (<code>DMA</code>)：</strong> <code>DMA </code>控制器将数据从<strong>内核空间的 <code>Socket </code>缓冲区</strong>复制到网卡硬件中。<code>sendfile() </code>调用返回，发生一次从<strong>内核空间到用户空间</strong>的上下文切换。</li>
</ol>
<p>总结一下高效之处：</p>
<ul>
<li><strong>2 次上下文切换</strong>：减少了一半。</li>
<li><strong>3 次数据复制</strong>：更重要的是，<strong>CPU 驱动的数据复制只有 1 次，且完全在内核空间内完成</strong>，避免了数据在内核和用户空间之间的拷贝。</li>
</ul>
<p><strong>真正的“零拷贝” (<code>Zero-Copy</code>)：</strong><br>
在更现代的硬件上，<code>sendfile()</code> 还能做到更极致的优化。如果网卡支持 “<code>Scatter-gather DMA</code>” 功能，那么第 3 步的 <code>CPU </code>复制也可以省掉。内核只需要把数据在缓冲区的位置和长度等描述信息传递给网卡，网卡就可以自己去内核缓冲区里拉取数据。此时，数据复制就只剩两次<code> DMA</code> 操作，<code>CPU </code>完全不参与数据拷贝，这就是真正的“零拷贝”。</p>
<blockquote>
<p><code>sendfile</code> 在<code>http</code>块中，可自行寻找。<code>/etc/nginx/nginx.conf</code></p>
</blockquote>
<h3 id="22-master-worker"><a class="markdownIt-Anchor" href="#22-master-worker"></a> 2.2. Master-Worker</h3>
<p>虽然我们用 <code>sudo</code> 来启动和管理 <code>Nginx</code>，但为了安全，<code>Nginx</code> 的 <code>Master </code>进程在启动后，会创建一些低权限的 <strong><code>Worker</code> 进程</strong>。真正去处理用户请求、读取网站文件的，正是这些 <code>Worker</code> 进程。</p>
<p>在 <code>Arch Linux</code> 上，这个低权限用户通常是<code> http</code>。在其他系统（如 <code>Debian/Ubuntu</code>）上可能是 <code>www-data</code>,可以把<code> Nginx</code> 的 <code>Worker</code> 进程想象成一个名叫 <code>http</code> 的普通访客。</p>
<p><code>403 Forbidden</code> 就是因为这个访客在某个环节被拦住了</p>
<h4 id="221-master-process"><a class="markdownIt-Anchor" href="#221-master-process"></a> 2.2.1. Master Process</h4>
<p><code>Master</code> 进程是 <code>Nginx </code>的入口和管理者，它以<code> root</code> 用户权限启动，因为它需要执行一些特权操作。它的核心职责包括：</p>
<ul>
<li><strong>读取和验证配置：</strong> 启动时，它会读取 <code>nginx.conf </code>并检查语法是否正确。</li>
<li><strong>绑定特权端口：</strong> 监听低于 <code>1024</code> 的端口（如 <code>80</code>, <code>443</code>）需要 <code>root</code> 权限。<code>Master</code> 进程负责绑定这些端口。</li>
<li><strong>创建和管理 Worker 进程：</strong> 根据配置 (<code>worker_processes</code>) 创建指定数量的 <code>Worker</code> 进程。这些 <code>Worker </code>进程会<strong>继承</strong>已经打开的监听端口。</li>
<li><strong>以低权限运行 Worker：</strong> 出于安全考虑，<code>Master</code> 进程会以一个普通用户（如<code>http</code>或 <code>www-data</code>）的身份来启动 <code>Worker</code> 进程。这样，即使 <code>Worker</code> 进程被嘿壳利用，其破坏能力也被限制在该用户的权限范围内。🤔</li>
<li><strong>处理控制信号：</strong> <code>Master</code> 进程负责响应来自管理员的指令，例如：
<ul>
<li><code>nginx -s reload</code>: 平滑重载配置。</li>
<li><code>nginx -s quit</code>: 优雅地关闭。</li>
<li><code>nginx -s stop</code>: 快速关闭。</li>
</ul>
</li>
<li><strong>监控 Worker 状态：</strong> 持续监控 <code>Worker</code> 进程的健康状况，如果某个 <code>Worker</code> 异常退出，<code>Master </code>会立即重新启动一个新的 <code>Worker</code> 来替代它。</li>
<li><strong>日志文件管理：</strong> 负责打开日志文件。</li>
</ul>
<p><strong>关键点：</strong> <code>Master</code> 进程不处理任何客户端的请求。它只做管理工作。</p>
<h4 id="222-worker-processes"><a class="markdownIt-Anchor" href="#222-worker-processes"></a> 2.2.2. Worker Processes</h4>
<p>Worker 进程是真正处理业务的“劳动力”。它们由 Master 进程创建，并以低权限用户运行。</p>
<p><strong>核心工作机制：事件驱动 + 异步非阻塞 I/O</strong></p>
<ol>
<li><strong>共享监听套接字 (<code>Shared Listening Sockets</code>):</strong><br>
所有 <code>Worker</code> 进程都从 <code>Master</code> 进程继承了同一个监听套接字（<code>listening socket</code>）。当一个新的客户端连接请求到达时，操作系统会唤醒这些正在等待的 <code>Worker</code> 进程。</li>
<li><strong>争抢连接 (<code>accept_mutex</code>):</strong><br>
为了避免多个 <code>Worker</code> 同时去处理同一个新连接（即“惊群效应” <code>Thundering Herd</code>），<code>Nginx </code>内部有一个 <code>accept_mutex</code> 锁。只有一个 <code>Worker </code>能成功获取到这个锁，然后调用 <code>accept() </code>来建立连接。这保证了连接处理的负载在多个 <code>Worker</code> 之间是相对均衡的。</li>
<li><strong>事件循环和 <code>epoll</code>:</strong><br>
每个 <code>Worker</code> 进程内部都有一个高效的<strong>事件循环</strong>。它利用操作系统的 <code>epoll</code> (在<code> Linux</code> 上) 或 <code>kqueue</code> (在 <code>BSD/macOS</code> 上) 这样的 <code>I/O</code> 多路复用技术。
<ul>
<li><strong>注册事件：</strong> 当一个 <code>Worker</code> 接受一个新连接后，它不会傻等客户端发数据。它只是把这个连接（<code>socket</code>）注册到<code>epoll</code>实例上，并告诉 <code>epoll</code>：“当这个连接上有数据可读时，请通知我。”</li>
<li><strong>等待事件：</strong> 然后，<code>Worker</code> 进程就调用 <code>epoll_wait()</code>，把自己“挂起”，等待 <code>epoll</code> 的通知。它不消耗 <code>CPU</code>。</li>
<li><strong>处理就绪事件：</strong> 当一个或多个连接上的事件就绪时（比如，客户端发来了数据，或者发送缓冲区变空可以继续写入了），<code>epoll_wait()</code> 会被唤醒，并返回一个“就绪事件”的列表。</li>
<li><strong>处理与再注册：</strong> <code>Worker</code> 进程遍历这个列表，对每个就绪的连接执行相应的<strong>非阻塞操作</strong>（如 <code>read()</code> 读取数据，<code>write()</code> 或 <code>sendfile()</code> 发送数据）。处理完一个连接后，它会再次向 <code>epol</code>l 更新这个连接需要监听的下一个事件。</li>
</ul>
</li>
</ol>
<p><strong>流程的关键优势：</strong></p>
<ul>
<li><strong>单线程高效处理：</strong> 每个 Worker 进程是单线程的，避免了线程切换的开销和锁的复杂性。</li>
<li><strong>永不阻塞</strong></li>
<li><strong>连接数与内存消耗解耦：</strong> 一个 Worker 可以轻松维护数万个连接</li>
</ul>
<hr>
<ul>
<li>[ ] to be continued</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-ownership-and-move</title>
    <url>/Rust-ownership-and-move/</url>
    <content><![CDATA[<h2 id="一点随笔"><a class="markdownIt-Anchor" href="#一点随笔"></a> 一点随笔</h2>
<p>这是s3的第一篇rust博客</p>
<p>rust好像一种“逆流而上”的选择<br>
悲观，并非源于对 <code>rust</code> 技术本身的怀疑，而是源于一个本科生对自身能力、时间成本和未来就业机会的理性权衡</p>
<p>也许这也只能永远当作一份<code>爱好</code>?</p>
<p>也许也是s3对未来的迷茫</p>
<p><code>完美主义</code>之下,rust给s3的吸引力并非一点两点:<br>
内存安全，性能高效…</p>
<p>甚至?给s3的感觉是一种代码艺术</p>
<p>s3不喜欢随波逐流,也确实总在捣鼓不常见的内容</p>
<p>真的可以做到<strong>最好</strong>吗?</p>
<hr>
<blockquote>
<p>致6EACzz:</p>
<p>s3会喜欢<code>if let</code>,可惜s3曾经不懂,但我们很难走在同一条路上了</p>
</blockquote>
<h2 id="ownership"><a class="markdownIt-Anchor" href="#ownership"></a> Ownership</h2>
<p><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">understanding-ownership</a></p>
<ul>
<li>[ ] On progress</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
</search>
